<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Magic on Magic</title>
    <link>/</link>
    <description>Recent content in Magic on Magic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 25 Oct 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>链表-leetCode-删除链表中的节点</title>
      <link>/2019/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>

&lt;h2 id=&#34;删除链表中的节点&#34;&gt;删除链表中的节点&lt;/h2&gt;

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。&lt;/p&gt;

&lt;p&gt;现有一个链表 &amp;ndash; head = [4,5,1,9]，它可以表示为: &lt;img src=&#34;https://s2.ax1x.com/2019/10/25/KwtOGq.png&#34; alt=&#34;示例&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例 1:
  输入: head = [4,5,1,9], node = 5
  输出: [4,1,9]
  解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.

示例 2:
  输入: head = [4,5,1,9], node = 1
  输出: [4,5,9]
  解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;

&lt;p&gt;从链表里删除一个节点 node 的最常见方法是修改之前节点的 next 指针，使其指向之后的节点。
&lt;img src=&#34;https://s2.ax1x.com/2019/10/25/KwUinS.png&#34; alt=&#34;pic&#34; /&gt;
因为，我们无法访问我们想要删除的节点 之前 的节点，我们始终不能修改该节点的 next 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。
&lt;img src=&#34;https://s2.ax1x.com/2019/10/25/KwUCX8.png&#34; alt=&#34;pic&#34; /&gt;
因为我们知道要删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
  node.val = node.next.val;
  node.next = node.next.next;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TS重新定义模块</title>
      <link>/2019/ts%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/ts%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</guid>
      <description>&lt;p&gt;重新定义模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;declare var am: any; // 支付宝

declare interface Window {
  ap: any; // 支付宝注入
}

declare module &#39;dva/dynamic&#39; {
  const dynamic: (config: any) =&amp;gt; React.ComponentType;
  export default dynamic;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-反转链表</title>
      <link>/2019/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h2 id=&#34;反转链表&#34;&gt;反转链表&lt;/h2&gt;

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;反转一个单链表。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例:
  输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
  输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;

&lt;p&gt;一、迭代
  - 第一个节点无前置节点 所以需要声明初始化一个前置节点prev
  - 开始迭代，结束提交为 当前节点不为null
  - 先把当前节点后置节点变为当前节点的前置节点
  - 然后把前置pre变为当前节点 因为下一次所需
  - 再把当前节点设为后置节点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let cur = head;
  let pre = null;
  while(cur) {
    let temp = cur.next; //  保存当前节点的后置节点 之后循环到下一个节点需要
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、递归&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？&lt;/li&gt;
&lt;li&gt;假设列表为：&lt;code&gt;n1 ​→ ... → nk−1 ​→ nk ​→ nk+1 ​→...→ nm ​→∅&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若从节点 &lt;code&gt;nk+1&lt;/code&gt;到 &lt;code&gt;nm&lt;/code&gt;已经被反转，而我们正处于 &lt;code&gt;nk&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n 1 ​ →...→n k−1 ​ →n k ​ →n k+1 ​ ←...←n m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们希望 &lt;code&gt;nk+1&lt;/code&gt; 的下一个节点指向 &lt;code&gt;nk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所以:&lt;code&gt;nk.next.next = nk&lt;/code&gt; &lt;em&gt;要小心的是 &lt;code&gt;n1&lt;/code&gt; 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (!head || !head.next) return head;
  let p = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return p;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-设计链表</title>
      <link>/2019/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h3 id=&#34;设计链表&#34;&gt;设计链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。&lt;/p&gt;

&lt;p&gt;在链表类中实现这些功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。&lt;/li&gt;
&lt;li&gt;addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。&lt;/li&gt;
&lt;li&gt;addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。&lt;/li&gt;
&lt;li&gt;addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。&lt;/li&gt;
&lt;li&gt;deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 假设链表为 5 -&amp;gt; 3 &amp;gt; 1
{
  val: 5,
  next: {
    val: 3,
    next: {
      val: 1,
      next: null
    }
  }
}
// 双链表的结构就会多一个prev
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;一-数组-不推荐&#34;&gt;一、数组（不推荐）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyLinkedList {
  constructor() {
    this.list = [];
  }
  get(index) {
    if (index &amp;lt; 0 || index &amp;gt;= this.list.length) return -1;
    return this.list[index];
  }
  addAtHead(val) {
    this.list.unshift(val);
  }
  addAtTail(val) {
    this.arr.push(val)
  }
  addAtIndex(index, val) {
    if (index &amp;lt; 0) { this.arr.push(val); return }
    if (index &amp;gt; this.arr.length) { return }
    this.arr.splice(index, 0, val)
  }
  deleteAtIndex(index) {
    if (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; this.arr.length) this.arr.splice(index, 1)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;二-对象设计单链表&#34;&gt;二、对象设计单链表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyLinkedList {
  constructor() {
    this.data = {};
  }
  get(index) {
    if (index &amp;lt; 0) return -1;
    let current = this.data;
    for (let i = 0; i &amp;lt; index; i++) {
      if (!current.next) return -1;
      current = current.next;
    }
    return current.val === undefined || current.val === null ? -1 : current.val;
  }
  addAtHead(val) {
    if (this.data.val === undefined || this.data.val === null) {
      this.data = {
        val: val,
        next: this.data,
      };
    } else {
      this.data = {
        val: val,
        next: null,
      };
    }
  }
  addAtTail(val) {
    let curr = this.data;
    while(curr.next) {
      curr = curr/next;
    }
    curr.next = {
      val: val,
      next: null,
    };
  }
  addAtIndex(index, val) {
    if (index &amp;lt; 0) return this.addAtHead(val);
    let curr = this.data;
    for (let i = 0; i &amp;lt; index - 1; i++) {
      if (!curr || !curr.next) return null;
      curr = curr.next;
    }
    if (!curr.val &amp;amp;&amp;amp; curr.val !== 0) return null;
    curr.next = {
      val: val,
      next: curr.next,
    };
  }
  deleteAtIndex(index) {
    if (index &amp;lt; 0) return null;
    if (index === 0) return this.data = this.data.next;
    let curr = this.data;
    for (let i = 0; i &amp;lt; index - 1; i++) {
      if (!curr.next || !curr.next.next) return null
      curr = curr.next;
    }
    if (!curr.next) return null;
    if (!curr.next.next) return curr.next = null;
    curr.next = curr.next.next;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;二-对象设计双链表&#34;&gt;二、对象设计双链表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyLinkedList {
  constructor () {
    this.data = null;
  }
  get(index) {
    if (index &amp;lt; 0) return -1;
    let curr = this.data;
    while (index &amp;gt; 0 &amp;amp;&amp;amp; curr) {
      curr = curr.next;
      index--;
    }
    return curr ? curr.val : -1;
  }
  addAtHead(val) {
    this.data = {
      val, next: this.data, prev: null
    }
    if (this.data.next) this.data.next.prev = this.data;
  }
  addAtTail(val) {
    if (this.data) {
      let curr = this.data;
      while (curr.next) {
        curr = curr.next;
      }
      curr.next = { val, next: null, prev: curr}
    } else {
      this.data = { val, next: null, prev: null }
    }
  }
  addAtIndex(index, val) {
    if (index &amp;lt;= 0) return this.addAtHead(val);
    let curr = this.data;
    for (let i = 0; i &amp;lt; index - 1; i++) {
      if (!curr || !curr.next) return null;
      curr = curr.next;
    }
    if (!curr) return null;
    let temp = curr.next;
    curr.next = {
      val, prev: curr, next: curr.next
    }
    if (temp) temp.prev = curr.next
  }
  deleteAtIndex(index) {
    if (index &amp;lt; 0) return null;
    let curr = this.data;
    while (index &amp;gt; 0) {
      if (!curr) return null;
      curr = curr.next;
      index--;
    }
    if (!curr) return null;
    if (!curr.prev &amp;amp;&amp;amp; !curr.next) {
      this.data = null;
    } else if (!curr.prev) {
      curr.next.prev = curr.prev;
      this.data = curr.next;
    } else if (!curr.next) {
      curr.prev.next = null;
    } else {
      curr.prev.next = curr.next;
      curr.next.prev = curr.prev;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-两数相加</title>
      <link>/2019/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>

&lt;h3 id=&#34;两数相加&#34;&gt;两数相加&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&lt;/p&gt;

&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
输出：7 -&amp;gt; 0 -&amp;gt; 8
原因：342 + 465 = 807
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;单链表的数据结构：&lt;code&gt;val&lt;/code&gt;属性存储当前的值，&lt;code&gt;next&lt;/code&gt;属性存储下一个节点的引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从链表表头开始，然后进行每一位进行相加，每位的数字在 0~9 之间，相加有可能会出现 &lt;em&gt;溢出&lt;/em&gt; 。
例如：5+7=12，这种情况下，将个位设置为当前值（也就是2），并将进位 carry=1 带入下一次迭代。进位必定是 0 | 1，因为两个数字相加（考虑到进位）最大和为 9+9+1=19。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。&lt;strong&gt;使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;先初始化一个哑结点&lt;/li&gt;
&lt;li&gt;初始化 sum 为 0&lt;/li&gt;
&lt;li&gt;进位 carry 初始化为 0&lt;/li&gt;
&lt;li&gt;遍历列表 l1 和 l2 直至到达它们的尾端，并对 sum 进行累加，将 l1 和 l2 赋值为下一个节点&lt;/li&gt;
&lt;li&gt;更新进位的值，carry = ~~(sum / 10carry=sum/10)&lt;/li&gt;
&lt;li&gt;创建一个数值为 (sum % 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点&lt;/li&gt;
&lt;li&gt;sum 赋值为 进位 carry，带入下一次循环&lt;/li&gt;
&lt;li&gt;将 carry 从初始化&lt;/li&gt;
&lt;li&gt;返回哑结点的下一个结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  let res = new ListNode(0)
      dummy = res,
      sum = 0, carry = 0;
  while(l1 || l2 || sum &amp;gt; 0) {
      if(l1) {
          sum += l1.val;
          l1 = l1.next;
      }
      if(l2) {
          sum += l2.val;
          l2 = l2.next;
      }
      carry = ~~(sum / 10);
      dummy.next = new ListNode(sum % 10)
      dummy = dummy.next;
      sum = carry;
      carry = 0;
  }
  return res.next;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-合并两个有序链表</title>
      <link>/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;由于单链表是线性的，使用递归方式将导致栈的使用也是线性的，当链表长度达到一定程度时，递归会导致爆栈，因此，现实中并不推荐使用递归方式来操作链表。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;合并两个有序链表&#34;&gt;合并两个有序链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;一、 递归&lt;/p&gt;

&lt;p&gt;可以使用 递归，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;思路&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素&lt;/li&gt;
&lt;li&gt;终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束&lt;/li&gt;
&lt;li&gt;返回值：每一层调用都返回排序好的链表头&lt;/li&gt;
&lt;li&gt;本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理&lt;/li&gt;
&lt;li&gt;O(m+n)O(m+n)，mm 为 l1的长度，nn 为 l2 的长度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if(l1 === null){
      return l2;
  }
  if(l2 === null){
      return l1;
  }
  if(l1.val &amp;lt; l2.val){
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
  }else{
      l2.next = mergeTwoLists(l1, l2.next);
      return l2;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、迭代&lt;/p&gt;

&lt;p&gt;可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;思路:

&lt;ul&gt;
&lt;li&gt;首先，我们设定一个哨兵节点 &lt;code&gt;preheat&lt;/code&gt; ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。&lt;/li&gt;
&lt;li&gt;在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  // 在返回节点之前保持对节点的不变引用
  const preheat = new ListNode(-1);
  let prev = preheat;

  while (l1 &amp;amp;&amp;amp; l2) {
    if (l1.val &amp;lt; l2.val) {
      prev.next = l1;
      l1 = l1.next;
    } else {
      prev.next = l2;
      l2 = l2.next;
    }
    prev = prev.next;
  }
  // 此时l1和l2中恰好有一个是非空的，将非空链表接在合并链表的后面
  prev.next = l1 ? l1 : l2;
  return preheat.next;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-回文链表</title>
      <link>/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h2 id=&#34;回文链表&#34;&gt;回文链表&lt;/h2&gt;

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;判断一个链表是否为回文链表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例 1:
  输入: 1-&amp;gt;2
  输出: false

示例 2:
  输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
  输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用2个指针，一个low，一个fast，fast是low的2倍，所以可以达到2分链表的效果&lt;/li&gt;
&lt;li&gt;在移动指针时同时对前半部分链表进行反转，最后直接比较被分开的2个链表&lt;/li&gt;
&lt;li&gt;因为不能改变当前slow的next，不然就无法跳到下一个元素，所以这里用pre和prepre实现指针的反转&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  if (!head || !head.next) return true;
  let slow = head;
  let fast = head.next;
  let pre = null;
  let prepre = null;
  while (fast &amp;amp;&amp;amp; fast.next) {
    // 反转前半段链表
    pre = slow;
    slow = slow.next;
    fast = fast.next.next;
    // 先移动指针再来反转
    pre.next = prepre;
    prepre = pre;
  }
  let p2 = slow.next;
  slow.next = pre;
  let p1 = !fast ? slow.next : slow;
  while(p1) {
    if (p1.val !== p2.val) return false;
    p1 = p1.next;
    p2 = p2.next;
  }
  return true;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>你真的了解webview么？</title>
      <link>/2019/webview/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/webview/</guid>
      <description>

&lt;p&gt;&lt;em&gt;文章转载自微信公众号 &lt;strong&gt;大转转FE&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;适用场景&#34;&gt;适用场景&lt;/h2&gt;

&lt;p&gt;像一些 App 的内嵌页面，提供各种各样的交互操作，其实webview的应用场景远远不止这些，其实在一些PC的软件里，和我们交互的也是我们的html页面，只是穿着webview的衣服，衣服太美而我们没有发现他们的真谛。&lt;/p&gt;

&lt;p&gt;另外，还有一些网络机顶盒里的交互，也是webview在和我们打交道，比如一些早期的IPTV里的EPG都是运行在webview里的，它们基于webkit内核，尽管我们使用的交互方式是遥控器。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;与app-native的交互&#34;&gt;与App native的交互&lt;/h2&gt;

&lt;p&gt;目前使用频率最多的，还是客户端内嵌的webview，都是webview打开m页去承接的。目前javascript和客户端（后面统称native）交互的常见方式有两种，一种是通过JSBridge的方式，另一种是通过schema的方式。&lt;/p&gt;

&lt;h3 id=&#34;jsbridge&#34;&gt;JSBridge&lt;/h3&gt;

&lt;p&gt;体现的形式其实就是，当我们在native内打开m页，native会在全局的window下，为我们注入一个Bridge。这个Bridge里面，会包含我们与native交互的各种方法、比如判断第三方App是否安装、获取网络信息等等功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 作用域下的JSBridge，
 * 和实例化后的getNetInfomation，
 * 均根据实际约定情况而定，
 * 这里只是用来举例说明
 */
const bridge = window.JSBridge;
console.log(bridge.getNetInfomation());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;IOS端: 在IOS中，主要使用&lt;code&gt;WebViewJavascriptBridge&lt;/code&gt;来注册，可以参考&lt;em&gt;Github WebViewJavascriptBridge&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];

[self.bridge registerHandler:@&amp;quot;ObjC Echo&amp;quot; handler:^(id data, WVJBResponseCallback responseCallback) {
	// to do...
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Android: 在Android中，需要通过addJavascriptInterface来注册&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class JSBridge {
    @JavascriptInterface //注意这里的注解。出于安全的考虑，4.2 之后强制要求，不然无法从 Javascript 中发起调用
    public void getNetInfomation(){
      // to do
    };
}
webView.addJavascriptInterface(new JSBridge();, &amp;quot;JSBridge&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;schema-url&#34;&gt;Schema url&lt;/h3&gt;

&lt;p&gt;如果说Bridge的方式是只能在native内部交互，那么&lt;code&gt;schame url&lt;/code&gt;的不紧可以在native内交互，也是可以跨app来交互的。&lt;code&gt;schema&lt;/code&gt;也是目前我们转转使用的主要方式，它类似一个伪协议的链接（也可以叫做统跳协议），比如：&lt;strong&gt;schema://path?param=abc&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在webview里，当m页发起schema请求时，native端会去进行捕获。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IOS端: 以UIWebView为例，在IOS中，UIWebView内发起网络请求时，可以通过delegate在native层来拦截，然后将捕获的schema进行触发对应的功能或业务逻辑（利用shouldStartLoadWithRequest）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType {
  // 获取scheme url后自行进行处理
  NSURL *url = [request URL];
  NSString *requestString = [[request URL] absoluteString];
  return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Android端: 在Android中，可以使用shouldoverrideurlloading来捕获schema url&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean shouldOverrideUrlLoading(WebView view, String url){
  //读取到url后自行进行分析处理

  //这里注意：如果返回false，则WebView处理链接url，如果返回true，代表WebView根据程序来执行url  
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;如何通过schema的方式可以进行跨端交互&#34;&gt;如何通过schema的方式可以进行跨端交互？&lt;/h2&gt;

&lt;p&gt;其实对于JavaScript，在webview里基本是一样的，也是发起一个schema的请求，只不过在native侧会有些许变化。&lt;/p&gt;

&lt;p&gt;首先，给大家普及一个小知识，就是在natvie中（包括IOS和Android），会通过schema找到相匹配的App。其中IOS不可以重复，就像appId一样；安卓可以重复，遇到重复情况时，会弹窗让用户选择其中之一。&lt;/p&gt;

&lt;p&gt;那么，有了这个知识点做铺垫，就可以理解，当我们在其他app中，像这个schema发起请求时，系统底层（IOS &amp;amp; Android）会通过schema去找到所匹配的app，然后将此App拉起。拉起app后，对应处理如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IOS端: 在IOS端内，会将schema作为参数传入一个提前定义好的回调函数内，然后执行该回调函数。此回调函数，可以通过得到的schema去进行解析，然后定向到app内的固定的某个页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString*)sourceApplication annotation:(id)annotation
  // 参数 url 即为获取的 schema
      
  // to do
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Android端: 在Android端内，会稍微麻烦一些，在外部的m页，会发起一个schema的伪协议链接，系统会去根据这个schema去检索，需要被拉起的App需要有一个配置文件，大致如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;activity
  android:name=&amp;quot;.activity.StartActivity&amp;quot;
  android:exported=&amp;quot;true&amp;quot;
&amp;gt;
&amp;lt;intent-filter&amp;gt;
    &amp;lt;action android:name=&amp;quot;android.intent.action.VIEW&amp;quot;/&amp;gt;
    &amp;lt;category android:name=&amp;quot;android.intent.category.DEFAULT&amp;quot;/&amp;gt;   
    &amp;lt;category android:name=&amp;quot;android.intent.category.BROWSABLE&amp;quot;/&amp;gt;        
    &amp;lt;data android:scheme=&amp;quot;zhuanzhuan&amp;quot;/&amp;gt; 
  &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activityandroid:name=&amp;quot;.activity.StartActivity&amp;quot;android:exported=&amp;quot;true&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上面的代码为例，在上面配置中scheme为zhuanzhuan，只要是 &amp;ldquo;zhuanzhuan://&amp;rdquo; 开头的schema的链接都会调起配置该schema的Activity(类似上面代码的 StartActivity)，此Activity会对这个 schema url 做处理，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StartActivity extends TempBaseActivity {

  Intent intent;
    
  @Override
  protected void onCreate(BundlesavedInstanceState) {       
    super.onCreate(savedInstanceState);
    intent = getIntent();      
    Uri uri = intent.getData();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如上面的代码，可以在此Activity中，通过 intent 中的 getData 方法，获取到传入的schema的相关信息，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/27374e51955cc775.jpg&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以在第三方app内，可以调起app的原理。当然现在市场上一些app，为了怕有流量流失，会对schema进行限制，只有plist白名单里的schema才能对应拉起，否则会被直接过滤掉。比如我们的wx爸爸，开通白名单后，才可以使用更多的jsApiList，通过schema的拉起就是其中之一，在此不做赘述…… :）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;webview的进化&#34;&gt;webview的进化&lt;/h2&gt;

&lt;p&gt;对于webview，要说进化、或者蜕变，让我第一想到的就是IOS的WKWebView了，每一个事物存在都有它的必然，让我们一起看看这个super版的webview。&lt;/p&gt;

&lt;h3 id=&#34;wkwebview的出现&#34;&gt;WKWebView的出现&lt;/h3&gt;

&lt;p&gt;目前混合开发已然成为了主流，为了提高体验，WKWebView在IOS8发布时，也随之一起诞生。在这之前IOS端一直使用的是UIWebView。&lt;/p&gt;

&lt;p&gt;从性能方面来说，WKWebView会比UIWebView高很多，可以算是一次飞跃。它采用了跨进程的方案，用 Nitro JS 解析器，高达 60fps 的刷新率。同时，提供了很好的H5页面支持，类比UIWebView还多提供了一个加载进度的属性。目前一些一线互联网app在IOS已经切换到了WKWebView，所以感觉我们无法拒绝。&lt;/p&gt;

&lt;p&gt;整个WKWebView的初始化也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;WKWebView *webView = [[WKWebView alloc] init];
NSURL *url = [NSURL URLWithString:@&amp;quot;https://m.zhuanzhuan.com&amp;quot;];
[webView loadRequest:[NSURLRequest requestWithURL:url]];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wkwebview-与-uiwebview的对比&#34;&gt;WKWebView 与 UIWebView的对比&lt;/h3&gt;

&lt;p&gt;上面有提到性能的提升，为什么 app 接入 WKWebView 之后，相对比 UIWebView 内存占用小那么多，主要是因为网页的载入和渲染这些耗内存和性能的过程都是由 WKWebView 进程去实现的（WKWebView是独立于app的进程）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/b6c28e21432a222c.jpeg&#34; alt=&#34;WKWebView&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样，互相进程独立相当于把整个App的进程对内存的占用量减少，App进程会更为稳定。况且，即使页面进程崩溃，体现出来的就是页面白屏或载入失败，不会影响到整个App进程的崩溃。&lt;/p&gt;

&lt;p&gt;除了上面说的性能以外，WKWebView会比UIWebView多了一个询问过程。在服务器完成响应之后，会询问获取内容是否载入到容器内，在控制上会比UIWebView更细粒度一点，也可以在一些通信上更好的和m页进行交互。大概流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/f019036d9012a991.jpeg&#34; alt=&#34;stream&#34; /&gt;&lt;/p&gt;

&lt;p&gt;WKWebView 的代理协议为 WKNavigationDelegate，对比 UIWebDelegate 首先跳转询问，就是载入 URL之前的一次调用，询问开发者是否下载并载入当前 URL，UIWebView 只有一次询问，就是请求之前的询问，而 WKWebView 在 URL 下载完毕之后还会发一次询问，让开发者根据服务器返回的 Web 内容再次做一次确定。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;任重而道远&#34;&gt;任重而道远&lt;/h2&gt;

&lt;p&gt;前面说到WKWebView这么赞，其实开发中也有一些痛点。不同于UIWebView，WKWebView很多交互都是异步的，所以在很大程度上，在和m页通信的时候，提高了开发成本。&lt;/p&gt;

&lt;h3 id=&#34;cookie&#34;&gt;cookie&lt;/h3&gt;

&lt;p&gt;首先就是cookie问题，这个目前我认为也是WKWebView在业界的一个坑。之前出现过一个问题，就是在IOS登陆完成后，马上进入m页，会有登录态的cookie获取不到的问题。这个问题在UIWebView中是不存在的。&lt;/p&gt;

&lt;p&gt;经过调研发现，主要问题是UIWebView对cookie是通过NSHTTPCookieStorage来统一处理的，服务端响应时写入，然后在下次请求时，在请求头里会带上相应的cookie，来做到m页和native共享cookie的值。&lt;/p&gt;

&lt;p&gt;但是在WKWebView中，则不然。它虽然也会对NSHTTPCookieStorage来写入cookie，但却不是实时存储的。而且从实际的测试中发现，不同的IOS版本，延迟的时间还不一样，无意对m页的开发者是一种挑战。同样，发起请求时，也不是实时读取，无法做到和native同步，导致页面逻辑出错。&lt;/p&gt;

&lt;p&gt;针对这个问题，目前我们转转的解决方法是需要客户端手动干预一下cookie的存储。将服务响应的cookie，持久化到本地，在下次webview启动时，读取本地的cookie值，手动再去通过native往webview写入。大致流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/f06684b50c93ab95.jpeg&#34; alt=&#34;stream&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然这也不是很完美的解决方案，因为偶尔还有spa的页面路由切换的时候丢失cookie的问题。&lt;/p&gt;

&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;

&lt;p&gt;除了cookie以外，WKWebView的缓存问题，最近我们也在关注。由于WKWebView内部默认使用一套缓存机制，开发者可以操作的权限会有限制，特别是IOS8版本，也许是当时刚诞生WKWebView的缘故，还很不完善，根本没法操作（当然相信IOS8很快会退出历史舞台）。对于一些m页的静态资源，偶尔会出现缓存不更新的情况，着实让人头疼。&lt;/p&gt;

&lt;p&gt;但在IOS 9 之后，系统提供了缓存管理的接口 WKWebsiteDataStore。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// RemoveCache
NSSet *websiteTypes= [NSSet setWithArray:@[WKWebsiteDataTypeDiskCache, WKWebsiteDataTypeMemoryCache]];
NSDate *date = [NSDate dateWithTimeIntervalSince1970:0];
[[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteTypes modifiedSince:date completionHandler:^{}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于IOS8，就只能通过删除文件来解决了，一般WKWebView的缓存数据会存储在这个目录里：&lt;code&gt;~/Library/Caches/BundleID/WebKit/&lt;/code&gt;，可通过删除该目录来实现清理缓存。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;还有webview的通病，就是我们每次首次打开m页时，都要有webview初始化的过程，那么如何减少初始化webview的时间，也是我们可以提高页面打开速度的一个重要环节&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-相交链表</title>
      <link>/2019/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h3 id=&#34;相交链表&#34;&gt;相交链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/09/27/uMQiZ9.png&#34; alt=&#34;pic&#34; /&gt;
&lt;img src=&#34;https://s2.ax1x.com/2019/09/27/uMQFaR.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意：
- 如果两个链表没有交点，返回 null.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。&lt;/p&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;根据题目意思&lt;/p&gt;

&lt;p&gt;如果两个链表相交，那么相交点之后的长度是相同的&lt;/p&gt;

&lt;p&gt;我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。
为此，我们必须消除两个链表的长度差&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历&lt;/li&gt;
&lt;li&gt;如果 pA 到了末尾，则 pA = headB 继续遍历&lt;/li&gt;
&lt;li&gt;如果 pB 到了末尾，则 pB = headA 继续遍历&lt;/li&gt;
&lt;li&gt;比较长的链表指针指向较短链表head时，长度差就消除了&lt;/li&gt;
&lt;li&gt;如此，只需要将最短链表遍历两次即可找到位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/totalimgs/xtjd.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var getIntersectionNode = function(headA, headB) {
  if (headA === null || headB === null) return null;
  let pA = headA;
  let pB = headB;
  while(pA !== pB) {
    pA = (pA === null) ? headB : pA.next;
    pB = (pB === null) ? headA : pB.next;
  }
  return pA;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-环形链表</title>
      <link>/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h3 id=&#34;环形链表&#34;&gt;环形链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;

&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 -1，则在该链表中没有环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;一、由上到下给每一层遍历到的结点做上标记，如果在下一个结点中出现了这个标记，则表示存在环形结构。如果不想篡改原始数据，可以先用 &lt;code&gt;temp&lt;/code&gt; 保存。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  while (head) {
    if (head.val === &#39;k.top&#39;) return true;
    head.val = &#39;k.top&#39;;
    head = head.next;
  }
  return false;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;二、利用 &lt;code&gt;JSON.stringify()&lt;/code&gt; 不能字符串化含有循环引用的结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  try {
    JSON.stringify(head);
    return false;
  } catch (e) {
    return true;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;三、*(双指针法）*设置一快一慢两个指针，快指针一次走两步到 .next.next，慢指针一次走一步到 .next，如果链表不存在环形结构，那么快指针和慢指针不会相遇。如果存在环形结构，快指针总会和慢指针相遇。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null || head.next === null) return false;
  let slow = head;
  let fast = head.next;
  while (slow !== fast) {
    if (fast === null || fast.next === null) return false;
    slow = slow.next;
    fast = fast.next;
  }
  return true;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-移除链表元素</title>
      <link>/2019/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</guid>
      <description>

&lt;h3 id=&#34;移除链表元素&#34;&gt;移除链表元素&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;删除链表中等于给定值 val 的所有节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例:
输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6
输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
  let tem = head;
  let pre = null;
  while (tem) {
    if (tem.val === val) {
      if (pre) {
        pre.next = tem.next;
      } else {
        head = tem.next;
      }
    } else {
      pre = tem;
    }
    tem = tem.next;
  }
  return head;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var removeElements = function(head, val) {
  if (!head) return null;
  if (head.val === val) return removeElements(head.next, val);
  head.next = removeElements(head.next, val);
  return head;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>pm2</title>
      <link>/2019/pm2/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/pm2/</guid>
      <description>

&lt;h3 id=&#34;pm2-的安装提示处理&#34;&gt;PM2 的安装提示处理&lt;/h3&gt;

&lt;p&gt;在本地安装 PM2 之后，可能会看到下面的这个提示，可以按照提示操作一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Since PM2’s deployment command runs on a non-interactive SSH connection, we need to resolve this by commenting out a few lines from the semaphoreci user’s ~/.bashrc file. We’re already logged in as this user on our droplet, so we simply need to open up this file and comment this out:


Comment the following lines:

#If not running interactively, don&#39;t do anything
#case $- in
#    *i*) ;;
#      * return;;
#esac

and this in /etc/bash.bashrc

# If not running interactively, don&#39;t do anything
[ -z &amp;quot;$PS1&amp;quot; ] &amp;amp;&amp;amp; return
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;尝试-pm2-启动服务&#34;&gt;尝试 PM2 启动服务&lt;/h3&gt;

&lt;p&gt;如果一个网站的服务，必须通过命令行 node server.js 来启动，启动后，退出命令行服务就终止，这显然不符合我们的预期。而即便是服务能持续运行，一旦遇到异常情况服务即终止，也是不理想的，这时候就需要有一种能够守护进程的工具或者服务，来把已经挂起的服务再次重启，这就是服务常驻的基本需求了。对于 Node.js 来说，有很多工具可以帮我们做到这一点，PM2 就是其中一个，之前我们写了这样一个静态站点代码 - app.js：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)

const homePage = `
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
      &amp;lt;title&amp;gt;Node.js 部署上线示例&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;h1&amp;gt;慕课网 Node.js 部署发布&amp;lt;/h1&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
`

http.createServer((req, res) =&amp;gt; {
  res.statusCode = 200
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)
  res.end(homePage)
}).listen(4321, () =&amp;gt; {
  console.log(&#39;Server running at 4321&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要把一个静态站点开起来，需要满足 2 个条件:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，这个站点可以持续稳定地提供服务；&lt;/li&gt;
&lt;li&gt;第二，这个站点可以从外网直接访问到，比如通过域名访问到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，我们的端口是跑在 4321 的，这显然不满足第二个条件，我们需要从外网通过 80 端口来访问。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们先解决第一个问题：让服务可以持续稳定地运行。（第二个问题留到下一个节来解决。）通过 node app.js 启动服务文件，服务就跑起来了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node app&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们通过浏览器来访问，就可以看到 Node.js 服务返回的页面内容了，但是一旦退出命令行，这个会话状态就会中断，随之 Node.js 服务也会终止。显然这不是我们想要的状态，我们希望服务不仅可以在后台运行，而且在出现异常的时候还可以自动重启。这时我们就可以用到 PM2 这个 Node.js 部署和进程管理工具，不作过多解释，直接来用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不加任何参数的话，PM2 会自动初始化一些基础参数，来把服务跑起来。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pm2 start app.js&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;补充-pm2-常用命令&#34;&gt;补充：PM2 常用命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过 PM2 跑服务器的时候，是可以进行集群配置的，也就是指定在几个核上运行几个进程：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pm2 start app.js -i 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i 后面跟的 2 表示启动 2 个 server 实例，如果输入 0 的话，则按照当前服务器实际的 CPU 核数来启动多个 server，启动后，我们通过 pm2 ls 来看看已经启动的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;~ pm2 ls
┌────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│Name│id│mode│status │↺     │cpu│memory│       │
├────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online│0  │19%   │28.4 MB│
│app │1 │N/A │cluster│online│0  │0%    │20.3 MB│
└────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pm2-实时扩容集群&#34;&gt;PM2 实时扩容集群&lt;/h4&gt;

&lt;p&gt;如果发现线上的服务响应比较吃力，而 CPU 核数没有吃满的话，我们可以实时扩容集群，通过 scale 命令来实现，比如：&lt;code&gt;pm2 scale app +1&lt;/code&gt;，这里的 +1 就是扩容一个服务实例，其实就是增加一个 cluster 的 worker 子进程，扩容后的应用效果如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[PM2] Scaling up application
┌─────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│ Name│id│mode│status │↺     │cpu│memory│       │
├─────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│ app │0 │N/A │cluster│online│0  │0%    │33.6 MB│
│ app │1 │N/A │cluster│online│0  │0%    │34.2 MB│
│ app │2 │N/A │cluster│online│0  │0%    │19.9 MB│
└─────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pm2-终止某个进程&#34;&gt;PM2 终止某个进程&lt;/h4&gt;

&lt;p&gt;有时候如果某个进程明显卡住了，或者线上负载不大，可以杀掉部分进程，通过：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;e12-cluster git:(master) ✗ pm2 stop 1
[PM2] Applying action stopProcessId on app [1](ids: 1)
[PM2] [app](1) ✓
┌────┬──┬────┬───────┬───────┬───┬──────┬───────┐
│Name│id│mode│status │↺      │cpu│memory│       │
├────┼──┼────┼───────┼───────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online │0  │0%    │33.6 MB│
│app │1 │N/A │cluster│stopped│0  │0%    │0 B    │
│app │2 │N/A │cluster│online │0  │0%    │33.6 MB│
└────┴──┴────┴───────┴───────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到进程 ID 为 1 的 worker 已经是 stopped 状态。&lt;/p&gt;

&lt;h4 id=&#34;pm2-平滑重启进程&#34;&gt;PM2 平滑重启进程&lt;/h4&gt;

&lt;p&gt;有时候，如果想要某个比较吃内存的进程可以重启，或者想要所有的 worker 都重启，但是又不希望影响进程正常处理用户的请求，可以使用 PM2 的 gracefulReload 命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜ pm2 reload app
Use --update-env to update environment variables
[PM2] Applying action reloadProcessId on app [app](ids: 0,1,2)
[PM2] [app](1) ✓
[PM2] [app](0) ✓
[PM2] [app](2) ✓
➜ pm2 ls
┌────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│Name│id│mode│status │↺     │cpu│memory│       │ 
├────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online│1  │6.8%  │37.4 MB│
│app │1 │N/A │cluster│online│0  │6.8%  │37.4 MB│
│app │2 │N/A │cluster│online│1  │6.4%  │37.5 MB│
└────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样所有的子进程又原地满血复活了，当然也存在这种情况，即某些进程上的未处理连接或任务的确很重，比如有一些大而重的文件 IO 或者数据库 IO 在等待，会导致 reload 失败。这时候可以指定一个超时时间，命令会退化到 restart 模式，强制杀死进程再重启；或者我们可以在代码中再友好一些，当它收到 PM2 要重启的时候，在程序里把一些任务清空然后让服务重启：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// PM2 会发出 SIGINT 事件，我们监听事件
process.on(&#39;SIGINT&#39;, function() {
  // 处理一些任务然后信号交还给 PM2 来重启服务
  db.stop(function(err) {
    process.exit(err ? 1 : 0)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pm2.io/doc/en/runtime/overview/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PM2 的文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Unitech/pm2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PM2 的仓库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置-pm2-一健部署项目目录&#34;&gt;配置 pm2 一健部署项目目录&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以先在本地仓库加一份 PM2 的部署文件 &lt;code&gt;ecosystem.yaml&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apps:
  - script: index.js
    name: NodeDeployStatic
    env:
      COMMON_VARIABLE: true
    env_production:
      NODE_ENV: production
deploy:
  production:
    user: rn_manager
    host:
      - 116.62.201.97
    port: &#39;39999&#39;
    ref: origin/master
    repo: git@git.dev.tencent.com:s_auto/muke.git
    # 服务器上项目部署的目录，会在/www/node-deploy-static下初始化一个production文件夹
    # 配置文件会自动从git上面拉取静态网站代码到此路径
    path: /www/node-deploy-static/production
    
    ssh_options: StrictHostKeyChecking=no
    pre-deploy: git fetch --all
    post-deploy: &#39;npm i &amp;amp;&amp;amp; pm2 startOrRestart ecosystem.yaml --env production&#39;
    env:
      NODE_ENV: production
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;运行：&lt;code&gt;pm2 deploy ./ecosystem.yaml production setup&lt;/code&gt;，*注：有可能会报：Permission denied（权限不足），可以到服务器上使用 &lt;code&gt;sudo chmod 777 /www/&lt;/code&gt; 这个命令对用户的权限为可读、可写、可执行（远程）*，输出内容如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;--&amp;gt; Deploying to production environment
--&amp;gt; on host 116.62.201.97
  ○ hook pre-setup
  ○ running setup
  ○ cloning git@git.dev.tencent.com:s_auto/muke.git
  ○ full fetch
Cloning into &#39;/www/node-deploy-static/production/source&#39;...
  ○ hook post-setup
  ○ setup complete
--&amp;gt; Success
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当前的服务所运行的文件夹，source 是 clone 下来的源码，shared 里面是日志文件和 pid 之类，其中 current 是 source 的软连接，两者是一样的代码，然后通过 &lt;code&gt;sudo chown -R $USER:$USER /www&lt;/code&gt; 可以让权限被当前用户访问，或者更暴力一点：&lt;code&gt;sudo chmod 755 /www/node-deploy-vue&lt;/code&gt;。等到服务器的文件夹都安置后，就可以从本地利用 PM2 往服务器进行部署了。&lt;/p&gt;

&lt;h3 id=&#34;从本地发布上线和更服务器的部署项目&#34;&gt;从本地发布上线和更服务器的部署项目&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;本地目录下输入命令：&lt;code&gt;pm2 deploy ecosystem.yaml production&lt;/code&gt; 更新和运行，&lt;em&gt;注：使用nvm安装的node和pm2 会报 &lt;code&gt;bash: pm2: command not found / post-deploy hook failed / Deploy failed&lt;/code&gt;，网上搜出来说是没有进行加 软链接&amp;ndash;待定&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>安装与配置MongoDB数据库</title>
      <link>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>

&lt;p&gt;服务器系统为 Ubuntu 14.04&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mongodump&lt;/code&gt; 逻辑备份工具。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongorestore&lt;/code&gt; 逻辑恢复工具。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongoexport&lt;/code&gt;  数据导出工具。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongoimport&lt;/code&gt;  数据导入工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用 Navicat for MongoDB 来管理数据库&lt;/p&gt;

&lt;h3 id=&#34;安装-mongodb-并开启等命令&#34;&gt;安装 MongoDB 并开启等命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.mongodb.com/manual/administration/install-enterprise/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MongoDB社区安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;加入公钥 &lt;del&gt;&lt;code&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6&lt;/code&gt;&lt;/del&gt; 使用后面这个命令：&lt;code&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为 MongoDB 创建一个列表文件，可以选择使用 Aliyun 的镜像文件 &lt;del&gt;&lt;code&gt;echo &amp;quot;deb [ arch=amd64 ] http://mirrors.aliyun.com/MongoDB/apt/ubuntu trusty/MongoDB-org/4.0 multiverse&amp;quot; | sudo tee /etc/apt/sources.list.d/MongoDB-org-4.0.list&lt;/code&gt;&lt;/del&gt; &lt;code&gt;echo &#39;deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen&#39; | sudo tee /etc/apt/sources.list.d/mongodb.list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重新加载更新本地的包库 &lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装 MongoDB 稳定版 &lt;code&gt;sudo apt-get install -y MongoDB-org&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;在安装的时候有可能会遇到这个问题：定位不到本地的 MongoDB-org 的安装包，可能是因为我们使用的是阿里云的服务器，所以默认的是阿里云的源。可以先把阿里云的源屏蔽掉试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vi /etc/apt/apt.conf
# 把下面一行给注释掉，在前面加一个#号即可：
Acquire::http::Proxy &amp;quot;http://mirrors.aliyun.com/&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;开启命令：&lt;code&gt;sudo service mongod start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看 MongoDB 是否成功开始服务，使用 &lt;code&gt;cat /var/log/mongodb/mongod.log&lt;/code&gt; 查看 MongoDB 日志文件，或者直接使用命令链接一下：&lt;code&gt;mongo&lt;/code&gt; &amp;ndash;&lt;em&gt;默认情况下，运行此命令将查找在localhost接口上侦听端口27017的MongoDB服务器（如果您想连接到在不同端口上运行的MongoDB服务器，请使用-port选项。例如，如果要连接到侦听端口22222的本地MongoDB服务器，则会发出以下命令：&lt;code&gt;mongo --port 22222&lt;/code&gt;）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;如果没有成功进入 MongoDB 的命令行界面，可以检查下阿里云安全组包括本地的防火墙 27017 端口有没有开启（MongoDB 的端口是默认的 27017 端口），如果能从终端进入到 MongoDB 命令行环境，说明我们的 MongoDB 服务开启成功了。&lt;/li&gt;
&lt;li&gt;停止数据库服务：&lt;code&gt;sudo service mongod stop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启数据库服务：&lt;code&gt;sudo service mongod restart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;检查 MongoDB 服务状态：&lt;code&gt;sudo service mongod status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;状态统计摘要列表（连续）：&lt;code&gt;mongostat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;状态统计摘要列表（5行，每2秒汇总）：&lt;code&gt;mongostat --rowcount 5 2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：输入 &lt;code&gt;moongo&lt;/code&gt; 后，报 &lt;code&gt;BadValue Invalid or no user locale set. Please ensure LANG and/or LC_* environment variables are set correctly&lt;/code&gt;，可以 使用 &lt;code&gt;locale-gen en_US.UTF-8&lt;/code&gt; 这个命令来生成缺少的语言环境，然后重新启动 数据库&lt;/p&gt;

&lt;h3 id=&#34;修改-mongodb-数据库默认运行端口&#34;&gt;修改 MongoDB 数据库默认运行端口&lt;/h3&gt;

&lt;p&gt;现在服务器上 MongoDB 运行的端口是默认的 27017 端口，全世界都知道，也是出于最最基本的安全考虑。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开 MongoDB 数据库配置文件：&lt;code&gt;sudo vi /etc/mongod.conf&lt;/code&gt; &lt;strong&gt;输入法必须为英文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以把 net 下面的 port 改成一个你喜欢的端口号，比如 19999。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;storage:
  dbPath: /var/lib/MongoDB
  journal:
    enabled: true
#  engine:
#  mmapv1:
#  wiredTiger:

# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path: /var/log/MongoDB/mongod.log

# network interfaces
net:
  port: 19999
  bindIp: 127.0.0.1
  
#processManagement:
#security:
  #authorization: &#39;enabled&#39;

#operationProfiling:
#replication:
#sharding:
## Enterprise-Only Options:

#auditLog:
#snmp
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;保存后重启服务：&lt;code&gt;sudo service mongod restart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加端口号后连接：&lt;code&gt;mongo --port 19999&lt;/code&gt; &lt;em&gt;提醒：MongoDB 的运行端口是在 27017 的，这里将 MongoDB 的默认端口修改后，比如改成 19999，那么对应的 iptables 也要更新下，包括阿里云的安全组也要配置下，这里容易被遗忘。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;本地线上的数据导入导出&#34;&gt;本地线上的数据导入导出&lt;/h3&gt;

&lt;h4 id=&#34;本地安装-和运行-mongodb&#34;&gt;本地安装 和运行 mongodb&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以现在本地搭建一个数据库，使用 &lt;code&gt;brew&lt;/code&gt; 来安装 &lt;code&gt;mongodb&lt;/code&gt;：&lt;code&gt;brew install mongodb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建一个数据库存储目录：&lt;code&gt;sudo mkdir -p /data/db&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动 mongodb，默认数据库目录即为 /data/db：&lt;code&gt;sudo mongod&lt;/code&gt; || &lt;code&gt;brew services start mongodb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重新启动：&lt;code&gt;brew services restart mongodb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;往线上空库导入单表数据或数据库&#34;&gt;往线上空库导入单表数据或数据库&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;把本地数据导入到本地数据库：&lt;code&gt;mongorestore -p 27017 -d [dbnames] [file-path]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对本地数据库进行整库备份，把数据库导入 &lt;code&gt;[local-file-name]&lt;/code&gt; 下，然后在压缩打包成 &lt;code&gt;[file-name].tar.gz&lt;/code&gt; 文件包&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mongodump -h 127.0.0.1:27017 -d [dbname] -o [local-file-path]

# tar 是打包
# tar zxvf 解压
# tar zcvf 压缩
# tar xvf 解压
tar zcvf [file-name].tar.gz [local-file-name]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;scp&lt;/code&gt; 上传到服务器 &lt;code&gt;scp -P 39999 ./imooc-movie.tar.gz rn_manager@116.62.201.97:/home/rn_manager/loaclBD/&lt;/code&gt;。注：服务器上找不到目录可以新建一个目录&lt;/li&gt;
&lt;li&gt;使用  &lt;code&gt;tar xvf ./loaclBD/imooc-movie.tar.gz&lt;/code&gt; 解压&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;mongorestore --host 127.0.0.1:19999 -d imooc-movie ./imooc-movie/imooc-movie/&lt;/code&gt; 导入数据到数据库中 &lt;em&gt;服务器上操作，执行这个命令时在当前目录下不能有 db 这个目录&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;为非空数据库导入数据&#34;&gt;为非空数据库导入数据&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;例如需要为一个已有的数据库导入一张或者几张单表，这种情况适用于：新增一些用户列表，新增一些创意数据，或者初始化一些管理员角色等。&lt;/li&gt;
&lt;li&gt;有一个 xxx 的用户，它是有超级权限的，我们希望通过本地的这张用户表导入到线上以后，等到应用发布了，这个应用就默认拥有了一个 xxx 的高权限用户，通过它就能管理应用的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;首先，需要在本地把这张用户表导出来：&lt;code&gt;mongoexport -d imooc-movie -c users -q &#39;{&amp;quot;name&amp;quot;: {$ne: null}}&#39; -o ./movie-users.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后上传这张表到服务器：&lt;code&gt;scp -P 39999 ./movie-users.json rn_manager@116.62.201.97:/home/rn_manager/loaclBD/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后登录到服务器上导入用户数据：&lt;code&gt;mongoimport --host 127.0.0.1:19999 -d imooc-movie -c users ./movie-users.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果导入了数据库之后后悔了，可以通过 &lt;code&gt;mongo --host 127.0.0.1:19999 imooc-movie --eval &amp;quot;db.dropDatabase()&amp;quot;&lt;/code&gt; 命令来删除数据库&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;为项目配置数据库读写权限&#34;&gt;为项目配置数据库读写权限&lt;/h4&gt;

&lt;p&gt;MongoDB 权限系统有一个大概的了解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MongoDB 是没有默认管理员账号，所以要先添加管理员账号，再开启权限认证。&lt;/li&gt;
&lt;li&gt;只有在切换到 admin 数据库后，添加的账号才是管理员账号。&lt;/li&gt;
&lt;li&gt;用户只能在用户所在数据库登录，包括管理员账号。&lt;/li&gt;
&lt;li&gt;管理员可以管理所有数据库，但是不能直接管理其他数据库，要先在 admin 数据库认证后才可以。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;首先是对整个 MongoDB 的数据库设立一个超级权限，其实就是一个管理员，&lt;code&gt;mongo -p 19999&lt;/code&gt;  从服务器进入到数据库命令行模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 切换到 admin
use admin
# 创建管理员权限的账号
# db.createUser({user: &#39;dba&#39;,pwd:&#39;123456.!$&#39;,roles:[{role:&#39;root&#39;,db:&#39;admin&#39;}]})
db.createUser({user: &#39;test_owner&#39;,pwd:&#39;123456.!$&#39;,roles:[{role:&#39;userAdminAnyDatabase&#39;,db:&#39;admin&#39;}]})
&amp;gt; Successfully added user: {
    &amp;quot;user&amp;quot; : &amp;quot;test_owner&amp;quot;,
    &amp;quot;roles&amp;quot; : [
      {
        &amp;quot;role&amp;quot; : &amp;quot;userAdminAnyDatabase&amp;quot;,
        &amp;quot;db&amp;quot; : &amp;quot;admin&amp;quot;
      }
    ]
  }
# 用刚创建的用户授权进入
db.auth(&#39;test_owner&#39;, &#39;123456.!$&#39;)
# 切换到业务数据库
use imooc-movie
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;然后添加普通用户，配置应用调用权限&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 为业务数据库添加一个读写权限的账号
db.createUser({user:&#39;ordinary_test&#39;,pwd:&#39;123456.f&#39;,roles:[{role:&#39;readWrite&#39;,db:&#39;imooc-movie&#39;}]})
&amp;gt; Successfully added user: {
    &amp;quot;user&amp;quot; : &amp;quot;ordinary_test&amp;quot;,
    &amp;quot;roles&amp;quot; : [
      {
        &amp;quot;role&amp;quot; : &amp;quot;readWrite&amp;quot;,
        &amp;quot;db&amp;quot; : &amp;quot;imooc-movie&amp;quot;
      }
    ]
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;再为这个数据库创建一个备份角色，权限配置为可读&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;db.createUser({user: &#39;imooc_movie_wheel&#39;, pwd: &#39;123456..&#39;, roles: [{role: &#39;read&#39;, db: &#39;imooc-movie&#39;}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;开启验证模式，打开配置文件：&lt;code&gt;sudo vi /etc/mongod.conf&lt;/code&gt; &lt;em&gt;Mac 上输入 &lt;code&gt;brew list mongodb&lt;/code&gt; 找到安装目录，然后进一步找到配置文件&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#security:
  #authorization: enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面这 2 行代码的注释拿掉，如果没有的话，需要输入这 2 行来配置 MongoDB 的认证模式，然后，按下 esc 键，同时按下 shift + 冒号键，输入 wq! 回车就保存了，再把 MongoDB 重启一下，用刚才介绍的命令：&lt;code&gt;sudo service mongod restart&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;对数据库建立自动备份&#34;&gt;对数据库建立自动备份&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;先来创建存放任务文件的目录和目标文件：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo mkdir -p /www/tasks
sudo touch /www/tasks/movie.backup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;用来存放备份文件的目录也可以创建下：&lt;code&gt;sudo mkdir -p /www/dbbackup/movie/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编辑这个备份脚本：&lt;code&gt;sudo vi /www/tasks/movie.backup.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

#备份数据库目录 根据自己的需求确定路径
backUpsFolder=/www/dbbackup/movie/

date_now=`date +%Y_%m_%d_%H%M`
backFileName=movie_$date_now

#进入备份文件夹，这个文件夹，如果大家在公司或者自己重要的项目里面，可以放到数据盘上，
#而不是这样扔到系统盘上，我们现在为了节约成本，是放到系统盘上的

cd $backUpsFolder

mkdir -p $backFileName

#导出

MongoDBdump -h 127.0.0.1:19999 -d imooc-movie -o $backFileName

tar zcvf $backFileName.tar.gz $backFileName

MongoDBdump -h 127.0.0.1:19999 -d imooc-movie -o $backFileName
#清理
rm -rf $backFileName

#在备份到本地之后，我们最好把这个数据库，再传到一个私密的云端上，比如七牛或者阿里云对象上，
#这样就多了一重备份，万一哪一天这个服务器磁盘坏了，我们也可以有云端的备份来恢复数据。

NODE_ENV=$backUpsFolder@$backFileName node /www/tasks/upload.js
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;通过 crontab 设置定时任务：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 启动 crontab 对话窗口
crontab -e

# 第一次使用会 
# o crontab for rn_manager - using an empty one
# 
# Select an editor.  To change later, run &#39;select-editor&#39;.
#   1. /bin/ed
#   2. /bin/nano        &amp;lt;---- easiest
#   3. /usr/bin/vim.basic
#   4. /usr/bin/vim.tiny
# 
# Choose 1-4 [2]: 3

59 23 * * * sh /home/imooc_manager/tasks/movie.backup.sh

00 4 * * * sh /www/bash.tasks/backup.sh
00 8 * * * sh /www/bash.tasks/backup.sh
00 12 * * * sh /www/bash.tasks/backup.sh
00 16 * * * sh /www/bash.tasks/backup.sh
00 20 * * * sh /www/bash.tasks/backup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;上传数据库备份到七牛&#34;&gt;上传数据库备份到七牛&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建一个上传脚本 &lt;code&gt;upload.js&lt;/code&gt;: &lt;code&gt;sudo touch /www/tasks/upload.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;upload.js 文件和 &lt;code&gt;movie.backup.sh&lt;/code&gt; 处在同一个目录下，&lt;code&gt;movie.backup.sh&lt;/code&gt; 最后一行调用了 upload.js 文件，这样定时任务在执行 &lt;code&gt;movie.backup.sh&lt;/code&gt; 脚本文件的时候会自动备份数据库，并自动上传到七牛云。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var qiniu = require(&#39;qiniu&#39;)

// 首先通过获取启动 Node 的服务时候传过来的环境变量
var parts = env.split(&#39;@&#39;)
var file = parts[1] + &#39;.tar.gz&#39;
var filePath = parts[0] + &#39;/&#39; + file

//需要填写你的 Access Key 和 Secret Key
qiniu.conf.ACCESS_KEY = &#39;Access_Key&#39;;
qiniu.conf.SECRET_KEY = &#39;Secret_Key&#39;;

//要上传的空间
bucket = &#39;imoocdeploydb&#39;

//构建上传策略函数
function uptoken(bucket, key) {
  var putPolicy = new qiniu.rs.PutPolicy(bucket + &#39;:&#39; + file);
  return putPolicy.token()
}

//生成上传 Token
token = uptoken(bucket, key)

//构造上传函数
function uploadFile(uptoken, key, localFile) {
  var extra = new qiniu.io.PutExtra()
  
  qiniu.io.putFile(uptoken, key, localFile, extra, function(err, ret) {
      if(!err) {
        // 上传成功， 处理返回值
        console.log(ret.hash, ret.key, ret.persistentId)       
      }
      else {
        // 上传失败， 处理返回代码
        console.log(err)
      }
  })
}

//调用uploadFile上传
uploadFile(token, file, filePath)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>搭建 Node.js 与阿里云 Alinode 环境</title>
      <link>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</guid>
      <description>

&lt;h3 id=&#34;搭建-node-js-环境&#34;&gt;搭建 Node.js 环境&lt;/h3&gt;

&lt;h4 id=&#34;系统更新-安装基础包&#34;&gt;系统更新，安装基础包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get update
sudo apt-get install vim openssl build-essential libssl-dev wget curl git
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装-node-js&#34;&gt;安装 node.js&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;nvm&lt;/code&gt; 这个工具，方便升级和管理 node.js 版本 &lt;code&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装 node.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nvm install v10.14.2
nvm use v10.14.2
nvm alias default v10.14.2
node -v
v10.14.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装-阿里云的-alinode&#34;&gt;安装 阿里云的 alinode&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;或者可以直接安装阿里云的 alinode，这也是我推荐给大家的 Node，因为它对 Node 做了必要的定制，可以无缝接入到 alinode 的监控中心，对于 &lt;strong&gt;多机器多应用运维&lt;/strong&gt; 非常有用。大家可以参考 &lt;a href=&#34;https://help.aliyun.com/document_detail/60338.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;alinode 安装文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装一些常用的全局工具包&#34;&gt;安装一些常用的全局工具包&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以配置一个简单的 registry 参数来指定使用国内的 taobao 镜像来下载： &lt;code&gt;npm --registry=https://registry.npm.taobao.org install -g npm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install pm2 -g
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>配置Nginx反向代理Node.js端口</title>
      <link>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</guid>
      <description>

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install nginx
sudo vi /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装完毕后，检查下 Nginx 的版本：&lt;code&gt;nginx -v&lt;/code&gt;。这个版本号通常可以在 Web 端的 header 里看到。安全起见，可以通过配置隐藏掉，如下打开 nginx.conf 文件：&lt;code&gt;sudo vi /etc/nginx/nginx.conf&lt;/code&gt;，把&lt;code&gt;nginx.conf&lt;/code&gt; 文件中的&lt;code&gt;server_tokens on&lt;/code&gt; 改成 &lt;code&gt;server_tokens off&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置-nginx-反向代理-node-js-端口&#34;&gt;配置 Nginx 反向代理 Node.js 端口&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;我们的网站静态服务是跑在 4321 端口上的，直接通过 80 端口无法启动，原因是我们 rn_manager 下的 Node 并不具备 root 的运行权限，不能监听 0 ~ 1024 之间的端口，当然也包括 80 端口。通过 sudo 来强制启动 Node 服务也不是不可以，但是，这多少会带来一些额外的成本和风险：一是我们需要额外配置，二是需要放大 Node 程序的权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;用 ip 访问，使用 nginx，用 root 级的权限来启动对 80 端口的监听，同时把来自 80 端口的流量分配给 Node 服务的另外一个端口，实现这种服务的代理。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;如果服务器只需放一个网站程序，那么解析网站到服务器网址，网站程序监听 80 端口即可。如果服务器有多个应用（你有多个网站），借助 Nginx 不仅可以实现端口代理，还可以实现负载均衡，由它来判断是来自哪个域名或 IP 的访问，从而根据配置的规则，将这个请求原封不动地转发给特定的端口或特定的某几台机器。在我们的这个案例中，就是把 80 端口的 IP 请求都转发到 Node.js 的 8081 端口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;第一步要在 /etc/nginx/conf.d 文件夹下面新增一个配置文件：&lt;code&gt;sudo vi  /etc/nginx/conf.d/imooc-com-4321.conf&lt;/code&gt;(看一下配置文件，就可以知道哪个域名对应到哪个端口)，详细配置如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;# 通过 upstream 我们可以设定一个简单的负载均衡策略，以应对将来可能的升级
# 首先定义一个 server 集群 gougou，里面可以加多个 server，每个 server 对应的值可以用域名，也可以直接用 IP，但我们通常不会用 IP 来访问，而是通过域名:

upstream imooc {
    server 127.0.0.1:4321;
}

server {
    listen 80;
    server_name test1.luck-year.top;

    # Gzip Compression
    gzip on;
    gzip_comp_level 6;
    gzip_vary on;
    gzip_min_length  1000;
    gzip_proxied any;
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
    gzip_buffers 16 8k;
    
    location / {
        # remote_addr 代表客户端的 IP
        proxy_set_header X-Real-IP $remote_addr;
        # proxy_add_x_forwarded_for 获取真实的 IP
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # http_host 表示请求的 host 头
        proxy_set_header Host $http_host;
        proxy_set_header X-NginX-Proxy true;
      
        # proxy_pass 指令实现代理。把域名代理到集群名上面
        proxy_pass http://imooc;
        proxy_redirect off;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;保存后，通过 &lt;code&gt;sudo nginx -t&lt;/code&gt;  来验证配置是否正确，有没有语法错误，然后我们把 Nginx 的服务重启一下: &lt;code&gt;sudo service nginx restart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;访问：&lt;code&gt;http://test1.luck-year.top/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;server_name test1.luck-year.top&lt;/code&gt; 这个对应的耳机域名需要在 域名解析里添加记录，需要先对域名进行备案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/totalimgs/域名解析.png&#34; alt=&#34;域名解析png&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;扩展&#34;&gt;扩展&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ps -ef | grep nginx&lt;/code&gt; 查看nginx安装目录和nginx配置文件目录&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
