<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Magic on Magic</title>
    <link>/</link>
    <description>Recent content in Magic on Magic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 02 Jul 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>pm2</title>
      <link>/2019/pm2/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/pm2/</guid>
      <description>

&lt;h3 id=&#34;pm2-的安装提示处理&#34;&gt;PM2 的安装提示处理&lt;/h3&gt;

&lt;p&gt;在本地安装 PM2 之后，可能会看到下面的这个提示，可以按照提示操作一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Since PM2’s deployment command runs on a non-interactive SSH connection, we need to resolve this by commenting out a few lines from the semaphoreci user’s ~/.bashrc file. We’re already logged in as this user on our droplet, so we simply need to open up this file and comment this out:


Comment the following lines:

#If not running interactively, don&#39;t do anything
#case $- in
#    *i*) ;;
#      * return;;
#esac

and this in /etc/bash.bashrc

# If not running interactively, don&#39;t do anything
[ -z &amp;quot;$PS1&amp;quot; ] &amp;amp;&amp;amp; return
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;尝试-pm2-启动服务&#34;&gt;尝试 PM2 启动服务&lt;/h3&gt;

&lt;p&gt;如果一个网站的服务，必须通过命令行 node server.js 来启动，启动后，退出命令行服务就终止，这显然不符合我们的预期。而即便是服务能持续运行，一旦遇到异常情况服务即终止，也是不理想的，这时候就需要有一种能够守护进程的工具或者服务，来把已经挂起的服务再次重启，这就是服务常驻的基本需求了。对于 Node.js 来说，有很多工具可以帮我们做到这一点，PM2 就是其中一个，之前我们写了这样一个静态站点代码 - app.js：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)

const homePage = `
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
      &amp;lt;title&amp;gt;Node.js 部署上线示例&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;h1&amp;gt;慕课网 Node.js 部署发布&amp;lt;/h1&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
`

http.createServer((req, res) =&amp;gt; {
  res.statusCode = 200
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)
  res.end(homePage)
}).listen(4321, () =&amp;gt; {
  console.log(&#39;Server running at 4321&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要把一个静态站点开起来，需要满足 2 个条件:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，这个站点可以持续稳定地提供服务；&lt;/li&gt;
&lt;li&gt;第二，这个站点可以从外网直接访问到，比如通过域名访问到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，我们的端口是跑在 4321 的，这显然不满足第二个条件，我们需要从外网通过 80 端口来访问。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们先解决第一个问题：让服务可以持续稳定地运行。（第二个问题留到下一个节来解决。）通过 node app.js 启动服务文件，服务就跑起来了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node app&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们通过浏览器来访问，就可以看到 Node.js 服务返回的页面内容了，但是一旦退出命令行，这个会话状态就会中断，随之 Node.js 服务也会终止。显然这不是我们想要的状态，我们希望服务不仅可以在后台运行，而且在出现异常的时候还可以自动重启。这时我们就可以用到 PM2 这个 Node.js 部署和进程管理工具，不作过多解释，直接来用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不加任何参数的话，PM2 会自动初始化一些基础参数，来把服务跑起来。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pm2 start app.js&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;补充-pm2-常用命令&#34;&gt;补充：PM2 常用命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过 PM2 跑服务器的时候，是可以进行集群配置的，也就是指定在几个核上运行几个进程：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pm2 start app.js -i 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i 后面跟的 2 表示启动 2 个 server 实例，如果输入 0 的话，则按照当前服务器实际的 CPU 核数来启动多个 server，启动后，我们通过 pm2 ls 来看看已经启动的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;~ pm2 ls
┌────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│Name│id│mode│status │↺     │cpu│memory│       │
├────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online│0  │19%   │28.4 MB│
│app │1 │N/A │cluster│online│0  │0%    │20.3 MB│
└────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pm2-实时扩容集群&#34;&gt;PM2 实时扩容集群&lt;/h4&gt;

&lt;p&gt;如果发现线上的服务响应比较吃力，而 CPU 核数没有吃满的话，我们可以实时扩容集群，通过 scale 命令来实现，比如：&lt;code&gt;pm2 scale app +1&lt;/code&gt;，这里的 +1 就是扩容一个服务实例，其实就是增加一个 cluster 的 worker 子进程，扩容后的应用效果如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[PM2] Scaling up application
┌─────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│ Name│id│mode│status │↺     │cpu│memory│       │
├─────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│ app │0 │N/A │cluster│online│0  │0%    │33.6 MB│
│ app │1 │N/A │cluster│online│0  │0%    │34.2 MB│
│ app │2 │N/A │cluster│online│0  │0%    │19.9 MB│
└─────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pm2-终止某个进程&#34;&gt;PM2 终止某个进程&lt;/h4&gt;

&lt;p&gt;有时候如果某个进程明显卡住了，或者线上负载不大，可以杀掉部分进程，通过：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;e12-cluster git:(master) ✗ pm2 stop 1
[PM2] Applying action stopProcessId on app [1](ids: 1)
[PM2] [app](1) ✓
┌────┬──┬────┬───────┬───────┬───┬──────┬───────┐
│Name│id│mode│status │↺      │cpu│memory│       │
├────┼──┼────┼───────┼───────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online │0  │0%    │33.6 MB│
│app │1 │N/A │cluster│stopped│0  │0%    │0 B    │
│app │2 │N/A │cluster│online │0  │0%    │33.6 MB│
└────┴──┴────┴───────┴───────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到进程 ID 为 1 的 worker 已经是 stopped 状态。&lt;/p&gt;

&lt;h4 id=&#34;pm2-平滑重启进程&#34;&gt;PM2 平滑重启进程&lt;/h4&gt;

&lt;p&gt;有时候，如果想要某个比较吃内存的进程可以重启，或者想要所有的 worker 都重启，但是又不希望影响进程正常处理用户的请求，可以使用 PM2 的 gracefulReload 命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜ pm2 reload app
Use --update-env to update environment variables
[PM2] Applying action reloadProcessId on app [app](ids: 0,1,2)
[PM2] [app](1) ✓
[PM2] [app](0) ✓
[PM2] [app](2) ✓
➜ pm2 ls
┌────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│Name│id│mode│status │↺     │cpu│memory│       │ 
├────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online│1  │6.8%  │37.4 MB│
│app │1 │N/A │cluster│online│0  │6.8%  │37.4 MB│
│app │2 │N/A │cluster│online│1  │6.4%  │37.5 MB│
└────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样所有的子进程又原地满血复活了，当然也存在这种情况，即某些进程上的未处理连接或任务的确很重，比如有一些大而重的文件 IO 或者数据库 IO 在等待，会导致 reload 失败。这时候可以指定一个超时时间，命令会退化到 restart 模式，强制杀死进程再重启；或者我们可以在代码中再友好一些，当它收到 PM2 要重启的时候，在程序里把一些任务清空然后让服务重启：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// PM2 会发出 SIGINT 事件，我们监听事件
process.on(&#39;SIGINT&#39;, function() {
  // 处理一些任务然后信号交还给 PM2 来重启服务
  db.stop(function(err) {
    process.exit(err ? 1 : 0)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pm2.io/doc/en/runtime/overview/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PM2 的文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Unitech/pm2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PM2 的仓库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置-pm2-一健部署项目目录&#34;&gt;配置 pm2 一健部署项目目录&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以先在本地仓库加一份 PM2 的部署文件 &lt;code&gt;ecosystem.yaml&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apps:
  - script: index.js
    name: NodeDeployStatic
    env:
      COMMON_VARIABLE: true
    env_production:
      NODE_ENV: production
deploy:
  production:
    user: rn_manager
    host:
      - 116.62.201.97
    port: &#39;39999&#39;
    ref: origin/master
    repo: git@git.dev.tencent.com:s_auto/muke.git
    # 服务器上项目部署的目录，会在/www/node-deploy-static下初始化一个production文件夹
    # 配置文件会自动从git上面拉取静态网站代码到此路径
    path: /www/node-deploy-static/production
    
    ssh_options: StrictHostKeyChecking=no
    pre-deploy: git fetch --all
    post-deploy: &#39;npm i &amp;amp;&amp;amp; pm2 startOrRestart ecosystem.yaml --env production&#39;
    env:
      NODE_ENV: production
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;运行：&lt;code&gt;pm2 deploy ./ecosystem.yaml production setup&lt;/code&gt;，*注：有可能会报：Permission denied（权限不足），可以到服务器上使用 &lt;code&gt;sudo chmod 777 /www/&lt;/code&gt; 这个命令对用户的权限为可读、可写、可执行（远程）*，输出内容如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;--&amp;gt; Deploying to production environment
--&amp;gt; on host 116.62.201.97
  ○ hook pre-setup
  ○ running setup
  ○ cloning git@git.dev.tencent.com:s_auto/muke.git
  ○ full fetch
Cloning into &#39;/www/node-deploy-static/production/source&#39;...
  ○ hook post-setup
  ○ setup complete
--&amp;gt; Success
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当前的服务所运行的文件夹，source 是 clone 下来的源码，shared 里面是日志文件和 pid 之类，其中 current 是 source 的软连接，两者是一样的代码，然后通过 &lt;code&gt;sudo chown -R $USER:$USER /www&lt;/code&gt; 可以让权限被当前用户访问，或者更暴力一点：&lt;code&gt;sudo chmod 755 /www/node-deploy-vue&lt;/code&gt;。等到服务器的文件夹都安置后，就可以从本地利用 PM2 往服务器进行部署了。&lt;/p&gt;

&lt;h3 id=&#34;从本地发布上线和更服务器的部署项目&#34;&gt;从本地发布上线和更服务器的部署项目&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;本地目录下输入命令：&lt;code&gt;pm2 deploy ecosystem.yaml production&lt;/code&gt; 更新和运行，&lt;em&gt;注：使用nvm安装的node和pm2 会报 &lt;code&gt;bash: pm2: command not found / post-deploy hook failed / Deploy failed&lt;/code&gt;，网上搜出来说是没有进行加 软链接&amp;ndash;待定&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>安装与配置MongoDB数据库</title>
      <link>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>

&lt;p&gt;服务器系统为 Ubuntu 14.04&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mongodump&lt;/code&gt; 逻辑备份工具。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongorestore&lt;/code&gt; 逻辑恢复工具。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongoexport&lt;/code&gt;  数据导出工具。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongoimport&lt;/code&gt;  数据导入工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用 Navicat for MongoDB 来管理数据库&lt;/p&gt;

&lt;h3 id=&#34;安装-mongodb-并开启等命令&#34;&gt;安装 MongoDB 并开启等命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.mongodb.com/manual/administration/install-enterprise/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MongoDB社区安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;加入公钥 &lt;del&gt;&lt;code&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6&lt;/code&gt;&lt;/del&gt; 使用后面这个命令：&lt;code&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为 MongoDB 创建一个列表文件，可以选择使用 Aliyun 的镜像文件 &lt;del&gt;&lt;code&gt;echo &amp;quot;deb [ arch=amd64 ] http://mirrors.aliyun.com/MongoDB/apt/ubuntu trusty/MongoDB-org/4.0 multiverse&amp;quot; | sudo tee /etc/apt/sources.list.d/MongoDB-org-4.0.list&lt;/code&gt;&lt;/del&gt; &lt;code&gt;echo &#39;deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen&#39; | sudo tee /etc/apt/sources.list.d/mongodb.list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重新加载更新本地的包库 &lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装 MongoDB 稳定版 &lt;code&gt;sudo apt-get install -y MongoDB-org&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;在安装的时候有可能会遇到这个问题：定位不到本地的 MongoDB-org 的安装包，可能是因为我们使用的是阿里云的服务器，所以默认的是阿里云的源。可以先把阿里云的源屏蔽掉试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vi /etc/apt/apt.conf
# 把下面一行给注释掉，在前面加一个#号即可：
Acquire::http::Proxy &amp;quot;http://mirrors.aliyun.com/&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;开启命令：&lt;code&gt;sudo service mongod start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看 MongoDB 是否成功开始服务，使用 &lt;code&gt;cat /var/log/mongodb/mongod.log&lt;/code&gt; 查看 MongoDB 日志文件，或者直接使用命令链接一下：&lt;code&gt;mongo&lt;/code&gt; &amp;ndash;&lt;em&gt;默认情况下，运行此命令将查找在localhost接口上侦听端口27017的MongoDB服务器（如果您想连接到在不同端口上运行的MongoDB服务器，请使用-port选项。例如，如果要连接到侦听端口22222的本地MongoDB服务器，则会发出以下命令：&lt;code&gt;mongo --port 22222&lt;/code&gt;）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;如果没有成功进入 MongoDB 的命令行界面，可以检查下阿里云安全组包括本地的防火墙 27017 端口有没有开启（MongoDB 的端口是默认的 27017 端口），如果能从终端进入到 MongoDB 命令行环境，说明我们的 MongoDB 服务开启成功了。&lt;/li&gt;
&lt;li&gt;停止数据库服务：&lt;code&gt;sudo service mongod stop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启数据库服务：&lt;code&gt;sudo service mongod restart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;检查 MongoDB 服务状态：&lt;code&gt;sudo service mongod status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;状态统计摘要列表（连续）：&lt;code&gt;mongostat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;状态统计摘要列表（5行，每2秒汇总）：&lt;code&gt;mongostat --rowcount 5 2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：输入 &lt;code&gt;moongo&lt;/code&gt; 后，报 &lt;code&gt;BadValue Invalid or no user locale set. Please ensure LANG and/or LC_* environment variables are set correctly&lt;/code&gt;，可以 使用 &lt;code&gt;locale-gen en_US.UTF-8&lt;/code&gt; 这个命令来生成缺少的语言环境，然后重新启动 数据库&lt;/p&gt;

&lt;h3 id=&#34;修改-mongodb-数据库默认运行端口&#34;&gt;修改 MongoDB 数据库默认运行端口&lt;/h3&gt;

&lt;p&gt;现在服务器上 MongoDB 运行的端口是默认的 27017 端口，全世界都知道，也是出于最最基本的安全考虑。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开 MongoDB 数据库配置文件：&lt;code&gt;sudo vi /etc/mongod.conf&lt;/code&gt; &lt;strong&gt;输入法必须为英文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以把 net 下面的 port 改成一个你喜欢的端口号，比如 19999。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;storage:
  dbPath: /var/lib/MongoDB
  journal:
    enabled: true
#  engine:
#  mmapv1:
#  wiredTiger:

# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path: /var/log/MongoDB/mongod.log

# network interfaces
net:
  port: 19999
  bindIp: 127.0.0.1
  
#processManagement:
#security:
  #authorization: &#39;enabled&#39;

#operationProfiling:
#replication:
#sharding:
## Enterprise-Only Options:

#auditLog:
#snmp
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;保存后重启服务：&lt;code&gt;sudo service mongod restart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加端口号后连接：&lt;code&gt;mongo --port 19999&lt;/code&gt; &lt;em&gt;提醒：MongoDB 的运行端口是在 27017 的，这里将 MongoDB 的默认端口修改后，比如改成 19999，那么对应的 iptables 也要更新下，包括阿里云的安全组也要配置下，这里容易被遗忘。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;本地线上的数据导入导出&#34;&gt;本地线上的数据导入导出&lt;/h3&gt;

&lt;h4 id=&#34;本地安装-和运行-mongodb&#34;&gt;本地安装 和运行 mongodb&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以现在本地搭建一个数据库，使用 &lt;code&gt;brew&lt;/code&gt; 来安装 &lt;code&gt;mongodb&lt;/code&gt;：&lt;code&gt;brew install mongodb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建一个数据库存储目录：&lt;code&gt;sudo mkdir -p /data/db&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动 mongodb，默认数据库目录即为 /data/db：&lt;code&gt;sudo mongod&lt;/code&gt; || &lt;code&gt;brew services start mongodb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重新启动：&lt;code&gt;brew services restart mongodb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;往线上空库导入单表数据或数据库&#34;&gt;往线上空库导入单表数据或数据库&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;把本地数据导入到本地数据库：&lt;code&gt;mongorestore -p 27017 -d [dbnames] [file-path]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对本地数据库进行整库备份，把数据库导入 &lt;code&gt;[local-file-name]&lt;/code&gt; 下，然后在压缩打包成 &lt;code&gt;[file-name].tar.gz&lt;/code&gt; 文件包&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mongodump -h 127.0.0.1:27017 -d [dbname] -o [local-file-path]

# tar 是打包
# tar zxvf 解压
# tar zcvf 压缩
# tar xvf 解压
tar zcvf [file-name].tar.gz [local-file-name]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;scp&lt;/code&gt; 上传到服务器 &lt;code&gt;scp -P 39999 ./imooc-movie.tar.gz rn_manager@116.62.201.97:/home/rn_manager/loaclBD/&lt;/code&gt;。注：服务器上找不到目录可以新建一个目录&lt;/li&gt;
&lt;li&gt;使用  &lt;code&gt;tar xvf ./loaclBD/imooc-movie.tar.gz&lt;/code&gt; 解压&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;mongorestore --host 127.0.0.1:19999 -d imooc-movie ./imooc-movie/imooc-movie/&lt;/code&gt; 导入数据到数据库中 &lt;em&gt;服务器上操作，执行这个命令时在当前目录下不能有 db 这个目录&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;为非空数据库导入数据&#34;&gt;为非空数据库导入数据&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;例如需要为一个已有的数据库导入一张或者几张单表，这种情况适用于：新增一些用户列表，新增一些创意数据，或者初始化一些管理员角色等。&lt;/li&gt;
&lt;li&gt;有一个 xxx 的用户，它是有超级权限的，我们希望通过本地的这张用户表导入到线上以后，等到应用发布了，这个应用就默认拥有了一个 xxx 的高权限用户，通过它就能管理应用的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;首先，需要在本地把这张用户表导出来：&lt;code&gt;mongoexport -d imooc-movie -c users -q &#39;{&amp;quot;name&amp;quot;: {$ne: null}}&#39; -o ./movie-users.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后上传这张表到服务器：&lt;code&gt;scp -P 39999 ./movie-users.json rn_manager@116.62.201.97:/home/rn_manager/loaclBD/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后登录到服务器上导入用户数据：&lt;code&gt;mongoimport --host 127.0.0.1:19999 -d imooc-movie -c users ./movie-users.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果导入了数据库之后后悔了，可以通过 &lt;code&gt;mongo --host 127.0.0.1:19999 imooc-movie --eval &amp;quot;db.dropDatabase()&amp;quot;&lt;/code&gt; 命令来删除数据库&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;为项目配置数据库读写权限&#34;&gt;为项目配置数据库读写权限&lt;/h4&gt;

&lt;p&gt;MongoDB 权限系统有一个大概的了解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MongoDB 是没有默认管理员账号，所以要先添加管理员账号，再开启权限认证。&lt;/li&gt;
&lt;li&gt;只有在切换到 admin 数据库后，添加的账号才是管理员账号。&lt;/li&gt;
&lt;li&gt;用户只能在用户所在数据库登录，包括管理员账号。&lt;/li&gt;
&lt;li&gt;管理员可以管理所有数据库，但是不能直接管理其他数据库，要先在 admin 数据库认证后才可以。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;首先是对整个 MongoDB 的数据库设立一个超级权限，其实就是一个管理员，&lt;code&gt;mongo -p 19999&lt;/code&gt;  从服务器进入到数据库命令行模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 切换到 admin
use admin
# 创建管理员权限的账号
# db.createUser({user: &#39;dba&#39;,pwd:&#39;123456.!$&#39;,roles:[{role:&#39;root&#39;,db:&#39;admin&#39;}]})
db.createUser({user: &#39;test_owner&#39;,pwd:&#39;123456.!$&#39;,roles:[{role:&#39;userAdminAnyDatabase&#39;,db:&#39;admin&#39;}]})
&amp;gt; Successfully added user: {
    &amp;quot;user&amp;quot; : &amp;quot;test_owner&amp;quot;,
    &amp;quot;roles&amp;quot; : [
      {
        &amp;quot;role&amp;quot; : &amp;quot;userAdminAnyDatabase&amp;quot;,
        &amp;quot;db&amp;quot; : &amp;quot;admin&amp;quot;
      }
    ]
  }
# 用刚创建的用户授权进入
db.auth(&#39;test_owner&#39;, &#39;123456.!$&#39;)
# 切换到业务数据库
use imooc-movie
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;然后添加普通用户，配置应用调用权限&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 为业务数据库添加一个读写权限的账号
db.createUser({user:&#39;ordinary_test&#39;,pwd:&#39;123456.f&#39;,roles:[{role:&#39;readWrite&#39;,db:&#39;imooc-movie&#39;}]})
&amp;gt; Successfully added user: {
    &amp;quot;user&amp;quot; : &amp;quot;ordinary_test&amp;quot;,
    &amp;quot;roles&amp;quot; : [
      {
        &amp;quot;role&amp;quot; : &amp;quot;readWrite&amp;quot;,
        &amp;quot;db&amp;quot; : &amp;quot;imooc-movie&amp;quot;
      }
    ]
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;再为这个数据库创建一个备份角色，权限配置为可读&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;db.createUser({user: &#39;imooc_movie_wheel&#39;, pwd: &#39;123456..&#39;, roles: [{role: &#39;read&#39;, db: &#39;imooc-movie&#39;}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;开启验证模式，打开配置文件：&lt;code&gt;sudo vi /etc/mongod.conf&lt;/code&gt; &lt;em&gt;Mac 上输入 &lt;code&gt;brew list mongodb&lt;/code&gt; 找到安装目录，然后进一步找到配置文件&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#security:
  #authorization: enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面这 2 行代码的注释拿掉，如果没有的话，需要输入这 2 行来配置 MongoDB 的认证模式，然后，按下 esc 键，同时按下 shift + 冒号键，输入 wq! 回车就保存了，再把 MongoDB 重启一下，用刚才介绍的命令：&lt;code&gt;sudo service mongod restart&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;对数据库建立自动备份&#34;&gt;对数据库建立自动备份&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;先来创建存放任务文件的目录和目标文件：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo mkdir -p /www/tasks
sudo touch /www/tasks/movie.backup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;用来存放备份文件的目录也可以创建下：&lt;code&gt;sudo mkdir -p /www/dbbackup/movie/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编辑这个备份脚本：&lt;code&gt;sudo vi /www/tasks/movie.backup.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

#备份数据库目录 根据自己的需求确定路径
backUpsFolder=/www/dbbackup/movie/

date_now=`date +%Y_%m_%d_%H%M`
backFileName=movie_$date_now

#进入备份文件夹，这个文件夹，如果大家在公司或者自己重要的项目里面，可以放到数据盘上，
#而不是这样扔到系统盘上，我们现在为了节约成本，是放到系统盘上的

cd $backUpsFolder

mkdir -p $backFileName

#导出

MongoDBdump -h 127.0.0.1:19999 -d imooc-movie -o $backFileName

tar zcvf $backFileName.tar.gz $backFileName

MongoDBdump -h 127.0.0.1:19999 -d imooc-movie -o $backFileName
#清理
rm -rf $backFileName

#在备份到本地之后，我们最好把这个数据库，再传到一个私密的云端上，比如七牛或者阿里云对象上，
#这样就多了一重备份，万一哪一天这个服务器磁盘坏了，我们也可以有云端的备份来恢复数据。

NODE_ENV=$backUpsFolder@$backFileName node /www/tasks/upload.js
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;通过 crontab 设置定时任务：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 启动 crontab 对话窗口
crontab -e

# 第一次使用会 
# o crontab for rn_manager - using an empty one
# 
# Select an editor.  To change later, run &#39;select-editor&#39;.
#   1. /bin/ed
#   2. /bin/nano        &amp;lt;---- easiest
#   3. /usr/bin/vim.basic
#   4. /usr/bin/vim.tiny
# 
# Choose 1-4 [2]: 3

59 23 * * * sh /home/imooc_manager/tasks/movie.backup.sh

00 4 * * * sh /www/bash.tasks/backup.sh
00 8 * * * sh /www/bash.tasks/backup.sh
00 12 * * * sh /www/bash.tasks/backup.sh
00 16 * * * sh /www/bash.tasks/backup.sh
00 20 * * * sh /www/bash.tasks/backup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;上传数据库备份到七牛&#34;&gt;上传数据库备份到七牛&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建一个上传脚本 &lt;code&gt;upload.js&lt;/code&gt;: &lt;code&gt;sudo touch /www/tasks/upload.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;upload.js 文件和 &lt;code&gt;movie.backup.sh&lt;/code&gt; 处在同一个目录下，&lt;code&gt;movie.backup.sh&lt;/code&gt; 最后一行调用了 upload.js 文件，这样定时任务在执行 &lt;code&gt;movie.backup.sh&lt;/code&gt; 脚本文件的时候会自动备份数据库，并自动上传到七牛云。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var qiniu = require(&#39;qiniu&#39;)

// 首先通过获取启动 Node 的服务时候传过来的环境变量
var parts = env.split(&#39;@&#39;)
var file = parts[1] + &#39;.tar.gz&#39;
var filePath = parts[0] + &#39;/&#39; + file

//需要填写你的 Access Key 和 Secret Key
qiniu.conf.ACCESS_KEY = &#39;Access_Key&#39;;
qiniu.conf.SECRET_KEY = &#39;Secret_Key&#39;;

//要上传的空间
bucket = &#39;imoocdeploydb&#39;

//构建上传策略函数
function uptoken(bucket, key) {
  var putPolicy = new qiniu.rs.PutPolicy(bucket + &#39;:&#39; + file);
  return putPolicy.token()
}

//生成上传 Token
token = uptoken(bucket, key)

//构造上传函数
function uploadFile(uptoken, key, localFile) {
  var extra = new qiniu.io.PutExtra()
  
  qiniu.io.putFile(uptoken, key, localFile, extra, function(err, ret) {
      if(!err) {
        // 上传成功， 处理返回值
        console.log(ret.hash, ret.key, ret.persistentId)       
      }
      else {
        // 上传失败， 处理返回代码
        console.log(err)
      }
  })
}

//调用uploadFile上传
uploadFile(token, file, filePath)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>搭建 Node.js 与阿里云 Alinode 环境</title>
      <link>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</guid>
      <description>

&lt;h3 id=&#34;搭建-node-js-环境&#34;&gt;搭建 Node.js 环境&lt;/h3&gt;

&lt;h4 id=&#34;系统更新-安装基础包&#34;&gt;系统更新，安装基础包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get update
sudo apt-get install vim openssl build-essential libssl-dev wget curl git
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装-node-js&#34;&gt;安装 node.js&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;nvm&lt;/code&gt; 这个工具，方便升级和管理 node.js 版本 &lt;code&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装 node.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nvm install v10.14.2
nvm use v10.14.2
nvm alias default v10.14.2
node -v
v10.14.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装-阿里云的-alinode&#34;&gt;安装 阿里云的 alinode&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;或者可以直接安装阿里云的 alinode，这也是我推荐给大家的 Node，因为它对 Node 做了必要的定制，可以无缝接入到 alinode 的监控中心，对于 &lt;strong&gt;多机器多应用运维&lt;/strong&gt; 非常有用。大家可以参考 &lt;a href=&#34;https://help.aliyun.com/document_detail/60338.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;alinode 安装文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;安装一些常用的全局工具包&#34;&gt;安装一些常用的全局工具包&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以配置一个简单的 registry 参数来指定使用国内的 taobao 镜像来下载： &lt;code&gt;npm --registry=https://registry.npm.taobao.org install -g npm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install pm2 -g
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>配置Nginx反向代理Node.js端口</title>
      <link>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</guid>
      <description>

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install nginx
sudo vi /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装完毕后，检查下 Nginx 的版本：&lt;code&gt;nginx -v&lt;/code&gt;。这个版本号通常可以在 Web 端的 header 里看到。安全起见，可以通过配置隐藏掉，如下打开 nginx.conf 文件：&lt;code&gt;sudo vi /etc/nginx/nginx.conf&lt;/code&gt;，把&lt;code&gt;nginx.conf&lt;/code&gt; 文件中的&lt;code&gt;server_tokens on&lt;/code&gt; 改成 &lt;code&gt;server_tokens off&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置-nginx-反向代理-node-js-端口&#34;&gt;配置 Nginx 反向代理 Node.js 端口&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;我们的网站静态服务是跑在 4321 端口上的，直接通过 80 端口无法启动，原因是我们 rn_manager 下的 Node 并不具备 root 的运行权限，不能监听 0 ~ 1024 之间的端口，当然也包括 80 端口。通过 sudo 来强制启动 Node 服务也不是不可以，但是，这多少会带来一些额外的成本和风险：一是我们需要额外配置，二是需要放大 Node 程序的权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;用 ip 访问，使用 nginx，用 root 级的权限来启动对 80 端口的监听，同时把来自 80 端口的流量分配给 Node 服务的另外一个端口，实现这种服务的代理。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;如果服务器只需放一个网站程序，那么解析网站到服务器网址，网站程序监听 80 端口即可。如果服务器有多个应用（你有多个网站），借助 Nginx 不仅可以实现端口代理，还可以实现负载均衡，由它来判断是来自哪个域名或 IP 的访问，从而根据配置的规则，将这个请求原封不动地转发给特定的端口或特定的某几台机器。在我们的这个案例中，就是把 80 端口的 IP 请求都转发到 Node.js 的 8081 端口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;第一步要在 /etc/nginx/conf.d 文件夹下面新增一个配置文件：&lt;code&gt;sudo vi  /etc/nginx/conf.d/imooc-com-4321.conf&lt;/code&gt;(看一下配置文件，就可以知道哪个域名对应到哪个端口)，详细配置如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;# 通过 upstream 我们可以设定一个简单的负载均衡策略，以应对将来可能的升级
# 首先定义一个 server 集群 gougou，里面可以加多个 server，每个 server 对应的值可以用域名，也可以直接用 IP，但我们通常不会用 IP 来访问，而是通过域名:

upstream imooc {
    server 127.0.0.1:4321;
}

server {
    listen 80;
    server_name test1.luck-year.top;

    # Gzip Compression
    gzip on;
    gzip_comp_level 6;
    gzip_vary on;
    gzip_min_length  1000;
    gzip_proxied any;
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
    gzip_buffers 16 8k;
    
    location / {
        # remote_addr 代表客户端的 IP
        proxy_set_header X-Real-IP $remote_addr;
        # proxy_add_x_forwarded_for 获取真实的 IP
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # http_host 表示请求的 host 头
        proxy_set_header Host $http_host;
        proxy_set_header X-NginX-Proxy true;
      
        # proxy_pass 指令实现代理。把域名代理到集群名上面
        proxy_pass http://imooc;
        proxy_redirect off;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;保存后，通过 &lt;code&gt;sudo nginx -t&lt;/code&gt;  来验证配置是否正确，有没有语法错误，然后我们把 Nginx 的服务重启一下: &lt;code&gt;sudo service nginx restart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;访问：&lt;code&gt;http://test1.luck-year.top/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;server_name test1.luck-year.top&lt;/code&gt; 这个对应的耳机域名需要在 域名解析里添加记录，需要先对域名进行备案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/totalimgs/域名解析.png&#34; alt=&#34;域名解析png&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;扩展&#34;&gt;扩展&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ps -ef | grep nginx&lt;/code&gt; 查看nginx安装目录和nginx配置文件目录&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>阿里云服务器相关</title>
      <link>/2019/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/</guid>
      <description>

&lt;p&gt;根据 慕课网 专栏 ‘一条龙的 Node·Vue·React 服务器部署’ 笔记。&lt;/p&gt;

&lt;h3 id=&#34;购买&#34;&gt;购买&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;到阿里云官网购买一个&lt;a href=&#34;https://www.aliyun.com/product/ecs?spm=5176.12825654.eofdhaal5.2.54212c4a2B4irr&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;配置相关信息&lt;/li&gt;
&lt;li&gt;记录登录名 root 和 登录密码&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;h4 id=&#34;登录&#34;&gt;登录&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;通过 ssh 登录 例如：&lt;code&gt;ssh root@116.62.201.97&lt;/code&gt; 后面会要求输入密码&lt;/li&gt;
&lt;li&gt;可以通过 &lt;code&gt;sudo lsb_release -a&lt;/code&gt; 来查看服务器版本&lt;/li&gt;
&lt;li&gt;登录成功后可以首先运行 &lt;code&gt;sudo apt-get update&lt;/code&gt;，作用是先把服务器上所有的包和源都 check 和更新一遍，让服务器处在一个崭新的状态&lt;/li&gt;
&lt;li&gt;可以把一些常用的开发者套件先安装上 &lt;code&gt;sudo apt-get install -y software-properties-common&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;添加一个用户&#34;&gt;添加一个用户&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;增加一个用户 &lt;code&gt;adduser rn_manager&lt;/code&gt;，完成后记录住密码，&lt;strong&gt;赋予账号更高权限&lt;/strong&gt;:可以在 &lt;strong&gt;visudo 权限配置文件&lt;/strong&gt;配置一下:&lt;code&gt;sudo visudo&lt;/code&gt;，加入 &lt;code&gt;rn_manager ALL=(ALL:ALL) ALL&lt;/code&gt; 这行，然后可以重启 ssh 服务：&lt;code&gt;service ssh restart&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;配置无密码登录&#34;&gt;配置无密码登录&lt;/h4&gt;

&lt;p&gt;那么，首先来本地电脑上配置这把钥匙，而且要生成两把钥匙，分别是 &lt;strong&gt;私钥&lt;/strong&gt; 和 &lt;strong&gt;公钥&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;提示：如果你之前用过 GitHub 或者 GitLab 之类基于 Git 的仓库管理系统，那么你本地应该是配置过这个公钥和私钥的，这里要切记，&lt;strong&gt;不用再重复配置一遍了！不用重新配置一遍了！&lt;/strong&gt; 可能你会覆盖掉你本地用的钥匙，这样的话，你可能就连不上你之前有权限的 Git 仓库了，我会演示这一步。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 通过 mkdir 创建这个目录
mkdir .ssh
# 通过 cd 进入到该目录下
cd .ssh

ssh-keygen -t rsa -b 4096 -C &amp;quot;你的邮箱（可以随便填写）&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一路回车到底，对于新手这里就先不要设置密码了，不然就搞得太复杂了。执行完这一步命令之后，可以看到 .ssh 的目录下面生成了两个文件 id_rsa（私钥）和 id_rsa.pub（公钥），然后开起来 ssh 代理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;eval &amp;quot;$(ssh-agent -s)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，把 ssh key 加入到 ssh 代理中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh-add ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理论上走完这一步，你本地已经有了配置好的钥匙文件，强调一下，这里要切换到本地操作，不是服务器上，在本地的根目录的 ssh 文件夹下。&lt;br /&gt;
通过 cat 命令打印这个公钥文件内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat .ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后选中整段内容，复制一下，再来到服务器上。
&amp;gt; 注意：这时候我们可能打开了至少 3 个终端窗口，一个是 root 账号的，一个是 rn_manager 新账号的（这两个都是服务器上的），还有一个是在本地，也就是当前这个终端窗口。我们进入到 rn_manager 用户登录的终端中，输入 ls 命令，显然是什么都没有的。&lt;/p&gt;

&lt;p&gt;然后，这一步很重要哈！这一步是为了，以后我们可以从 GitHub 或者 GitLab 之类的仓库获得仓库的权限，因此我们要把刚才生成私钥的过程重复一遍，这一步不做是不影响我们配置无密码登录的，再把刚才的流程走一遍，一模一样的步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh-keygen -t rsa -b 4096 -C &amp;quot;scott@imooc.com&amp;quot;
eval &amp;quot;$(ssh-agent -s)&amp;quot;
ssh-add ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，通过简单的 vim 命令，我们需要创建一个授权文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会打开一个编辑页面，不要做任何输入，切记，不要做任何输入，同时要保证当前的输入法切换到英文输入状态，然后按下键盘上的 &lt;code&gt;i&lt;/code&gt;  键后，command+v 把刚才复制的公钥拷贝进来，再按一下键盘上的 ESC 退出键确保回到编辑状态，然后同时按下 shift 和 &lt;strong&gt;冒号键&lt;/strong&gt;，最后输入 &lt;code&gt;wq!&lt;/code&gt; 回车，这个文件就自动创建了。这是简单的 vim 快捷键，大家还是要多少了解一点点的，才能方便在服务器上增改文件。&lt;br /&gt;
然后，我们之前不是复制过本地的公钥文件吗，这时候还在系统的剪贴板里面呢，我们这时候要注意，切换到 rn_manager 这个账号下面的终端里，不是切换到 root 账号的终端里面，我们在新的账号终端环境操作。再次通过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者按一下键盘上的上选择键，来调出历史中缓存的刚才所使用的一条命令来打开授权文件，然后记住输入法是英文状态下，按一下键盘上的 i 键，切记，是 uijk 的 i 键，然后 command+v 粘贴进去（如果是 Windows 系统，是 ctrl+v 粘贴）。&lt;br /&gt;
之后，按一下 ESC 退出键，再同时按下 shift+; 键，输入 &lt;code&gt;wq!&lt;/code&gt;  回车即可。这个操作很容易由于不熟悉 Linux 下的 vim 编辑而出错，要多体会几遍，再动手做。&lt;/p&gt;

&lt;p&gt;如果没有生效，可以对该文件进行一个 600 可读授权，再重启下 ssh 服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;chmod 600 ~/.ssh/authorized_keys
sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在重启这个 ssh 服务的时候，应该会提示你要输入密码，这时候要输入刚才创建 rn_manager 账户的密码，千万注意，这里输入的密码不是 root 账号的密码，而是新账号的密码。&lt;/p&gt;

&lt;p&gt;最后，我们先不要关闭这个终端窗口，再另外开一个 &lt;code&gt;Iterm&lt;/code&gt; 窗口，通过 &lt;code&gt;ssh rn_manager@116.62.201.97&lt;/code&gt; 就可以直接登录了，不需要输入密码&lt;/p&gt;

&lt;h4 id=&#34;修改服务起端口号&#34;&gt;修改服务起端口号&lt;/h4&gt;

&lt;p&gt;可以在 root 或者 rn_manager 用户下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vim /etc/ssh/sshd_config
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 不允许空密码
PermitEmptyPasswords no
# 关闭密码验证登录，前提是你已经使用了 ssh 密钥验证方式登录
PasswordAuthentication no
# 如果你在服务器上手动添加了用户并将用户分配到 root 用户组，可以考虑禁止root用户登录
PermitRootLogin no

# 允许 pubkey 登录
PubkeyAuthentication yes

# Expect .ssh/authorized_keys2 to be disregarded by default in future.
AuthorizedKeysFile      .ssh/authorized_keys .ssh/authorized_keys2

# 登录的端口号
Port 39999
UseDNS no
AllowUsers rn_manager
# 只允许 ip4
AddressFamily inet
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;补充：单独聊一聊端口，这个很容易被人忽视，一般来说，0 ~ 65536 端口号都是可用范围内的数，但是 0 ~ 1024 最好不要使用，通常会被系统程序占用，必须以 root 身份才能启动，那么在 1024 以上到 65536 之间我们都可以选择性的使用。可以设置得稍微大一些，这样做不仅是禁用掉了 22 默认端口的登录途径，也缩小了被扫描和猜测到的概率，在安全层面我们是增加了一点点的安全防护，多多益善吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完成后可以重启 ssh 服务: &lt;code&gt;sudo service ssh restart&lt;/code&gt;，之后就可以使用 &lt;code&gt;ssh -p 39999 rn_manager@116.62.201.97&lt;/code&gt; 来进行登录。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;阿里云需要去 管理-&amp;gt;本实例安全组-&amp;gt;安全组列表-&amp;gt;配置规则-&amp;gt;添加安全组规则。否则会连接不上服务器，报超时&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;安全防护-配置-iptables-和-fail2ban-增强安全防护&#34;&gt;安全防护：配置 IPTables 和 Fail2Ban 增强安全防护&lt;/h4&gt;

&lt;h5 id=&#34;iptables&#34;&gt;iptables&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;iptables 是一个允许灵活配置的安全策略防火墙框架，简言之就是防火墙。对于一堵墙，我们的操作原则就是设置一些出入的大门，有些大门关闭，有些大门设置一些出入规则，尽量筛选掉一些恶意或者可疑的访问，留出安全的通道对外或者对内提供访问服务。&lt;/li&gt;
&lt;li&gt;可以先把 Ubuntu 升级更新一下：&lt;code&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade&lt;/code&gt;，如果遇到:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;E: Could not get lock /var/lib/dpkg/lock - open (11 Resource temporarily unavailable)
E: Unable to lock the administration directory (/var/lib/dpkg/) is another process using it? 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种错误，可以采用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ps aux | grep apt

root      1531  0.0  0.0  53340  3732 ?        S    16:24   0:00 sudo apt-get upgrade
root      1532  0.0  1.8 106184 75992 ?        S    16:24   0:07 apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到 apt-get 开头的，&lt;code&gt;sudo kill -9 1531 &amp;amp;&amp;amp; sudo kill -9 1532&lt;/code&gt;，然后重新执行，如果还失败，可以再多执行个 &lt;code&gt;sudo rm /var/lib/dpkg/lock &amp;amp;&amp;amp; sudo rm /var/cache/apt/archives/lock&lt;/code&gt;，然后再重新执行：&lt;code&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;然后我们把 iptables 的所有过滤规则都清空掉，输入：&lt;code&gt;iptables -F&lt;/code&gt;，在命令行，是可以一条一条的添加规则的，但是整个过程不太好用文字形式来演示，我们就通过文件方式来配置吧，输入如下命令：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;*filter

# Accepts all established inbound connections
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allows all outbound traffic
# You could modify this to only allow certain traffic
-A OUTPUT -j ACCEPT

# Allows HTTP and HTTPS connections from anywhere (the normal ports for websites)
 -A INPUT -p tcp --dport 443 -j ACCEPT
 -A INPUT -p tcp --dport 80 -j ACCEPT
# Allows SSH connections for script kiddies
# THE -dport NUMBER IS THE SAME ONE YOU SET UP IN THE SSHD_CONFIG FILE
 -A INPUT -p tcp -m state --state NEW --dport 39999 -j ACCEPT

# Now you should read up on iptables rules and consider whether ssh access
# for everyone is really desired. Most likely you will only allow access from certain IPs.

# allow ping
 -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT
 
# Mongodb open prot
-A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT
-A OUTPUT -d 127.0.0.1 -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT

# log iptables denied calls (access via &#39;dmesg&#39; command)
-A INPUT -m limit --limit 5/min -j LOG --log-prefix &amp;quot;iptables denied: &amp;quot; --log-level 7

# Drop incoming connections if IP make more than 150 connection attempts to port 80 within 60 seconds
-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --set
-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60  --hitcount 150 -j DROP

COMMIT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这几条需要特别注意：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 443 通常是 ssl 的端口，如果 VPS 是作为一台 web 应用的服务器并且启用 https，你需要这个
 -A INPUT -p tcp --dport 443 -j ACCEPT
 # 80 端口就不多说了
 -A INPUT -p tcp --dport 80 -j ACCEPT
 # 这是 ssh 默认的 22 端口，开放给自己登录使用
 -A INPUT -p tcp -m state --state NEW --dport 39999 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的 22 端口，你可以修改为其他的端口，并且关闭 22 端口。更有一种解决方案是：将生产机器 ssh 端口完全关闭，用一台同一子网下的跳板机来登录目标生产机器，其他的配置的话，你需要根据你的业务来具体配置相对应的安全策略。(需要把中文转译或者写为英文，否则下个操作会报错)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;告诉 iptables 你的配置在哪：&lt;code&gt;sudo iptables-restore &amp;lt; /etc/iptables.up.rules&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后创建 shell 脚本来开机自启动：&lt;code&gt;sudo vi /etc/network/if-up.d/iptables&lt;/code&gt;，写入:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 防火墙的开启与禁用命令很简单，如下：

sudo ufw start
sudo ufw status
sudo ufw disable

# 然后把文件路径写入进去

#!/bin/sh
iptables-restore /etc/iptables.up.rules

# 给予可以执行的权限

chmod +x /etc/network/if-up.d/iptables
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就把 iptables 配置好了。&lt;/p&gt;

&lt;h5 id=&#34;fail2ban&#34;&gt;Fail2Ban&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Fail2Ban 可以看做是防御性的动作库，通过监控系统的日志文件，根据检测到的任何可疑的行为，自动触发不同的防御动作，如将产生可疑行为的目标，执行 IP 锁定等。Fail2Ban 的安装很简单：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install fail2ban
sudo apt-get install nginx sendmail iptables-persistent

/etc/iptables/rules.v4
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;拷贝一份新的配置文件出来，我们重新编辑这个配置文件：&lt;code&gt;awk &#39;{ printf &amp;quot;# &amp;quot;; print; }&#39; /etc/fail2ban/jail.conf | sudo tee /etc/fail2ban/jail.local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开配置文件 &lt;code&gt;sudo vi /etc/fail2ban/jail.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[DEFAULT]
ignoreip = 127.0.0.1/8
bantime  = 3600
maxretry = 3
destemail = youemail@domain.com
action = %(action_mw)s

[ssh]
enabled  = true
port     = ssh
filter   = sshd
logpath  = /var/log/auth.log
maxretry = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;阿里云安全组&#34;&gt;阿里云安全组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;阿里云的服务器，默认就提供了安全组这样的高级防火墙，供我们使用，它可以控制从外网能访问到服务器的哪些端口，从内网能访问到服务器的哪些端口，流量的进和出，对哪些 IP 段的服务器授权，非常强大。&lt;/li&gt;
&lt;li&gt;根据实际使用情况，通常我们会选择开启下面这些端口：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;协议	端口
SSH	    22
telnet	23
HTTP	80
HTTPS	443
MS SQL	1443
Oracle	1521
MySQL	3306
RDP	    3389
PostgreSQL	5432
Redis	6379
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;注&#34;&gt;注：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;vi 中文乱码：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 修改方法很简单,因为明确是vi编码的问题,就修改一下它的保存编码即可.. 
# 编辑/etc/vim/vimrc文件,在最后添上 
set encoding=utf-8 
set fileencoding=utf-8 
set fileencodings=utf-8,gb18030,utf-16,big5
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;服务器上可以安装 git ，然后通过设置 ssh 来拉取项目&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>css3 适配iphoneX 安全区域</title>
      <link>/2019/%E9%80%82%E9%85%8Diphonex/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%80%82%E9%85%8Diphonex/</guid>
      <description>

&lt;h2 id=&#34;iphonex-适配&#34;&gt;iphoneX 适配&lt;/h2&gt;

&lt;h3 id=&#34;第一步-设置网页在可视窗口的布局方式&#34;&gt;第一步：设置网页在可视窗口的布局方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ios11 引入 meta 标签的 viewpoint 扩展属性 &lt;code&gt;viewpoint-fit&lt;/code&gt;，在 iOS 11 中 viewpoint-fit 也官方添加到 CSS Round Display 规范中了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewport-fit&lt;/code&gt; 有三个属性值：

&lt;ul&gt;
&lt;li&gt;Auto：默认值。这个值不影响初始布局视窗，整个 Web 页面是可视的。&lt;/li&gt;
&lt;li&gt;Contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形。&lt;/li&gt;
&lt;li&gt;Cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以我们可以通过 viewpoint-fit=cover 来解决问题，使页面内容跳出安全区域的框框。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0,user-scalable=0,viewport-fit=cover&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二步-页面主体内容限定在安全区域内&#34;&gt;第二步：页面主体内容限定在安全区域内&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;IOS11 提供了两个个新的 css 变量 &lt;code&gt;env(safe-area-inset-※)&lt;/code&gt; 和 &lt;code&gt;constant(safe-area-inset-※)&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;safe-area-inset-※&lt;/code&gt; 提供了四个方向的值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;safe-area-inset-top&lt;/code&gt;：在 Viewport 顶部的安全区域内设置量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;safe-area-inset-bottom&lt;/code&gt;：在 Viewport 底部的安全区域内设置量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;safe-area-inset-left&lt;/code&gt;：在 Viewport 左边的安全区域内设置量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;safe-area-inset-right&lt;/code&gt;：在 Viewport 右边的安全区域内设置量；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;constant()&lt;/code&gt; 和 &lt;code&gt;env()&lt;/code&gt; 这个变量已经开始着手标准化，目前也可以被用在 &lt;code&gt;margin、padding、top、bottom、left、right&lt;/code&gt; 等 css 属性中，&lt;strong&gt;同时在不支持的环境中将不会生效&lt;/strong&gt;。而且，同样在 iOS 11 中，iPhone X 机型以下得到的值均为 0，iPhone X 得到其对应的设置量。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;第三步-设置底部的样式&#34;&gt;第三步：设置底部的样式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;safe-area-inset-bottom&lt;/code&gt; 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
    padding-bottom: constant(safe-area-inset-bottom);
    padding-bottom: env(safe-area-inset-bottom);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;扩展-fixed-元素适配&#34;&gt;扩展：fixed 元素适配&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;类型一：fixed 完全吸底元素（bottom = 0）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.fixed-bottom-box {
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;div {
  margin-bottom: constant(safe-area-inset-bottom);
  margin-bottom: env(safe-area-inset-bottom);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;扩展-只希望-iphonex-才需要新增适配样式-可以配合-supports-来隔离兼容样式&#34;&gt;扩展：只希望 iPhoneX 才需要新增适配样式，可以配合 @supports 来隔离兼容样式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@supports&lt;/code&gt; 来判断浏览器是否支持某个CSS属性，并且根据是否支持来定义样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@supports&lt;/code&gt; 中的“条件规则”可以声明一条或者几个由不同的逻辑运算符相结合的声明（比如说，非（not），或（or），与（and）等），而且还可以使用括号来确定其操作的优先级关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {
    div {
        margin-bottom: constant(safe-area-inset-bottom);
        margin-bottom: env(safe-area-inset-bottom);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数组降纬</title>
      <link>/2019/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BA%AC/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BA%AC/</guid>
      <description>

&lt;h3 id=&#34;第一种-将数组字符串话&#34;&gt;第一种：将数组字符串话&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;利用数组与字符串的隐式转换，使用+符号链接一个对象，javascript会默认调用toString方法转为字符串，再使用字符串分割成字符串数组，最后转成数值形数组。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let arr = [[222, 333, 444], [55, 66, 77], 11, ]
arr += &#39;&#39;;
arr = arr.split(&#39;,&#39;);
arr = arr.map(item =&amp;gt; Number(item));

console.log(arr); // [222, 333, 444, 55, 66, 77, 11]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第二种-自定义函数&#34;&gt;第二种：自定义函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const reduceDimension = (arr) =&amp;gt; {
	let ret = [];

	let toArr = function(arr){
		arr.forEach(function(item){
			Array.isArray(item) ? toArr(item) : ret.push(item);
		});
	}
	toArr(arr);

	return ret;
}
let arr = [[12], 4, [333, [4444, 5555]], [9, [111, 222]]];
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>弹出遮照阻止底部页面滚动</title>
      <link>/2019/%E5%BC%B9%E5%87%BA%E9%81%AE%E7%85%A7%E9%98%BB%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%BC%B9%E5%87%BA%E9%81%AE%E7%85%A7%E9%98%BB%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</guid>
      <description>

&lt;h4 id=&#34;代码如下&#34;&gt;代码如下：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const bodyEl = document.body;
let top = 0;
/**
 * 阻止页面滚动
 * @param {boolean} isFixed
 */
export function stopBodyScroll(isFixed: boolean) {
  if (isFixed) {
    top = window.scrollY;

    bodyEl.style.position = &#39;fixed&#39;;
    bodyEl.style.top = -top + &#39;px&#39;;
  } else {
    bodyEl.style.position = &#39;&#39;;
    bodyEl.style.top = &#39;&#39;;

    window.scrollTo(0, top); // 回到原先的top
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ua检测</title>
      <link>/2019/ua%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/ua%E6%A3%80%E6%B5%8B/</guid>
      <description>

&lt;h4 id=&#34;代码如下&#34;&gt;代码如下：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const userAgent = window.navigator.userAgent.toLowerCase();
export const uaJudge = {
  get isAndroid() {
    return /android|adr/gi.test(userAgent);
  },
  get isVivo() {
    return /vivo/gi.test(userAgent);
  },
  get isIos() {
    return /iphone|ipod|ipad/gi.test(userAgent);
  },
  /** 微信（包含小程序） */
  get isWeChat() {
    return /micromessenger/gi.test(userAgent);
  },
  /** 微信小程序 */
  get isWeChatMini() {
    if (this.isWeChat) {
      return new Promise((resolve, reject) =&amp;gt; {
        wx.miniProgram.getEnv((res: any) =&amp;gt; {
          resolve(res.miniprogram);
        });
        setTimeout(resolve, 1000);
      });
    } else {
      return Promise.resolve(false);
    }
  },
  /** 支付宝 */
  get isAlipay() {
    return /alipay/gi.test(userAgent);
  },
  /** 百度 */
  get isBaidu() {
    return /baiduboxapp/gi.test(userAgent);
  },
  /** 百度网盘 */
  get isWangPan() {
    return /bdnetdisk/gi.test(userAgent);
  },
  /** 新浪微博 */
  get isWeiBo() {
    return /weibo/gi.test(userAgent);
  },
  /** 钉钉 */
  get isDingDing() {
    return /dingtalk/gi.test(userAgent);
  },
  /** qq，qq浏览器 */
  get isQQ() {
    return /QQ/gi.test(window.navigator.userAgent);
  },
  /** uc浏览器 */
  get isUC() {
    return /ucbrowser/gi.test(userAgent);
  },
  /** 网易云音乐 */
  get isWYMusic() {
    return /neteasemusic/gi.test(userAgent);
  },
  /** 美图系（包含潮自拍，美图贴贴等） */
  get isMTSeries() {
    return /com.meitu/gi.test(userAgent);
  },
  /** 潮自拍 */
  get isChaoZiPai() {
    return /com.meitu.wheecam/gi.test(userAgent);
  },
  /** 潮自拍3.6.4及以上版本支持新协议 */
  get isNewChaoZiPai() {
    const result = /com.meitu.wheecam\/([\d.]*)/.exec(userAgent);
    const version = result &amp;amp;&amp;amp; result[1];
    if (version) {
      return parseInt(version.replace(/\./g, &#39;&#39;).substring(0, 3), 10) &amp;gt;= 364;
    } else {
      return false;
    }
  },
  /** 无他相机 */
  get isWuTa() {
    return /wuta_browser/gi.test(userAgent);
  },
  /** 她face++ */
  get isTaFace() {
    return /taface/gi.test(userAgent);
  },
  /** 小恩爱 */
  get isXiaoenai() {
    return /mzdw/gi.test(userAgent);
  },
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>获取元素content宽高</title>
      <link>/2019/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0content%E5%AE%BD%E9%AB%98/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0content%E5%AE%BD%E9%AB%98/</guid>
      <description>

&lt;h4 id=&#34;代码如下&#34;&gt;代码如下：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 获取元素content宽高
 * @param el
 */
export function getContentSize(el: HTMLElement) {
  const width = el.offsetWidth;
  const height = el.offsetHeight;
  const style = window.getComputedStyle(el);
  // border
  const blw = parseFloat(style.borderLeftWidth || &#39;0&#39;);
  const brw = parseFloat(style.borderRightWidth || &#39;0&#39;);
  const btw = parseFloat(style.borderTopWidth || &#39;0&#39;);
  const bbw = parseFloat(style.borderBottomWidth || &#39;0&#39;);
  // padding
  const plw = parseFloat(style.paddingLeft || &#39;0&#39;);
  const prw = parseFloat(style.paddingRight || &#39;0&#39;);
  const ptw = parseFloat(style.paddingTop || &#39;0&#39;);
  const pbw = parseFloat(style.paddingBottom || &#39;0&#39;);
  return {
    width: width - blw - brw - plw - prw,
    height: height - btw - bbw - ptw - pbw,
  };
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>通过http链接加载script</title>
      <link>/2019/%E9%80%9A%E8%BF%87http%E9%93%BE%E6%8E%A5%E5%8A%A0%E8%BD%BDscript/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%80%9A%E8%BF%87http%E9%93%BE%E6%8E%A5%E5%8A%A0%E8%BD%BDscript/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function loadScript(src: string, async: boolean = true) {
  return new Promise((resolve, reject) =&amp;gt; {
    const script = document.createElement(&#39;script&#39;);
    async &amp;amp;&amp;amp; (script.async = true);
    script.onload = resolve;
    script.onerror = reject;
    script.src = src;
    document.body.appendChild(script);
  });
}
// 注意：使用appendChild，不要使用append，ios9不支持append。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Webpack 优化相关</title>
      <link>/2019/webpack/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/webpack/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://webpack.js.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;webpack-优化&#34;&gt;Webpack 优化&lt;/h2&gt;

&lt;h3 id=&#34;构建过程提速策略&#34;&gt;构建过程提速策略&lt;/h3&gt;

&lt;h4 id=&#34;不要让-loader-做太多事情&#34;&gt;不要让 loader 做太多事情&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;以 babel-loader 为例：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;babel-loader 无疑是强大的，但它也是慢的。&lt;/p&gt;

&lt;p&gt;最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译，比如 webpack 官方在介绍 babel-loader 时给出的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /(node_modules|bower_components)/,
      use: {
        loader: &#39;babel-loader&#39;,
        options: {
          presets: [&#39;@babel/preset-env&#39;]
        }
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，选择开启缓存将转译结果缓存至文件系统，只需要为 loader 增加相应的参数设定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;loader: &#39;babel-loader?cacheDirectory=true&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;抽离第三库&#34;&gt;抽离第三库&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DllPlugin&lt;/code&gt;是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用 DllPlugin 处理文件，要分两步走：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于 dll 专属的配置文件，打包 dll 库&lt;/li&gt;
&lt;li&gt;基于 webpack.config.js 文件，打包业务代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例&amp;ndash;配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// webpack.dll.config.js
const path = require(&amp;quot;path&amp;quot;)
const webpack = require(&amp;quot;webpack&amp;quot;)

module.exports = {
  entry: {
    // 依赖的库数组
    vendor: [
      &#39;mint-ui&#39;,
      &#39;vue/dist/vue.common.js&#39;,
      &#39;whatwg-fetch&#39;,
      &#39;vuex&#39;,
      &#39;vue-router&#39;
    ]
  },
  output: {
    path: path.join(__dirname, &#39;../static/js&#39;),
    filename: &#39;[name].dll.js&#39;,
    library: &#39;[name]_library&#39;
  },
  plugins: [
    new webpack.DllPlugin({
      // DllPlugin的name属性需要和libary保持一致
      path: path.join(__dirname, &#39;..&#39;, &#39;[name]-manifest.json&#39;),
      name: &#39;[name]_library&#39;,
      // context需要和webpack.config.js保持一致
      context: __dirname
    }),
    // 压缩打包的文件
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      }
    })
  ]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;package.json--&amp;gt;scripts&lt;/code&gt;下添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;build:dll&amp;quot;: &amp;quot;webpack --config build/webpack.dll.config.js&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令，运行&lt;code&gt;npm run build:dll&lt;/code&gt;会在&lt;code&gt;static/js&lt;/code&gt;文件夹里会出现&lt;code&gt;vendor.dll.js&lt;/code&gt;文件，在根目录下出现&lt;code&gt;vendor-manifest.json&lt;/code&gt;文件。&lt;br /&gt;
&lt;code&gt;vendor.dll.js&lt;/code&gt;是我们第三方库打包的结果，&lt;code&gt;vendor-manifest.json&lt;/code&gt;则用于描述每个第三方库对应的具体路径。&lt;br /&gt;
随后在&lt;code&gt;webpack.base.conf.js || webpack.config.js&lt;/code&gt;里针对 dll 稍作配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const path = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;)
module.exports = {
  mode: &#39;production&#39;,
  // 编译入口
  entry: {
    main: &#39;./src/index.js&#39;
  },
  // 目标文件
  output: {
    path: path.join(__dirname, &#39;dist/&#39;),
    filename: &#39;[name].js&#39;
  },
  // dll相关配置
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      // manifest就是我们第一步中打包出来的json文件
      manifest: require(&#39;../vendor-manifest.json&#39;)
    }),
    // 将 vendor.dll.js 插入HTML里 需要安装 html-webpack-include-assets-plugin
    new HtmlWebpackIncludeAssetsPlugin({
      assets: [utils.assetsPath(&#39;js/vendor.dll.js&#39;)],
      files: [&#39;index.html&#39;],
      append: false
    })
    // 多页面下 可以在每个 index.html 手动引入 vendor.dll.js
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;happypack-将-loader-由单进程转为多进程&#34;&gt;Happypack——将 loader 由单进程转为多进程&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;webpack&lt;/code&gt; 是单线程的，就算此刻存在多个任务，你也只能排队一个接一个地等待处理。这是 webpack 的缺点，好在我们的 CPU 是多核的，&lt;code&gt;Happypack&lt;/code&gt; 会充分释放 &lt;code&gt;CPU&lt;/code&gt; 在多核并发方面的优势，帮我们把任务分解给多个子进程去并发执行，大大提升打包效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 共享线程池
 * 通常，在内部创建的每个HappyPack插件都会创建自己的线程，用于运行加载器。
 * 但是，如果您使用多个HappyPack插件，那么最好自己创建一个线程池，然后配置插
 * 件以共享该池，从而最大限度地减少其中线程的空闲时间
 * 使用5个线程的自定义线程池
 */
const Happypack = require(&#39;happypack&#39;)
const happyThreadPool = Happypack.ThreadPool({size: 5}) // HappyPack.ThreadPool({ size: os.cpus().length })

module.exports = {
  module: {
    rules: [
      ...
      {
        test: /\.js$/,
        // 问号后面的查询参数指定了处理这类文件的HappyPack实例的名字
        loader: &#39;happypack/loader?id=happyBabel&#39;,
        ...
      },
    ],
  },
  plugins: [
    ...
    new HappyPack({
      // 这个HappyPack的“名字”就叫做happyBabel，和楼上的查询参数遥相呼应
      id: &#39;happyBabel&#39;,
      // 指定进程池
      threadPool: happyThreadPool,
      loaders: [&#39;babel-loader?cacheDirectory&#39;]
    })
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构建结果体积压缩&#34;&gt;构建结果体积压缩&lt;/h3&gt;

&lt;h4 id=&#34;文件结构可视化-找出导致体积过大的原因&#34;&gt;文件结构可视化，找出导致体积过大的原因&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;webpack-bundle-analyzer&lt;/code&gt;配置方法和普通的 plugin 无异，它会以矩形树图的形式将包内各个模块的大小和依赖关系呈现出来，格局如官方所提供这张图所示：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/totalimgs/webpack1.gif&#34; alt=&#34;webpack1&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用方式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;按需加载&#34;&gt;按需加载&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require.ensure&lt;/code&gt; 是 Webpack 的特殊语法，用来设置 组件根路径 按需加载。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://webpack.js.org/api/module-methods/#require-ensure&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以 &lt;code&gt;VUE&lt;/code&gt; 项目举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vue Router
import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;

Vue.use(Router)

export default new Router({
  // require.ensure 是 Webpack 的特殊语法，用来设置 组件根路径 按需加载
  routes: [
    {
      path: &#39;/&#39;,
      name: &#39;index&#39;,
      redirect: &#39;/home&#39;,
      component (reslove) {
        require.ensure([&#39;../App.vue&#39;], () =&amp;gt; {
          reslove(require(&#39;../App.vue&#39;))// 完成调用
        })
      },
      children: [{
        path: &#39;/order&#39;,
        name: &#39;order&#39;,
        component (reslove) {
          require.ensure(&#39;../components/order/Order.vue&#39;, () =&amp;gt; {
            reslove(require(&#39;../components/order/Order.vue&#39;))
          })
        }
      },
      {
        path: &#39;/home&#39;,
        name: &#39;home&#39;,
        component (reslove) {
          require.ensure(&#39;../components/homepage/Home.vue&#39;, () =&amp;gt; {
            reslove(require(&#39;../components/homepage/Home.vue&#39;))
          })
        }
      },
      {
        path: &#39;/drag&#39;,
        name: &#39;drag&#39;,
        component (reslove) {
          require.ensure(&#39;../components/drag/drag.vue&#39;, () =&amp;gt; {
            reslove(require(&#39;../components/drag/drag.vue&#39;))
          })
        }
      }]
    }
  ]
})

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;Vue Router&lt;/code&gt; 官方文档还推荐使用动态 import 语法来进行代码分块，比如上述 require.ensure 代码可以修改为：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 引入 Order 组件
const Order = () =&amp;gt; import(&#39;../components/order/Order.vue&#39;);

// 引入 Home 组件
const Home = () =&amp;gt; import(&#39;../components/homepage/Home.vue&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其余代码可以保持不变，仍然可以实现同样的功能。如果你想给拆分出的文件命名，可以尝试一下 webpack 提供的 &lt;code&gt;Magic Comments&lt;/code&gt;（魔法注释）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Home = () =&amp;gt; import(/* webpackChunkName:&#39;home&#39;*/ &#39;./views/Home.vue&#39;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>localStorage 统一管理设置-增加时间</title>
      <link>/2018/local-stroge/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/local-stroge/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;设置本地存储&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function setStorage(key: string, value: any) {
  try {
    localStorage.setItem(key,  JSON.stringify({
      data: value,
      time: Date.now(),
    }));
  } catch {
    console.log(&#39;localStorage.setItem error&#39;);
    console.log(key, value);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;获取本地存储&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 注意：stringify 会过滤掉undefined的值
function getStorage(key: string) {
  const result = localStorage.getItem(key);
  if (result) {
    try {
      const objRes = JSON.parse(result);
      return objRes;
    } catch (e) {
      console.log(&#39;JSON.parse error:&#39;, result);
      return result;
    }
  } else {
    return result;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;删除本地存储&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function removeStorage(key: string) {
  localStorage.removeItem(key);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker 相关</title>
      <link>/2018/docker/</link>
      <pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/docker/</guid>
      <description>

&lt;h1 id=&#34;docker-相关&#34;&gt;Docker 相关&lt;/h1&gt;

&lt;h2 id=&#34;搭建-gitlab&#34;&gt;搭建 gitLab&lt;/h2&gt;

&lt;h3 id=&#34;搜索镜像&#34;&gt;搜索镜像&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker search gitlab-ce
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看镜像&#34;&gt;查看镜像&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Hapi</title>
      <link>/2018/hapi/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/hapi/</guid>
      <description>

&lt;h1 id=&#34;hapi&#34;&gt;Hapi&lt;/h1&gt;

&lt;h2 id=&#34;hapi-相关使用总结&#34;&gt;Hapi 相关使用总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hapi.js 是一个用来构建基于 Node.js 的应用和服务的富框架，使得开发者把重点放在便携可重用的应用逻辑而不是构建架构。内建输入验证、缓存、认证和其他 Web 应用开发常用的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hapi-框架模块接口文档&#34;&gt;Hapi 框架模块接口文档&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hapijs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hapijs.com/api&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Hapi-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;supervisor-nodemon-pm2&#34;&gt;Supervisor / nodemon / PM2&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;有不少 Node.js 小工具能帮助我们监视代码的改动然后自动重启 Node.js 服务，好用的工具有 &lt;code&gt;Supervisor / nodemon / PM2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 系统全局安装 supervisor
$ npm i -g supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;目录结构&#34;&gt;目录结构&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;├── config                       # 项目配置目录
|   ├── index.js                 # 配置项目中的配置信息
├── models                       # 数据库 model
├── node_modules                 # node.js 的依赖目录
├── plugins                      # 插件目录
├── routes                       # 路由目录
│   ├── hello-world.js           # 测试接口 hello-world
├── utils                        # 工具类相关目录
├── app.js                       # 项目入口文件
├── package.json                 # JS 项目工程依赖库
├── README.md                    # 项目工程如何被使用的说明手册
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;环境配置&#34;&gt;环境配置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;例子：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# .env.example

# 服务的启动名字和端口，但也可以缺省不填值，默认值的填写只是一定程度减少起始数据配置工作
HOST = 127.0.0.1
PORT = 3000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;读取-env-中的配置值&#34;&gt;读取 .env 中的配置值&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Node.js 可以通过 env2 的插件，来读取 .env 配置文件，加载后的环境配置参数，可以通过例如 process.env.PORT 来读取端口信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i env2 -D
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-swagger-插件配置接口文档&#34;&gt;使用 Swagger 插件配置接口文档&lt;/h3&gt;

&lt;h4 id=&#34;安装基础依赖与基础插件配置&#34;&gt;安装基础依赖与基础插件配置&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装适配 hapi v16 的 swagger 插件
npm i hapi-swagger@7
npm i inert@4
npm i vision@4
npm i package
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;├── plugins                       # hapi 插件配置
|   ├── hapi-swagger.js           # swagger 插件
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;通过 &lt;strong&gt;自己的服务地址+/documentation&lt;/strong&gt; 来查看 Swagger 文档。&lt;em&gt;&lt;a href=&#34;http://192.168.31.10:8181/documentation&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://192.168.31.10:8181/documentation&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-joi-校验数据结构&#34;&gt;使用 Joi 校验数据结构&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装适配 hapi v16 的 joi 插件
npm i joi@13
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql修改默认编码&#34;&gt;MySQL修改默认编码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;show variables like &#39;%char%&#39;;&lt;/code&gt; 查看默认编码&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysql&amp;gt; show variables like &#39;%char%&#39;;
+--------------------------+---------------------------------------------------------+
| Variable_name            | Value                                                   |
+--------------------------+---------------------------------------------------------+
| character_set_client     | gbk                                                     |
| character_set_connection | gbk                                                     |
| character_set_database   | utf8                                                    |
| character_set_filesystem | binary                                                  |
| character_set_results    | gbk                                                     |
| character_set_server     | utf8                                                    |
| character_set_system     | utf8                                                    |
| character_sets_dir       | C:\Program Files\MySQL\MySQL Server 5.7\share\charsets\ |
+--------------------------+---------------------------------------------------------+
8 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改mysql编码，（version：5.7.24）Window10下 &lt;code&gt;my.ini&lt;/code&gt;文件路径在 &lt;code&gt;C:\ProgramData\MySQL\MySQL Server 5.7\&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在my.ini添加如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[mysqld]
character-set-server=utf8
[client]
default-character-set=utf8
[mysql]
default-character-set=utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql-与-sequelize&#34;&gt;MySQL 与 Sequelize&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;数据库为 MySQL 5.6。&lt;a href=&#34;https://sequelize.readthedocs.io/en/v3/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Sequelize&lt;/a&gt; 则是 Node.js 生态中一款知名的基于 promise 数据库 ORM 插件，提供了大量常用数据库增删改查的函数式 API，以帮助我们在实际开发中，大量减少书写冗长的基础数据库查询语句。&lt;/li&gt;
&lt;li&gt;Sequelize 支持的数据库有：&lt;code&gt;PostgreSQL，MySQL，MariaDB，SQLite 和 MSSQL。&lt;/code&gt;在使用不同的数据库时候，需要我们开发者额外安装不同的对应数据库连接驱动，d当前使用的 MySQL，则依赖于插件 MySQL2 。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# MySQL 连接
[root@vultr ~]# mysql -u root -p
Enter password: *******

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.22 MySQL Community Server (GPL)

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

# 查看数据库编码格式
mysql&amp;gt; show variables like &#39;%char%&#39;;
+--------------------------+---------------------------------------------------------+
| Variable_name            | Value                                                   |
+--------------------------+---------------------------------------------------------+
| character_set_client     | utf8                                                    |
| character_set_connection | utf8                                                    |
| character_set_database   | latin1                                                  |
| character_set_filesystem | binary                                                  |
| character_set_results    | utf8                                                    |
| character_set_server     | latin1                                                  |
| character_set_system     | utf8                                                    |
| character_sets_dir       | C:\Program Files\MySQL\MySQL Server 5.7\share\charsets\ |
+--------------------------+---------------------------------------------------------+
8 rows in set, 1 warning (0.00 sec)

# 创建用户
# 说明：
# username：你将创建的用户名
# host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%
# password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器
mysql&amp;gt; CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;

# 授权
# 说明:
# privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL
# databasename：数据库名
# tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*
# 例子：
# GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;
# GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;
mysql&amp;gt; GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;;
# 注意:用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:
mysql&amp;gt; GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; WITH GRANT OPTION;

# 设置与更改用户密码
mysql&amp;gt; SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;);
# 如果是当前登陆用户用:
mysql&amp;gt; SET PASSWORD = PASSWORD(&amp;quot;newpassword&amp;quot;);

# 撤销用户权限
# 说明：说明:privilege, databasename, tablename：同授权部分
# 注意：
# 假如你在给用户&#39;pig&#39;@&#39;%&#39;授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO &#39;pig&#39;@&#39;%&#39;，则在使用REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON *.* TO &#39;pig&#39;@&#39;%&#39;;则REVOKE SELECT ON test.user FROM &#39;pig&#39;@&#39;%&#39;;命令也不能撤销该用户对test数据库中user表的Select权限。
# 具体信息可以用命令SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;; 查看
mysql&amp;gt; REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;

# 删除用户
mysql&amp;gt; DROP USER &#39;username&#39;@&#39;host&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sequelize-cli&#34;&gt;Sequelize-cli&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sequelize 插件的主要应用场景是实际应用开发过程中的代码逻辑层。与其相伴的还有一套 cli 工具，Sequelize-cli，提供了一系列好用的终端指令，来帮助我们完成一些常用的琐碎任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装依赖&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i sequelize-cli -D
npm i sequelize
npm i mysql2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;sequelize init (通过 sequelize-cli 初始化 sequelize，我们将得到一个好用的初始化结构：)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# windows下
node_modules\.bin\sequelize init
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;├── config                       # 项目配置目录
|   ├── config.[json|js]              # 数据库连接的配置
├── models                       # 数据库 model
|   ├── index.js                 # 数据库连接的样板代码
├── migrations                   # 数据迁移的目录
├── seeders                      # 数据填充的目录
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;sequelize db:create&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;执行下面的命令，可以默认使用 development 下的配置，来创建项目数据库。增加例如 &amp;ndash;env production，则使用 config/config.js 中的 production 项配置，来完成数据库的创建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node_modules\.bin\sequelize db:create

# 通过 --env 参数，指定为生产环境创建项目数据库
# node_modules\.bin\sequelize db:create --env production
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;migrate-数据迁移&#34;&gt;migrate 数据迁移&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;sequelize migration:create &lt;em&gt;使用 sequelize migration:create 来创建一个迁移文件 create-shops-table。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node_modules\.bin\sequelize migration:create --name create-shops-table
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;sequelize db:migrate &lt;em&gt;帮助将 migrations 目录下的迁移行为定义，按时间戳的顺序，逐个地执行迁移描述，最终完成数据库表结构的自动化创建。并且，在数据库中会默认创建一个名为 SequelizeMeta 的表，用于记录在当前数据库上所运行的迁移历史版本。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node_modules\.bin\sequelize db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mysql&amp;gt; show tables;
+---------------------+
| Tables_in_practtest |
+---------------------+
| goods               |
| sequelizemeta       |
| shops               |
+---------------------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sequelize db:migrate:undo &lt;em&gt;sequelize db:migrate:undo 则可以帮助我们按照 down 方法中所定义的规则，回退一个数据库表结构迁移的状态。&lt;code&gt;node_modules\.bin\sequelize db:migrate:undo&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;向表中追加字段 &lt;em&gt;创建一个名叫 add-columns-to-shops-table 的迁移迁移文件：&lt;code&gt;node_modules\.bin\sequelize migration:create --name add-columns-to-shops-table&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = {
  up: (queryInterface, Sequelize) =&amp;gt; Promise.all([
    queryInterface.addColumn(&#39;shops&#39;, &#39;address&#39;, { type: Sequelize.STRING }),
  ]),

  down: queryInterface =&amp;gt; Promise.all([
    queryInterface.removeColumn(&#39;shops&#39;, &#39;address&#39;),
  ]),
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 之前的表结构
mysql&amp;gt; desc shops;
+------------+--------------+------+-----+---------+----------------+
| Field      | Type         | Null | Key | Default | Extra          |
+------------+--------------+------+-----+---------+----------------+
| id         | int(11)      | NO   | PRI | NULL    | auto_increment |
| name       | varchar(255) | NO   |     | NULL    |                |
| thumb_url  | varchar(255) | YES  |     | NULL    |                |
| created_at | datetime     | YES  |     | NULL    |                |
| updated_at | datetime     | YES  |     | NULL    |                |
+------------+--------------+------+-----+---------+----------------+
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 再次运行完 node_modules\.bin\sequelize db:migrate 后的表结构
mysql&amp;gt; desc shops;
+------------+--------------+------+-----+---------+----------------+
| Field      | Type         | Null | Key | Default | Extra          |
+------------+--------------+------+-----+---------+----------------+
| id         | int(11)      | NO   | PRI | NULL    | auto_increment |
| name       | varchar(255) | NO   |     | NULL    |                |
| thumb_url  | varchar(255) | YES  |     | NULL    |                |
| created_at | datetime     | YES  |     | NULL    |                |
| updated_at | datetime     | YES  |     | NULL    |                |
| address    | varchar(255) | YES  |     | NULL    |                |
+------------+--------------+------+-----+---------+----------------+
6 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;seeders-种子数据填充&#34;&gt;seeders 种子数据填充&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sequelize seed:create &lt;em&gt;&lt;code&gt;node_modules\.bin\sequelize seed:create --name init-shops&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sequelize db:seed:all &lt;em&gt;与 db:migrate 相似，执行 sequelize db:seed:all ，将向数据库填充 seeders 目录中所有 up 方法所定义的数据。&lt;code&gt;node_modules\.bin\sequelize db:seed:all&lt;/code&gt;&lt;/em&gt;&lt;strong&gt;注意: seeders 的执行，不会将状态存储在 SequelizeMeta 表中。&lt;/strong&gt;(当然，我们也可以通过 &lt;code&gt;--seed&lt;/code&gt; 来制定特定的 &lt;code&gt;seed&lt;/code&gt; 配置来做填充：
&lt;code&gt;node_modules\.bin\sequelize db:seed --seed 20190103082032-init-goods.js&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 添加后的数据表
mysql&amp;gt; select * from shops;
+----+-------+-----------+---------------------+---------------------+---------+
| id | name  | thumb_url | created_at          | updated_at          | address |
+----+-------+-----------+---------------------+---------------------+---------+
|  1 | 店铺1 | 1.png     | 2018-12-30 12:10:22 | 2018-12-30 12:10:22 | NULL    |
|  2 | 店铺2 | 2.png     | 2018-12-30 12:10:22 | 2018-12-30 12:10:22 | NULL    |
|  3 | 店铺3 | 3.png     | 2018-12-30 12:10:22 | 2018-12-30 12:10:22 | NULL    |
|  4 | 店铺4 | 4.png     | 2018-12-30 12:10:22 | 2018-12-30 12:10:22 | NULL    |
|  5 | 店铺5 | 5.png     | 2018-12-30 12:10:22 | 2018-12-30 12:10:22 | NULL    |
+----+-------+-----------+---------------------+---------------------+---------+
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;sequelize db:seed:undo &lt;em&gt;Seeders 所填充的数据，也与迁移的 db:migrate:undo 相仿，只是不会进入 SequelizeMeta 记录。两个可用的命令如下，很简单，不再赘述：&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
# 撤销所有的种子
node_modules\.bin\sequelize db:seed:undo:all
# 数据表
mysql&amp;gt; select * from shops;
+----+-------+-----------+---------------------+---------------------+---------+
| id | name  | thumb_url | created_at          | updated_at          | address |
+----+-------+-----------+---------------------+---------------------+---------+
|  5 | 店铺5 | 5.png     | 2018-12-30 12:10:22 | 2018-12-30 12:10:22 | NULL    |
+----+-------+-----------+---------------------+---------------------+---------+
1 row in set (0.00 sec)

# 撤销指定的种子
node_modules\.bin\sequelize db:seed:undo --seed XXXXXXXXXXXXXX-demo-user.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sequelize-连接-mysql-数据库&#34;&gt;Sequelize 连接 MySQL 数据库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Sequelize 连接数据库的核心代码主要就是通过 new Sequelize（database, username, password, options） 来实现，其中 options 中的配置选项，除了最基础的 host 与 port、数据库类型外，还可以设置连接池的连接参数 pool，数据模型命名规范 underscored 等等。具体可以查阅官方手册 &lt;a href=&#34;http://docs.sequelizejs.com/manual/installation/usage.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;基础使用&lt;/a&gt;。&lt;strong&gt;希望遵循 MySQL 数据库表字段的下划线命名规范，所以，需要全局开启一个 &lt;code&gt;underscore: true&lt;/code&gt; 的定义，来使系统中默认的 createdAt 与 updatedAt 能以下划线的方式，与表结构保持一致。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;定义数据库业务相关的-model&#34;&gt;定义数据库业务相关的 model&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;结合业务所需，可以在存放 models 目录下继续创建一系列的 model 来与数据库表结构做对应：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;├── models                       # 数据库 model
│   ├── index.js                 # model 入口与连接
│   ├── goods.js                 # 商品表
│   ├── shops.js                 # 店铺表
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;实现接口&#34;&gt;实现接口&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;很多时候，我们并不希望 findAll 来将数据表中的所有数据全都暴露出来，比如在查询用户列表时，用户的密码的值，便是特别敏感的数据。 我们可以在 findAll 中加入一个 &lt;code&gt;attributes&lt;/code&gt; 的约束，可以是一个要查询的属性（字段）列表，或者是一个 key 为 &lt;code&gt;include&lt;/code&gt; 或 &lt;code&gt;exclude&lt;/code&gt; 对象的键，比如对于用户表，&lt;code&gt;findAll({ attributes: { exclude: [&#39;password&#39;] } })&lt;/code&gt;，就可以排除密码字段的查询露出。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Joi = require(&#39;joi&#39;)
const models = require(&#39;../models&#39;)

const GROUP_NAME = &#39;shops&#39;

module.exports = [
  {
    method: &#39;GET&#39;,
    path: `/${GROUP_NAME}`,
    handler: async (request, reply) =&amp;gt; {
      // 查找数据
      const result = await models.shops.findAll({
        // 只返回 id 和 name
        attributes: [&#39;id&#39;, &#39;name&#39;]
      })
      reply(result)
    },
    config: {
      tags: [&#39;api&#39;, GROUP_NAME],
      description: &#39;获取店铺列表&#39;,
      // 适用于 GET 接口的 query（URL 路径参数）
      validate: {
        query: {
          limit: Joi.number().integer().min(1).default(10).description(&#39;每页条数&#39;),
          // error(new Error(&#39;页码数不能为0！&#39;))  显示的错误信息为中文（message）
          page: Joi.number().integer().min(1).default(1).description(&#39;页码数&#39;).error(new Error(&#39;页码数不能为0！&#39;))
        }
      }
    }
  },
  ...
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;列表分页 &lt;code&gt;options&lt;/code&gt; 的具体配置参数细节说明，参见 &lt;a href=&#34;https://github.com/fknop/hapi-pagination/tree/v1.6.5&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;hapi-pagination&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装适配 hapi v16 的 hapi-pagination
$ npm i hapi-pagination@1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基于-jwt-的身份验证&#34;&gt;基于 JWT 的身份验证&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JWT 全称 JSON Web Token，是为了方便在各系统之间安全地传送 JSON 对象格式的信息，而采用的一个开发标准，基于 RFC 7519 定义。服务器在接收到 JWT 之后，可以验证它的合法性，用户登录与否的身份验证便是 JWT 的使用场景之一。&lt;/li&gt;
&lt;li&gt;JWT 具有「紧凑」与「自包含」的两大特点: 紧凑（compact）、自包含（self-contained）&lt;/li&gt;
&lt;li&gt;JWT 的构成&amp;mdash;JSON Web Token 由 header、payload、signature 三部分组成，使用点号 . 分隔，下面是一段典型的 JWT 串:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# header
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
# payload
eyJ1c2VySWQiOjEsImV4cCI6MTUzNTMyMjc0NSwiaWF0IjoxNTM0NzE3OTQ1fQ.
# signature
6tOdn2R82bxJbXjAnwU5g4g9EKqGNe-qo4qCo6UZnQ
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;header &amp;ndash; JWT 第一部分 header 指定了该 JWT 使用的签名算法：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &amp;quot;alg&amp;quot;: &amp;quot;HS256&amp;quot;, &amp;quot;typ&amp;quot;:&amp;quot;JWT&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;payload &amp;ndash; JWT 的第二部分 &lt;code&gt;payload&lt;/code&gt; 包含了该 JWT 的签发内容信息。以如上述 JWT 串为例，被解码之后，可以得到如下信息，包涵有用户 &lt;code&gt;ID&lt;/code&gt;，&lt;code&gt;JWT&lt;/code&gt; 过期时间 &lt;code&gt;exp&lt;/code&gt;，&lt;code&gt;JWT&lt;/code&gt; 签发时间 &lt;code&gt;iat&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;userId&amp;quot;: 1,
  &amp;quot;exp&amp;quot;: 1535322745,
  &amp;quot;iat&amp;quot;: 1534717945
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 JWT 的规范有一套预设的标准注册声明，非必要项，在业务场景需要的时候加入：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iss(issuer)&lt;/code&gt;：JWT 的签发者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sub(subject)&lt;/code&gt;：JWT 所面向的用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aud(audience)&lt;/code&gt;：接收 JWT 的一方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exp(expiresIn)&lt;/code&gt;：JWT 的过期时间，这个时间必须大于签发时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nbf(notBefore)&lt;/code&gt;：定义在什么时间之前，该 JWT 都是不可用的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iat(issuedAt)&lt;/code&gt;：JWT 的签发时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jti(jwtid)&lt;/code&gt;：JWT 的唯一身份标识，主要用来作为一次性 token，从而避免重放攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的信息数据，可以在 payload 中额外追加，避免与预设保留字冲突就好。&lt;br /&gt;
&lt;em&gt;注意&lt;/em&gt; ：对于已签发的 JWT, 尽管信息是可以受到下文 signature 的签名防篡改保护，但 payload 部分的内容，依旧任何人都可以 decode 解码阅读。故而不要在 payload 中存放诸如密码密秘类的安全敏感数据。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;signature &amp;ndash; JWT 的第三部分 signature 用来验证签发数据的合法性，是否存在第三方篡改伪造行为。由 header + payload + 签发 secret 组合而成。有心的读者可以发现，其中的参数条件 header 和 payload 皆为 base64 的编码内容，base64 是一种可双向的编码算法，所以不具备数据安全性。唯有 secret 的参数条件，在 JWT 最终的生成串中并不公开，所以在服务端保管好 secret 的签发字符串的私密性尤为重要，随意地将其提交进 git 的代码版本库，是一种极度不严谨行为。 以 HS256 算法为例，signature 的签发算法如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;HMACSHA256(base64UrlEncode(header) + &amp;quot;.&amp;quot; + base64UrlEncode(payload), secret)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Secret&lt;/code&gt; 的秘钥签发，可以通过一些在线的 AES 加密工具来生成一串长度 32 或 64 的随机字符串。比如： &lt;a href=&#34;http://tool.oschina.net/encrypt/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;tool.oschina.net/encrypt/&lt;/a&gt; 。太长的字符串会一定程度上影响 jwt 验证的计算效率，所以找寻一个平衡点为宜。&lt;/p&gt;

&lt;h4 id=&#34;基于-jwt-的身份验证的好处&#34;&gt;基于 JWT 的身份验证的好处&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨语言性&lt;/strong&gt;：payload 数据结构基于 JSON，可以被任何主流语言支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;免疫 CSRF&lt;/strong&gt;：对 Cookie 的不依赖性，决定了天然免疫 CSRF 攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可跨域性&lt;/strong&gt;：同样是对 Cookie 的不依赖性，决定了更好的跨域支持与独立服务化属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多端适配&lt;/strong&gt;：iOS， Android，微信小程序等非网页客户端，Cookie 是不被支持的，JWT 的认证机制则会简单很多。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;去耦可扩展性&lt;/strong&gt;：JWT 可以在任何拥有正确 secret 私钥的 API 服务环境被身份验证和使用，便于微服务拆分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;基于-jwt-身份验证的注意项&#34;&gt;基于 JWT 身份验证的注意项&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;不要在 JWT 的 payload 中签入敏感信息&lt;/li&gt;
&lt;li&gt;保护好 secret 秘钥&lt;/li&gt;
&lt;li&gt;使用 HTTPS 传输 JWT&lt;/li&gt;
&lt;li&gt;设置较短的 JWT 失效时间，并结合一个失效较长的 JWT RefreshToken 组合为宜。因为 JWT 无法轻易失效已签发的合法 JWT&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;使用-jsonwebtoken-签发-jwt&#34;&gt;使用 jsonwebtoken 签发 JWT&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;jsonwebtoken 是 Node.js 生态里用于签发与校验 JWT 的流行插件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;jwt-sign-签发&#34;&gt;jwt.sign 签发&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;JWT 的签发语法是 &lt;code&gt;jwt.sign(payload, secretOrPrivateKey, [options, callback])&lt;/code&gt;。默认的签发算法基于 &lt;code&gt;HS256 (HMAC SHA256)&lt;/code&gt;，可以在 options 参数的 &lt;code&gt;algorithm&lt;/code&gt; 另行修改。JWT 签发规范中的一些标准保留字段比如 &lt;code&gt;exp&lt;/code&gt;，&lt;code&gt;nbf&lt;/code&gt;，&lt;code&gt;aud&lt;/code&gt;，&lt;code&gt;sub&lt;/code&gt;，&lt;code&gt;iss&lt;/code&gt; 等都没有默认值，可以一并在 &lt;code&gt;payload&lt;/code&gt;参数中按需声明使用，亦可以在第三个参数 options 中，通过 &lt;code&gt;expiresIn&lt;/code&gt;，&lt;code&gt;notBefore&lt;/code&gt;，&lt;code&gt;audience&lt;/code&gt;，&lt;code&gt;subject&lt;/code&gt;，&lt;code&gt;issuer&lt;/code&gt; 来分别赋值，但是不允许在两处同时声明。&lt;/li&gt;
&lt;li&gt;可以通过 &lt;a href=&#34;https://jwt.io/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JWT&lt;/a&gt; 来 decode JWT 中的 payload 信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;hapi-auth-jwt2-接口用户验证&#34;&gt;hapi-auth-jwt2 接口用户验证&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i hapi-auth-jwt2@7
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;hapi-auth-jwt2 配置&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;├── plugins                       # hapi 插件配置
│ ├── hapi-auth-jwt2.js           # jwt 配置插件
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sequelize-支持两种使用事务的方法&#34;&gt;Sequelize 支持两种使用事务的方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;托管事务&lt;/li&gt;
&lt;li&gt;非托管事务&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;在一个事务中，可能会包含开始（start）、提交（commit）、回滚（rollback）等操作，Sequelize 通过 &lt;a href=&#34;http://docs.sequelizejs.com/manual/tutorial/transactions.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Transaction&lt;/a&gt;类来实现事务相关功能。以满足一些对操作过程的完整性比较高的使用场景。&lt;/em&gt;
&lt;em&gt;托管事务基于 Promise 结果链进行自动提交或回滚。非托管事务则交由用户自行控制提交或回滚。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;微信接收的数据与返回的格式都是以-text-xml-的格式-而非-application-json-需要引入-xml2js-的插件帮助在-javascript-的-ojbect-与-xml-的-object-数据关系之间快速转换&#34;&gt;微信接收的数据与返回的格式都是以 text/xml 的格式，而非 application/json ，需要引入 xml2js 的插件帮助在 JavaScript 的 Ojbect 与 XML 的 Object 数据关系之间快速转换&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i xml2js
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;系统监控与记录-使用-good-插件&#34;&gt;系统监控与记录 —— 使用 Good 插件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Good 是一个 hapi 插件，用于监视和报告来自主机的各种 hapi 服务器事件以及 ops 信息。它侦听 hapi 服务器实例发出的事件，并将标准化事件推送到流集合中。Good 插件目前有这四个扩展功能： good-squeeze、good-console、good-file、good-http。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i good@7
npm i good-squeeze@5
npm i good-console@7
npm i good-file@6
npm i good-http@6
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;good-squeeze：good-squeeze 是一个小转换流的集合。它提供了两个类，Squeeze 和 SafeJson, Squeeze 流基于良好的事件选项来过滤事件。SafeJson 流用于把对象转成 JSON 字符串，并且可以防止对象中循环引用引起的错误。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;good-console：good-console 能够将服务 good 服务事件转化为格式化字符串的转换流插件，最终通过 stdout 在控制台打印输出。
&amp;gt; GoodConsole([config])
&amp;gt; good-console 本身提供 3 个参数来简单配置控制台的打印信息：
&amp;gt; * format：使用 MomentJS 格式化时间， 默认值 YYMMDD/HHmmss.SSS
&amp;gt; * utc：boolean 输出时间是否为布尔值， 默认值 true
&amp;gt; * color：boolean 是否彩色输出，默认值 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;good-file：基于 good-console 的控制台输出日志，当遇到控制台断开或是重启的时候，历史日志将无法找回，此时，在本地生成一份写文件的日志记录，会更好地便于日后的追溯。good-file 插件很好地解决了这样的需求痛点。
&amp;gt; GoodFile (path, options)
&amp;gt; * path：必填项，用来定义日志的写入目录
&amp;gt; * options：选填项，文件流的选项。 默认值为&lt;code&gt;{ encoding: &#39;utf8&#39;, flags: &#39;a&#39;, mode: 0o666 }&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;good-http：除此之外，在实际应用场景中，我们会遇到一些高危异常的错误情况，这类日志我们更希望能在错误发生的第一时间，就通过自动报警的方式，来通知开发人员及时介入响应。这里可以使用 good-http 插件，它可以构造一个 post 的请求接口，将定义的重要日志信息以 JSON 的数据结构方式，推送到目标端点。
&amp;gt; GoodHttp (endpoint, config)
&amp;gt; * endpoint：日志发送的目标地址
&amp;gt; * config：Object 类型的配置项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组合使用日志插件：在实际项目使用中，可以进行组合性配置，在 reporters 字段中使用不同的 key 来区分即可&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;reporters: {
  typeConsole: [
    // good-console 的一系列配置
  ],
  typeFile: [
    // good-file 的一系列配置
  ],
  typeHttpA: [
    // good-http 针对 A 平台的一系列配置
  ],
  typeHttpB: [
    // good-http 针对 B 平台的一系列配置
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-good-http-结合-sentry-自动收集错误日志&#34;&gt;使用 good-http 结合 Sentry 自动收集错误日志&lt;/h3&gt;

&lt;h4 id=&#34;sentry-简介&#34;&gt;Sentry 简介&lt;/h4&gt;

&lt;p&gt;Sentry 中文翻译过来是哨兵的意思，从字面中可以知道 「站岗、放哨、巡逻、稽查的士兵」，不错，Sentry 是程序的「哨兵」 。它可以监控我们在生产环境中项目的运行状态，一旦某段代码运行报错，或者异常，会第一时间把报错的 路由，异常文件，请求方式 等一些非常详细的信息以消息或者邮件给我们，让我们第一时间知道：程序出错了，然后我们可以从 Sentry 给我们的详细的错误信息中瞬间找到我们需要处理的代码，并及时修正。&lt;/p&gt;

&lt;h4 id=&#34;sentry-服务搭建流程&#34;&gt;Sentry 服务搭建流程&lt;/h4&gt;

&lt;p&gt;利用 hapi 的 API 服务能力再搭建一个简易的内网 API 服务，该服务使用 Sentry 的 raven 插件进行错误日志的收集与汇报，日志的信息源来自应用服务的 good-http 插件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;申请 Sentry 的 API key&lt;/li&gt;
&lt;li&gt;配置 Sentry 的错误收集与报告插件 raven&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i raven
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Raven = require(&#39;raven&#39;)
Raven.config(&#39;https://your-sentry-api-key@sentry.io/182062&#39;).install()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;提供错误日志接收服务&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  method: &#39;POST&#39;,
  path: &#39;/reportErrorLog&#39;,
  handler: async (request, reply) =&amp;gt; {
    //直接将请求参数上报到 Sentry
    Raven.captureException(request.payload)
    reply()
  },
  config: {
    tags: [&#39;api&#39;, &#39;report&#39;],
    auth: false,
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;配置应用服务中 good-http 的错误日志推送到上述含有 Sentry raven 的 API 微服务&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;server.register({
  plugin: require(&#39;good&#39;),
  {
    ops: {
      interval: 1000
    },
    reporters: {
      typeHttp: [
        {
          module: &#39;good-squeeze&#39;,
          name: &#39;Squeeze&#39;,
          args: [{ error: &#39;*&#39; }]
        },
        {
          module: &#39;good-http&#39;,
          args: [&#39;http://your-sentry-server/reportErrorLog&#39;, {}]
        }
      ]
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
