<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Magic on Magic</title>
    <link>/</link>
    <description>Recent content in Magic on Magic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 02 Dec 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Docker Gitlab</title>
      <link>/2019/docker-gitlab/</link>
      <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/docker-gitlab/</guid>
      <description>

&lt;h1 id=&#34;安装-gitlab&#34;&gt;安装 Gitlab&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;目录类似 Jenkins，使用 docker-compose 安装&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;version: &#39;3&#39;
services:
    docker-gitlab:
      image: &#39;twang2218/gitlab-ce-zh:9.4&#39;
      restart: &#39;no&#39;
      container_name: gitlab
      hostname: &#39;gitlab.xxxxx.com&#39;
      environment:
        TZ: &#39;Asia/Shanghai&#39;
        GITLAB_OMNIBUS_CONFIG: |
          external_url &#39;http://gitlab.xxxxxx.com&#39;
          unicorn[&#39;worker_timeout&#39;] = 60
          unicorn[&#39;worker_processes&#39;] = 2
          gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39;
          gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 26
          nginx[&#39;client_max_body_size&#39;] = &#39;250m&#39;
      ports:
       - &#39;81:80&#39;
       - &#39;443:443&#39;
       - &#39;26:22&#39;
      volumes:
       - /home/gitlab/gitlab_home/config:/etc/gitlab
       - /home/gitlab/gitlab_home/data:/var/opt/gitlab
       - /home/gitlab/gitlab_home/logs:/var/log/gitlab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在当前目录下运行 &lt;code&gt;docker-compose up -d&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;nginx-代理&#34;&gt;Nginx 代理&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;upstream gitlab {
 server 116.62.201.97:81;
}

server {
 listen 80;
 server_name gitlab.xxx.com;

 location / {
  client_max_body_size 900m;
  proxy_redirect off;
  # 以下确保 gitlab中项目的 url 是域名而不是 http://git，不可缺少
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  # 反向代理到 gitlab 内置的 nginx
  proxy_pass http://gitlab;
  index index.html index.htm;
 }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker Jenkins</title>
      <link>/2019/docker-jenkins/</link>
      <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/docker-jenkins/</guid>
      <description>

&lt;h1 id=&#34;安装-jenkins&#34;&gt;安装 jenkins&lt;/h1&gt;

&lt;p&gt;在安装jenkins我选择了使用docker-compose，docker-compose 是一个用来把 docker 自动化的东西&lt;br /&gt;
有了 docker-compose 你可以把所有繁复的 docker 操作全都一条命令，自动化的完成。&lt;/p&gt;

&lt;h3 id=&#34;首先我们需要在服务器上创建一个目录机构&#34;&gt;首先我们需要在服务器上创建一个目录机构&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;/home/jenkins
  - docker-compose.yml
  - jenkins-home
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;接下来我们来编写-docker-compose-yml-安装jenkins&#34;&gt;接下来我们来编写 docker-compose.yml 安装jenkins&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;version: &#39;3&#39;    # 指定 docker-compose.yml 文件的写法格式

services:       # 多个容器集合
  docker_jenkins:
    user: root  # 为了避免一些权限问题 在这我使用了root
    restart: always # 重启方式
    image: jenkins/jenkins:lts  # 指定服务所使用的镜像 在这里我选择了 LTS (长期支持)
    container_name: jenkins # 容器名称
    ports:      # 对外暴露的端口定义
      - &#39;8899:8080&#39;
      - &#39;50000:50000&#39;
    volumes:    # 卷挂载路径
      - /home/jenkins/jenkins_home/:/var/jenkins_home  # 这是我们一开始创建的目录挂载到容器内的jenkins_home目录
      - /var/run/docker.sock:/var/run/docker.sock
      - /usr/bin/docker:/usr/bin/docker     # 这是为了我们可以在容器内使用docker命令
      - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose # 同样的这是为了使用docker-compose命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要进入到 jenkins 目录下执行：&lt;code&gt;docker-compose up -d&lt;/code&gt;，开启守护进程后台执行(停止 &lt;code&gt;docker-compose down&lt;/code&gt;)这个命令会帮我们自动拉取镜像并配置，不出意外你现在可以打开你的服务器地址 &lt;a href=&#34;http://xxxxxxx&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://xxxxxxx&lt;/a&gt;:端口号 就能看到这个界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/12/05/Q8sYxP.png&#34; alt=&#34;Q8sYxP.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开你所创建的jenkins目录进入到jenkins_home：&lt;code&gt;/home/jenkins/jenkins-home&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;进入 secrets 目录并打印下： &lt;code&gt;cat initialAdminPassword&lt;/code&gt;：（dadasdf324324dasdasd3243432）,然后把里面的文本复制出来填到管理员密码中：
&lt;img src=&#34;https://s2.ax1x.com/2019/12/05/Q8yAeS.png&#34; alt=&#34;Q8yAeS.png&#34; /&gt;
接下来需要安装几个插件：&lt;code&gt;NodeJS Plugin&lt;/code&gt;，&lt;code&gt;Publish Over SSH&lt;/code&gt;，&lt;code&gt;Git Parameter Plug-In&lt;/code&gt;（举例）
&lt;img src=&#34;https://s2.ax1x.com/2019/12/05/Q867DK.png&#34; alt=&#34;Q867DK.png&#34; /&gt;
然后到全局工具配置（举例）
&lt;img src=&#34;https://s2.ax1x.com/2019/12/05/Q8cgMt.png&#34; alt=&#34;Q8cgMt.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;nginx-代理&#34;&gt;Nginx 代理&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;upstream jenkins {
 server xxxxxxxxxxxx:8899;
}

server {
 listen 80;
 server_name jenkins.ex.com;

 location / {
  proxy_pass http://jenkins;
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo nginx -t&lt;/code&gt; 检测配置是否正确&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo service nginx restart&lt;/code&gt; 重启 nginx&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-删除链表中的节点</title>
      <link>/2019/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>

&lt;h2 id=&#34;删除链表中的节点&#34;&gt;删除链表中的节点&lt;/h2&gt;

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。&lt;/p&gt;

&lt;p&gt;现有一个链表 &amp;ndash; head = [4,5,1,9]，它可以表示为: &lt;img src=&#34;https://s2.ax1x.com/2019/10/25/KwtOGq.png&#34; alt=&#34;示例&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例 1:
  输入: head = [4,5,1,9], node = 5
  输出: [4,1,9]
  解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.

示例 2:
  输入: head = [4,5,1,9], node = 1
  输出: [4,5,9]
  解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;

&lt;p&gt;从链表里删除一个节点 node 的最常见方法是修改之前节点的 next 指针，使其指向之后的节点。
&lt;img src=&#34;https://s2.ax1x.com/2019/10/25/KwUinS.png&#34; alt=&#34;pic&#34; /&gt;
因为，我们无法访问我们想要删除的节点 之前 的节点，我们始终不能修改该节点的 next 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。
&lt;img src=&#34;https://s2.ax1x.com/2019/10/25/KwUCX8.png&#34; alt=&#34;pic&#34; /&gt;
因为我们知道要删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
  node.val = node.next.val;
  node.next = node.next.next;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TS重新定义模块</title>
      <link>/2019/ts%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/ts%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</guid>
      <description>&lt;p&gt;重新定义模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;declare var am: any; // 支付宝

declare interface Window {
  ap: any; // 支付宝注入
}

declare module &#39;dva/dynamic&#39; {
  const dynamic: (config: any) =&amp;gt; React.ComponentType;
  export default dynamic;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-反转链表</title>
      <link>/2019/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h2 id=&#34;反转链表&#34;&gt;反转链表&lt;/h2&gt;

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;反转一个单链表。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例:
  输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
  输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;

&lt;p&gt;一、迭代
  - 第一个节点无前置节点 所以需要声明初始化一个前置节点prev
  - 开始迭代，结束提交为 当前节点不为null
  - 先把当前节点后置节点变为当前节点的前置节点
  - 然后把前置pre变为当前节点 因为下一次所需
  - 再把当前节点设为后置节点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let cur = head;
  let pre = null;
  while(cur) {
    let temp = cur.next; //  保存当前节点的后置节点 之后循环到下一个节点需要
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、递归&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？&lt;/li&gt;
&lt;li&gt;假设列表为：&lt;code&gt;n1 ​→ ... → nk−1 ​→ nk ​→ nk+1 ​→...→ nm ​→∅&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若从节点 &lt;code&gt;nk+1&lt;/code&gt;到 &lt;code&gt;nm&lt;/code&gt;已经被反转，而我们正处于 &lt;code&gt;nk&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n 1 ​ →...→n k−1 ​ →n k ​ →n k+1 ​ ←...←n m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们希望 &lt;code&gt;nk+1&lt;/code&gt; 的下一个节点指向 &lt;code&gt;nk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所以:&lt;code&gt;nk.next.next = nk&lt;/code&gt; &lt;em&gt;要小心的是 &lt;code&gt;n1&lt;/code&gt; 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (!head || !head.next) return head;
  let p = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return p;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-设计链表</title>
      <link>/2019/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h3 id=&#34;设计链表&#34;&gt;设计链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。&lt;/p&gt;

&lt;p&gt;在链表类中实现这些功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。&lt;/li&gt;
&lt;li&gt;addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。&lt;/li&gt;
&lt;li&gt;addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。&lt;/li&gt;
&lt;li&gt;addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。&lt;/li&gt;
&lt;li&gt;deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 假设链表为 5 -&amp;gt; 3 &amp;gt; 1
{
  val: 5,
  next: {
    val: 3,
    next: {
      val: 1,
      next: null
    }
  }
}
// 双链表的结构就会多一个prev
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;一-数组-不推荐&#34;&gt;一、数组（不推荐）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyLinkedList {
  constructor() {
    this.list = [];
  }
  get(index) {
    if (index &amp;lt; 0 || index &amp;gt;= this.list.length) return -1;
    return this.list[index];
  }
  addAtHead(val) {
    this.list.unshift(val);
  }
  addAtTail(val) {
    this.arr.push(val)
  }
  addAtIndex(index, val) {
    if (index &amp;lt; 0) { this.arr.push(val); return }
    if (index &amp;gt; this.arr.length) { return }
    this.arr.splice(index, 0, val)
  }
  deleteAtIndex(index) {
    if (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; this.arr.length) this.arr.splice(index, 1)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;二-对象设计单链表&#34;&gt;二、对象设计单链表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyLinkedList {
  constructor() {
    this.data = {};
  }
  get(index) {
    if (index &amp;lt; 0) return -1;
    let current = this.data;
    for (let i = 0; i &amp;lt; index; i++) {
      if (!current.next) return -1;
      current = current.next;
    }
    return current.val === undefined || current.val === null ? -1 : current.val;
  }
  addAtHead(val) {
    if (this.data.val === undefined || this.data.val === null) {
      this.data = {
        val: val,
        next: this.data,
      };
    } else {
      this.data = {
        val: val,
        next: null,
      };
    }
  }
  addAtTail(val) {
    let curr = this.data;
    while(curr.next) {
      curr = curr/next;
    }
    curr.next = {
      val: val,
      next: null,
    };
  }
  addAtIndex(index, val) {
    if (index &amp;lt; 0) return this.addAtHead(val);
    let curr = this.data;
    for (let i = 0; i &amp;lt; index - 1; i++) {
      if (!curr || !curr.next) return null;
      curr = curr.next;
    }
    if (!curr.val &amp;amp;&amp;amp; curr.val !== 0) return null;
    curr.next = {
      val: val,
      next: curr.next,
    };
  }
  deleteAtIndex(index) {
    if (index &amp;lt; 0) return null;
    if (index === 0) return this.data = this.data.next;
    let curr = this.data;
    for (let i = 0; i &amp;lt; index - 1; i++) {
      if (!curr.next || !curr.next.next) return null
      curr = curr.next;
    }
    if (!curr.next) return null;
    if (!curr.next.next) return curr.next = null;
    curr.next = curr.next.next;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;二-对象设计双链表&#34;&gt;二、对象设计双链表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyLinkedList {
  constructor () {
    this.data = null;
  }
  get(index) {
    if (index &amp;lt; 0) return -1;
    let curr = this.data;
    while (index &amp;gt; 0 &amp;amp;&amp;amp; curr) {
      curr = curr.next;
      index--;
    }
    return curr ? curr.val : -1;
  }
  addAtHead(val) {
    this.data = {
      val, next: this.data, prev: null
    }
    if (this.data.next) this.data.next.prev = this.data;
  }
  addAtTail(val) {
    if (this.data) {
      let curr = this.data;
      while (curr.next) {
        curr = curr.next;
      }
      curr.next = { val, next: null, prev: curr}
    } else {
      this.data = { val, next: null, prev: null }
    }
  }
  addAtIndex(index, val) {
    if (index &amp;lt;= 0) return this.addAtHead(val);
    let curr = this.data;
    for (let i = 0; i &amp;lt; index - 1; i++) {
      if (!curr || !curr.next) return null;
      curr = curr.next;
    }
    if (!curr) return null;
    let temp = curr.next;
    curr.next = {
      val, prev: curr, next: curr.next
    }
    if (temp) temp.prev = curr.next
  }
  deleteAtIndex(index) {
    if (index &amp;lt; 0) return null;
    let curr = this.data;
    while (index &amp;gt; 0) {
      if (!curr) return null;
      curr = curr.next;
      index--;
    }
    if (!curr) return null;
    if (!curr.prev &amp;amp;&amp;amp; !curr.next) {
      this.data = null;
    } else if (!curr.prev) {
      curr.next.prev = curr.prev;
      this.data = curr.next;
    } else if (!curr.next) {
      curr.prev.next = null;
    } else {
      curr.prev.next = curr.next;
      curr.next.prev = curr.prev;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker 相关</title>
      <link>/2019/docker/</link>
      <pubDate>Mon, 02 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/docker/</guid>
      <description>

&lt;h1 id=&#34;docker-相关&#34;&gt;Docker 相关&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;服务器环境: ubuntu16&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用apt安装&#34;&gt;使用APT安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get update
sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加软件源的 GRP 密钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# 官方源
# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们需要向 source.list 中添加 Docker 软件源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo add-apt-repository &amp;quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot;

# 官方源
# $ sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要测试或每日构建版本的 Docker CE 请将 stable 改为 test 或者 nightly。&lt;/p&gt;

&lt;h2 id=&#34;安装-docker-ce&#34;&gt;安装 Docker CE&lt;/h2&gt;

&lt;p&gt;更新 apt 软件包缓存，并安装 docker-ce&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get update
sudo apt-get install docker-ce
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用脚本自动安装&#34;&gt;使用脚本自动安装&lt;/h3&gt;

&lt;p&gt;在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -fsSL get.docker.com -o get-docker.sh
sudo sh get-docker.sh --mirror Aliyun
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;启动-docker-ce&#34;&gt;启动 Docker CE&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo systemctl enable docker
sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;建立-docker-用户组&#34;&gt;建立 Docker 用户组&lt;/h3&gt;

&lt;p&gt;默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。&lt;/p&gt;

&lt;p&gt;建立 docker 组：&lt;code&gt;sudo groupadd docker&lt;/code&gt;，将当前用户加入 docker 组：&lt;code&gt;sudo usermod -aG docker $USER&lt;/code&gt;，退出当前终端并重新登录，进行如下测试。&lt;/p&gt;

&lt;h3 id=&#34;测试-docker-是否安装正确&#34;&gt;测试 Docker 是否安装正确&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run hello-world
# Unable to find image &#39;hello-world:latest&#39; locally
#     latest: Pulling from library/hello-world
#     d1725b59e92d: Pull complete
#     Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788
#     Status: Downloaded newer image for hello-world:latest
#     
#     Hello from Docker!
#     This message shows that your installation appears to be working correctly.
#     
#     To generate this message, Docker took the following steps:
#      1. The Docker client contacted the Docker daemon.
#      2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
#         (amd64)
#      3. The Docker daemon created a new container from that image which runs the
#         executable that produces the output you are currently reading.
#      4. The Docker daemon streamed that output to the Docker client, which sent it
#         to your terminal.
#     
#     To try something more ambitious, you can run an Ubuntu container with:
#      $ docker run -it ubuntu bash
#     
#     Share images, automate workflows, and more with a free Docker ID:
#      https://hub.docker.com/
#     
#     For more examples and ideas, visit:
#      https://docs.docker.com/get-started/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若能正常输出以上信息，则说明安装成功。&lt;/p&gt;

&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速&lt;/h3&gt;

&lt;p&gt;如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cr.console.aliyun.com/cn-shanghai/instances/mirrors&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;阿里云镜像加速&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;安装-docker-compose&#34;&gt;安装 docker-compose&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/compose/install/#install-compose&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;运行此命令以下载docker-compose的当前稳定版本&#34;&gt;运行此命令以下载Docker Compose的当前稳定版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;对二进制文件应用可执行权限&#34;&gt;对二进制文件应用可执行权限&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看版本&#34;&gt;查看版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;搜索镜像&#34;&gt;搜索镜像&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker search gitlab-ce
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;查看镜像&#34;&gt;查看镜像&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-两数相加</title>
      <link>/2019/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>

&lt;h3 id=&#34;两数相加&#34;&gt;两数相加&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&lt;/p&gt;

&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
输出：7 -&amp;gt; 0 -&amp;gt; 8
原因：342 + 465 = 807
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;单链表的数据结构：&lt;code&gt;val&lt;/code&gt;属性存储当前的值，&lt;code&gt;next&lt;/code&gt;属性存储下一个节点的引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从链表表头开始，然后进行每一位进行相加，每位的数字在 0~9 之间，相加有可能会出现 &lt;em&gt;溢出&lt;/em&gt; 。
例如：5+7=12，这种情况下，将个位设置为当前值（也就是2），并将进位 carry=1 带入下一次迭代。进位必定是 0 | 1，因为两个数字相加（考虑到进位）最大和为 9+9+1=19。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。&lt;strong&gt;使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;先初始化一个哑结点&lt;/li&gt;
&lt;li&gt;初始化 sum 为 0&lt;/li&gt;
&lt;li&gt;进位 carry 初始化为 0&lt;/li&gt;
&lt;li&gt;遍历列表 l1 和 l2 直至到达它们的尾端，并对 sum 进行累加，将 l1 和 l2 赋值为下一个节点&lt;/li&gt;
&lt;li&gt;更新进位的值，carry = ~~(sum / 10carry=sum/10)&lt;/li&gt;
&lt;li&gt;创建一个数值为 (sum % 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点&lt;/li&gt;
&lt;li&gt;sum 赋值为 进位 carry，带入下一次循环&lt;/li&gt;
&lt;li&gt;将 carry 从初始化&lt;/li&gt;
&lt;li&gt;返回哑结点的下一个结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  let res = new ListNode(0)
      dummy = res,
      sum = 0, carry = 0;
  while(l1 || l2 || sum &amp;gt; 0) {
      if(l1) {
          sum += l1.val;
          l1 = l1.next;
      }
      if(l2) {
          sum += l2.val;
          l2 = l2.next;
      }
      carry = ~~(sum / 10);
      dummy.next = new ListNode(sum % 10)
      dummy = dummy.next;
      sum = carry;
      carry = 0;
  }
  return res.next;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-合并两个有序链表</title>
      <link>/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;由于单链表是线性的，使用递归方式将导致栈的使用也是线性的，当链表长度达到一定程度时，递归会导致爆栈，因此，现实中并不推荐使用递归方式来操作链表。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;合并两个有序链表&#34;&gt;合并两个有序链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;一、 递归&lt;/p&gt;

&lt;p&gt;可以使用 递归，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;思路&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素&lt;/li&gt;
&lt;li&gt;终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束&lt;/li&gt;
&lt;li&gt;返回值：每一层调用都返回排序好的链表头&lt;/li&gt;
&lt;li&gt;本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理&lt;/li&gt;
&lt;li&gt;O(m+n)O(m+n)，mm 为 l1的长度，nn 为 l2 的长度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if(l1 === null){
      return l2;
  }
  if(l2 === null){
      return l1;
  }
  if(l1.val &amp;lt; l2.val){
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
  }else{
      l2.next = mergeTwoLists(l1, l2.next);
      return l2;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、迭代&lt;/p&gt;

&lt;p&gt;可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;思路:

&lt;ul&gt;
&lt;li&gt;首先，我们设定一个哨兵节点 &lt;code&gt;preheat&lt;/code&gt; ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。&lt;/li&gt;
&lt;li&gt;在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  // 在返回节点之前保持对节点的不变引用
  const preheat = new ListNode(-1);
  let prev = preheat;

  while (l1 &amp;amp;&amp;amp; l2) {
    if (l1.val &amp;lt; l2.val) {
      prev.next = l1;
      l1 = l1.next;
    } else {
      prev.next = l2;
      l2 = l2.next;
    }
    prev = prev.next;
  }
  // 此时l1和l2中恰好有一个是非空的，将非空链表接在合并链表的后面
  prev.next = l1 ? l1 : l2;
  return preheat.next;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-回文链表</title>
      <link>/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h2 id=&#34;回文链表&#34;&gt;回文链表&lt;/h2&gt;

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;判断一个链表是否为回文链表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例 1:
  输入: 1-&amp;gt;2
  输出: false

示例 2:
  输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
  输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用2个指针，一个low，一个fast，fast是low的2倍，所以可以达到2分链表的效果&lt;/li&gt;
&lt;li&gt;在移动指针时同时对前半部分链表进行反转，最后直接比较被分开的2个链表&lt;/li&gt;
&lt;li&gt;因为不能改变当前slow的next，不然就无法跳到下一个元素，所以这里用pre和prepre实现指针的反转&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  if (!head || !head.next) return true;
  let slow = head;
  let fast = head.next;
  let pre = null;
  let prepre = null;
  while (fast &amp;amp;&amp;amp; fast.next) {
    // 反转前半段链表
    pre = slow;
    slow = slow.next;
    fast = fast.next.next;
    // 先移动指针再来反转
    pre.next = prepre;
    prepre = pre;
  }
  let p2 = slow.next;
  slow.next = pre;
  let p1 = !fast ? slow.next : slow;
  while(p1) {
    if (p1.val !== p2.val) return false;
    p1 = p1.next;
    p2 = p2.next;
  }
  return true;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>你真的了解webview么？</title>
      <link>/2019/webview/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/webview/</guid>
      <description>

&lt;p&gt;&lt;em&gt;文章转载自微信公众号 &lt;strong&gt;大转转FE&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;适用场景&#34;&gt;适用场景&lt;/h2&gt;

&lt;p&gt;像一些 App 的内嵌页面，提供各种各样的交互操作，其实webview的应用场景远远不止这些，其实在一些PC的软件里，和我们交互的也是我们的html页面，只是穿着webview的衣服，衣服太美而我们没有发现他们的真谛。&lt;/p&gt;

&lt;p&gt;另外，还有一些网络机顶盒里的交互，也是webview在和我们打交道，比如一些早期的IPTV里的EPG都是运行在webview里的，它们基于webkit内核，尽管我们使用的交互方式是遥控器。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;与app-native的交互&#34;&gt;与App native的交互&lt;/h2&gt;

&lt;p&gt;目前使用频率最多的，还是客户端内嵌的webview，都是webview打开m页去承接的。目前javascript和客户端（后面统称native）交互的常见方式有两种，一种是通过JSBridge的方式，另一种是通过schema的方式。&lt;/p&gt;

&lt;h3 id=&#34;jsbridge&#34;&gt;JSBridge&lt;/h3&gt;

&lt;p&gt;体现的形式其实就是，当我们在native内打开m页，native会在全局的window下，为我们注入一个Bridge。这个Bridge里面，会包含我们与native交互的各种方法、比如判断第三方App是否安装、获取网络信息等等功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 作用域下的JSBridge，
 * 和实例化后的getNetInfomation，
 * 均根据实际约定情况而定，
 * 这里只是用来举例说明
 */
const bridge = window.JSBridge;
console.log(bridge.getNetInfomation());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;IOS端: 在IOS中，主要使用&lt;code&gt;WebViewJavascriptBridge&lt;/code&gt;来注册，可以参考&lt;em&gt;Github WebViewJavascriptBridge&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];

[self.bridge registerHandler:@&amp;quot;ObjC Echo&amp;quot; handler:^(id data, WVJBResponseCallback responseCallback) {
	// to do...
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Android: 在Android中，需要通过addJavascriptInterface来注册&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class JSBridge {
    @JavascriptInterface //注意这里的注解。出于安全的考虑，4.2 之后强制要求，不然无法从 Javascript 中发起调用
    public void getNetInfomation(){
      // to do
    };
}
webView.addJavascriptInterface(new JSBridge();, &amp;quot;JSBridge&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;schema-url&#34;&gt;Schema url&lt;/h3&gt;

&lt;p&gt;如果说Bridge的方式是只能在native内部交互，那么&lt;code&gt;schame url&lt;/code&gt;的不紧可以在native内交互，也是可以跨app来交互的。&lt;code&gt;schema&lt;/code&gt;也是目前我们转转使用的主要方式，它类似一个伪协议的链接（也可以叫做统跳协议），比如：&lt;strong&gt;schema://path?param=abc&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在webview里，当m页发起schema请求时，native端会去进行捕获。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IOS端: 以UIWebView为例，在IOS中，UIWebView内发起网络请求时，可以通过delegate在native层来拦截，然后将捕获的schema进行触发对应的功能或业务逻辑（利用shouldStartLoadWithRequest）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType {
  // 获取scheme url后自行进行处理
  NSURL *url = [request URL];
  NSString *requestString = [[request URL] absoluteString];
  return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Android端: 在Android中，可以使用shouldoverrideurlloading来捕获schema url&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean shouldOverrideUrlLoading(WebView view, String url){
  //读取到url后自行进行分析处理

  //这里注意：如果返回false，则WebView处理链接url，如果返回true，代表WebView根据程序来执行url  
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;如何通过schema的方式可以进行跨端交互&#34;&gt;如何通过schema的方式可以进行跨端交互？&lt;/h2&gt;

&lt;p&gt;其实对于JavaScript，在webview里基本是一样的，也是发起一个schema的请求，只不过在native侧会有些许变化。&lt;/p&gt;

&lt;p&gt;首先，给大家普及一个小知识，就是在natvie中（包括IOS和Android），会通过schema找到相匹配的App。其中IOS不可以重复，就像appId一样；安卓可以重复，遇到重复情况时，会弹窗让用户选择其中之一。&lt;/p&gt;

&lt;p&gt;那么，有了这个知识点做铺垫，就可以理解，当我们在其他app中，像这个schema发起请求时，系统底层（IOS &amp;amp; Android）会通过schema去找到所匹配的app，然后将此App拉起。拉起app后，对应处理如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IOS端: 在IOS端内，会将schema作为参数传入一个提前定义好的回调函数内，然后执行该回调函数。此回调函数，可以通过得到的schema去进行解析，然后定向到app内的固定的某个页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString*)sourceApplication annotation:(id)annotation
  // 参数 url 即为获取的 schema
      
  // to do
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Android端: 在Android端内，会稍微麻烦一些，在外部的m页，会发起一个schema的伪协议链接，系统会去根据这个schema去检索，需要被拉起的App需要有一个配置文件，大致如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;activity
  android:name=&amp;quot;.activity.StartActivity&amp;quot;
  android:exported=&amp;quot;true&amp;quot;
&amp;gt;
&amp;lt;intent-filter&amp;gt;
    &amp;lt;action android:name=&amp;quot;android.intent.action.VIEW&amp;quot;/&amp;gt;
    &amp;lt;category android:name=&amp;quot;android.intent.category.DEFAULT&amp;quot;/&amp;gt;   
    &amp;lt;category android:name=&amp;quot;android.intent.category.BROWSABLE&amp;quot;/&amp;gt;        
    &amp;lt;data android:scheme=&amp;quot;zhuanzhuan&amp;quot;/&amp;gt; 
  &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activityandroid:name=&amp;quot;.activity.StartActivity&amp;quot;android:exported=&amp;quot;true&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上面的代码为例，在上面配置中scheme为zhuanzhuan，只要是 &amp;ldquo;zhuanzhuan://&amp;rdquo; 开头的schema的链接都会调起配置该schema的Activity(类似上面代码的 StartActivity)，此Activity会对这个 schema url 做处理，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StartActivity extends TempBaseActivity {

  Intent intent;
    
  @Override
  protected void onCreate(BundlesavedInstanceState) {       
    super.onCreate(savedInstanceState);
    intent = getIntent();      
    Uri uri = intent.getData();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如上面的代码，可以在此Activity中，通过 intent 中的 getData 方法，获取到传入的schema的相关信息，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/27374e51955cc775.jpg&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以在第三方app内，可以调起app的原理。当然现在市场上一些app，为了怕有流量流失，会对schema进行限制，只有plist白名单里的schema才能对应拉起，否则会被直接过滤掉。比如我们的wx爸爸，开通白名单后，才可以使用更多的jsApiList，通过schema的拉起就是其中之一，在此不做赘述…… :）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;webview的进化&#34;&gt;webview的进化&lt;/h2&gt;

&lt;p&gt;对于webview，要说进化、或者蜕变，让我第一想到的就是IOS的WKWebView了，每一个事物存在都有它的必然，让我们一起看看这个super版的webview。&lt;/p&gt;

&lt;h3 id=&#34;wkwebview的出现&#34;&gt;WKWebView的出现&lt;/h3&gt;

&lt;p&gt;目前混合开发已然成为了主流，为了提高体验，WKWebView在IOS8发布时，也随之一起诞生。在这之前IOS端一直使用的是UIWebView。&lt;/p&gt;

&lt;p&gt;从性能方面来说，WKWebView会比UIWebView高很多，可以算是一次飞跃。它采用了跨进程的方案，用 Nitro JS 解析器，高达 60fps 的刷新率。同时，提供了很好的H5页面支持，类比UIWebView还多提供了一个加载进度的属性。目前一些一线互联网app在IOS已经切换到了WKWebView，所以感觉我们无法拒绝。&lt;/p&gt;

&lt;p&gt;整个WKWebView的初始化也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;WKWebView *webView = [[WKWebView alloc] init];
NSURL *url = [NSURL URLWithString:@&amp;quot;https://m.zhuanzhuan.com&amp;quot;];
[webView loadRequest:[NSURLRequest requestWithURL:url]];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wkwebview-与-uiwebview的对比&#34;&gt;WKWebView 与 UIWebView的对比&lt;/h3&gt;

&lt;p&gt;上面有提到性能的提升，为什么 app 接入 WKWebView 之后，相对比 UIWebView 内存占用小那么多，主要是因为网页的载入和渲染这些耗内存和性能的过程都是由 WKWebView 进程去实现的（WKWebView是独立于app的进程）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/b6c28e21432a222c.jpeg&#34; alt=&#34;WKWebView&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样，互相进程独立相当于把整个App的进程对内存的占用量减少，App进程会更为稳定。况且，即使页面进程崩溃，体现出来的就是页面白屏或载入失败，不会影响到整个App进程的崩溃。&lt;/p&gt;

&lt;p&gt;除了上面说的性能以外，WKWebView会比UIWebView多了一个询问过程。在服务器完成响应之后，会询问获取内容是否载入到容器内，在控制上会比UIWebView更细粒度一点，也可以在一些通信上更好的和m页进行交互。大概流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/f019036d9012a991.jpeg&#34; alt=&#34;stream&#34; /&gt;&lt;/p&gt;

&lt;p&gt;WKWebView 的代理协议为 WKNavigationDelegate，对比 UIWebDelegate 首先跳转询问，就是载入 URL之前的一次调用，询问开发者是否下载并载入当前 URL，UIWebView 只有一次询问，就是请求之前的询问，而 WKWebView 在 URL 下载完毕之后还会发一次询问，让开发者根据服务器返回的 Web 内容再次做一次确定。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;任重而道远&#34;&gt;任重而道远&lt;/h2&gt;

&lt;p&gt;前面说到WKWebView这么赞，其实开发中也有一些痛点。不同于UIWebView，WKWebView很多交互都是异步的，所以在很大程度上，在和m页通信的时候，提高了开发成本。&lt;/p&gt;

&lt;h3 id=&#34;cookie&#34;&gt;cookie&lt;/h3&gt;

&lt;p&gt;首先就是cookie问题，这个目前我认为也是WKWebView在业界的一个坑。之前出现过一个问题，就是在IOS登陆完成后，马上进入m页，会有登录态的cookie获取不到的问题。这个问题在UIWebView中是不存在的。&lt;/p&gt;

&lt;p&gt;经过调研发现，主要问题是UIWebView对cookie是通过NSHTTPCookieStorage来统一处理的，服务端响应时写入，然后在下次请求时，在请求头里会带上相应的cookie，来做到m页和native共享cookie的值。&lt;/p&gt;

&lt;p&gt;但是在WKWebView中，则不然。它虽然也会对NSHTTPCookieStorage来写入cookie，但却不是实时存储的。而且从实际的测试中发现，不同的IOS版本，延迟的时间还不一样，无意对m页的开发者是一种挑战。同样，发起请求时，也不是实时读取，无法做到和native同步，导致页面逻辑出错。&lt;/p&gt;

&lt;p&gt;针对这个问题，目前我们转转的解决方法是需要客户端手动干预一下cookie的存储。将服务响应的cookie，持久化到本地，在下次webview启动时，读取本地的cookie值，手动再去通过native往webview写入。大致流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ftp.bmp.ovh/imgs/2019/08/f06684b50c93ab95.jpeg&#34; alt=&#34;stream&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然这也不是很完美的解决方案，因为偶尔还有spa的页面路由切换的时候丢失cookie的问题。&lt;/p&gt;

&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;

&lt;p&gt;除了cookie以外，WKWebView的缓存问题，最近我们也在关注。由于WKWebView内部默认使用一套缓存机制，开发者可以操作的权限会有限制，特别是IOS8版本，也许是当时刚诞生WKWebView的缘故，还很不完善，根本没法操作（当然相信IOS8很快会退出历史舞台）。对于一些m页的静态资源，偶尔会出现缓存不更新的情况，着实让人头疼。&lt;/p&gt;

&lt;p&gt;但在IOS 9 之后，系统提供了缓存管理的接口 WKWebsiteDataStore。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// RemoveCache
NSSet *websiteTypes= [NSSet setWithArray:@[WKWebsiteDataTypeDiskCache, WKWebsiteDataTypeMemoryCache]];
NSDate *date = [NSDate dateWithTimeIntervalSince1970:0];
[[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteTypes modifiedSince:date completionHandler:^{}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于IOS8，就只能通过删除文件来解决了，一般WKWebView的缓存数据会存储在这个目录里：&lt;code&gt;~/Library/Caches/BundleID/WebKit/&lt;/code&gt;，可通过删除该目录来实现清理缓存。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;还有webview的通病，就是我们每次首次打开m页时，都要有webview初始化的过程，那么如何减少初始化webview的时间，也是我们可以提高页面打开速度的一个重要环节&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-相交链表</title>
      <link>/2019/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h3 id=&#34;相交链表&#34;&gt;相交链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/09/27/uMQiZ9.png&#34; alt=&#34;pic&#34; /&gt;
&lt;img src=&#34;https://s2.ax1x.com/2019/09/27/uMQFaR.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意：
- 如果两个链表没有交点，返回 null.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。&lt;/p&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;p&gt;根据题目意思&lt;/p&gt;

&lt;p&gt;如果两个链表相交，那么相交点之后的长度是相同的&lt;/p&gt;

&lt;p&gt;我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。
为此，我们必须消除两个链表的长度差&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历&lt;/li&gt;
&lt;li&gt;如果 pA 到了末尾，则 pA = headB 继续遍历&lt;/li&gt;
&lt;li&gt;如果 pB 到了末尾，则 pB = headA 继续遍历&lt;/li&gt;
&lt;li&gt;比较长的链表指针指向较短链表head时，长度差就消除了&lt;/li&gt;
&lt;li&gt;如此，只需要将最短链表遍历两次即可找到位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/images/totalimgs/xtjd.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var getIntersectionNode = function(headA, headB) {
  if (headA === null || headB === null) return null;
  let pA = headA;
  let pB = headB;
  while(pA !== pB) {
    pA = (pA === null) ? headB : pA.next;
    pB = (pB === null) ? headA : pB.next;
  }
  return pA;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-环形链表</title>
      <link>/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>

&lt;h3 id=&#34;环形链表&#34;&gt;环形链表&lt;/h3&gt;

&lt;h4 id=&#34;描述&#34;&gt;描述&lt;/h4&gt;

&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;

&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 -1，则在该链表中没有环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png&#34; alt=&#34;pic&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;一、由上到下给每一层遍历到的结点做上标记，如果在下一个结点中出现了这个标记，则表示存在环形结构。如果不想篡改原始数据，可以先用 &lt;code&gt;temp&lt;/code&gt; 保存。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  while (head) {
    if (head.val === &#39;k.top&#39;) return true;
    head.val = &#39;k.top&#39;;
    head = head.next;
  }
  return false;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;二、利用 &lt;code&gt;JSON.stringify()&lt;/code&gt; 不能字符串化含有循环引用的结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  try {
    JSON.stringify(head);
    return false;
  } catch (e) {
    return true;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;三、*(双指针法）*设置一快一慢两个指针，快指针一次走两步到 .next.next，慢指针一次走一步到 .next，如果链表不存在环形结构，那么快指针和慢指针不会相遇。如果存在环形结构，快指针总会和慢指针相遇。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null || head.next === null) return false;
  let slow = head;
  let fast = head.next;
  while (slow !== fast) {
    if (fast === null || fast.next === null) return false;
    slow = slow.next;
    fast = fast.next;
  }
  return true;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表-leetCode-移除链表元素</title>
      <link>/2019/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</guid>
      <description>

&lt;h3 id=&#34;移除链表元素&#34;&gt;移除链表元素&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;删除链表中等于给定值 val 的所有节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;示例:
输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6
输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
  let tem = head;
  let pre = null;
  while (tem) {
    if (tem.val === val) {
      if (pre) {
        pre.next = tem.next;
      } else {
        head = tem.next;
      }
    } else {
      pre = tem;
    }
    tem = tem.next;
  }
  return head;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var removeElements = function(head, val) {
  if (!head) return null;
  if (head.val === val) return removeElements(head.next, val);
  head.next = removeElements(head.next, val);
  return head;
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>pm2</title>
      <link>/2019/pm2/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/pm2/</guid>
      <description>

&lt;h3 id=&#34;pm2-的安装提示处理&#34;&gt;PM2 的安装提示处理&lt;/h3&gt;

&lt;p&gt;在本地安装 PM2 之后，可能会看到下面的这个提示，可以按照提示操作一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Since PM2’s deployment command runs on a non-interactive SSH connection, we need to resolve this by commenting out a few lines from the semaphoreci user’s ~/.bashrc file. We’re already logged in as this user on our droplet, so we simply need to open up this file and comment this out:


Comment the following lines:

#If not running interactively, don&#39;t do anything
#case $- in
#    *i*) ;;
#      * return;;
#esac

and this in /etc/bash.bashrc

# If not running interactively, don&#39;t do anything
[ -z &amp;quot;$PS1&amp;quot; ] &amp;amp;&amp;amp; return
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;尝试-pm2-启动服务&#34;&gt;尝试 PM2 启动服务&lt;/h3&gt;

&lt;p&gt;如果一个网站的服务，必须通过命令行 node server.js 来启动，启动后，退出命令行服务就终止，这显然不符合我们的预期。而即便是服务能持续运行，一旦遇到异常情况服务即终止，也是不理想的，这时候就需要有一种能够守护进程的工具或者服务，来把已经挂起的服务再次重启，这就是服务常驻的基本需求了。对于 Node.js 来说，有很多工具可以帮我们做到这一点，PM2 就是其中一个，之前我们写了这样一个静态站点代码 - app.js：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)

const homePage = `
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
      &amp;lt;title&amp;gt;Node.js 部署上线示例&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;h1&amp;gt;慕课网 Node.js 部署发布&amp;lt;/h1&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
`

http.createServer((req, res) =&amp;gt; {
  res.statusCode = 200
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)
  res.end(homePage)
}).listen(4321, () =&amp;gt; {
  console.log(&#39;Server running at 4321&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要把一个静态站点开起来，需要满足 2 个条件:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，这个站点可以持续稳定地提供服务；&lt;/li&gt;
&lt;li&gt;第二，这个站点可以从外网直接访问到，比如通过域名访问到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，我们的端口是跑在 4321 的，这显然不满足第二个条件，我们需要从外网通过 80 端口来访问。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们先解决第一个问题：让服务可以持续稳定地运行。（第二个问题留到下一个节来解决。）通过 node app.js 启动服务文件，服务就跑起来了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node app&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们通过浏览器来访问，就可以看到 Node.js 服务返回的页面内容了，但是一旦退出命令行，这个会话状态就会中断，随之 Node.js 服务也会终止。显然这不是我们想要的状态，我们希望服务不仅可以在后台运行，而且在出现异常的时候还可以自动重启。这时我们就可以用到 PM2 这个 Node.js 部署和进程管理工具，不作过多解释，直接来用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不加任何参数的话，PM2 会自动初始化一些基础参数，来把服务跑起来。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pm2 start app.js&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;补充-pm2-常用命令&#34;&gt;补充：PM2 常用命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过 PM2 跑服务器的时候，是可以进行集群配置的，也就是指定在几个核上运行几个进程：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pm2 start app.js -i 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i 后面跟的 2 表示启动 2 个 server 实例，如果输入 0 的话，则按照当前服务器实际的 CPU 核数来启动多个 server，启动后，我们通过 pm2 ls 来看看已经启动的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;~ pm2 ls
┌────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│Name│id│mode│status │↺     │cpu│memory│       │
├────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online│0  │19%   │28.4 MB│
│app │1 │N/A │cluster│online│0  │0%    │20.3 MB│
└────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pm2-实时扩容集群&#34;&gt;PM2 实时扩容集群&lt;/h4&gt;

&lt;p&gt;如果发现线上的服务响应比较吃力，而 CPU 核数没有吃满的话，我们可以实时扩容集群，通过 scale 命令来实现，比如：&lt;code&gt;pm2 scale app +1&lt;/code&gt;，这里的 +1 就是扩容一个服务实例，其实就是增加一个 cluster 的 worker 子进程，扩容后的应用效果如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[PM2] Scaling up application
┌─────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│ Name│id│mode│status │↺     │cpu│memory│       │
├─────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│ app │0 │N/A │cluster│online│0  │0%    │33.6 MB│
│ app │1 │N/A │cluster│online│0  │0%    │34.2 MB│
│ app │2 │N/A │cluster│online│0  │0%    │19.9 MB│
└─────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pm2-终止某个进程&#34;&gt;PM2 终止某个进程&lt;/h4&gt;

&lt;p&gt;有时候如果某个进程明显卡住了，或者线上负载不大，可以杀掉部分进程，通过：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;e12-cluster git:(master) ✗ pm2 stop 1
[PM2] Applying action stopProcessId on app [1](ids: 1)
[PM2] [app](1) ✓
┌────┬──┬────┬───────┬───────┬───┬──────┬───────┐
│Name│id│mode│status │↺      │cpu│memory│       │
├────┼──┼────┼───────┼───────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online │0  │0%    │33.6 MB│
│app │1 │N/A │cluster│stopped│0  │0%    │0 B    │
│app │2 │N/A │cluster│online │0  │0%    │33.6 MB│
└────┴──┴────┴───────┴───────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到进程 ID 为 1 的 worker 已经是 stopped 状态。&lt;/p&gt;

&lt;h4 id=&#34;pm2-平滑重启进程&#34;&gt;PM2 平滑重启进程&lt;/h4&gt;

&lt;p&gt;有时候，如果想要某个比较吃内存的进程可以重启，或者想要所有的 worker 都重启，但是又不希望影响进程正常处理用户的请求，可以使用 PM2 的 gracefulReload 命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜ pm2 reload app
Use --update-env to update environment variables
[PM2] Applying action reloadProcessId on app [app](ids: 0,1,2)
[PM2] [app](1) ✓
[PM2] [app](0) ✓
[PM2] [app](2) ✓
➜ pm2 ls
┌────┬──┬────┬───────┬──────┬───┬──────┬───────┐
│Name│id│mode│status │↺     │cpu│memory│       │ 
├────┼──┼────┼───────┼──────┼───┼──────┼───────┤
│app │0 │N/A │cluster│online│1  │6.8%  │37.4 MB│
│app │1 │N/A │cluster│online│0  │6.8%  │37.4 MB│
│app │2 │N/A │cluster│online│1  │6.4%  │37.5 MB│
└────┴──┴────┴───────┴──────┴───┴──────┴───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样所有的子进程又原地满血复活了，当然也存在这种情况，即某些进程上的未处理连接或任务的确很重，比如有一些大而重的文件 IO 或者数据库 IO 在等待，会导致 reload 失败。这时候可以指定一个超时时间，命令会退化到 restart 模式，强制杀死进程再重启；或者我们可以在代码中再友好一些，当它收到 PM2 要重启的时候，在程序里把一些任务清空然后让服务重启：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// PM2 会发出 SIGINT 事件，我们监听事件
process.on(&#39;SIGINT&#39;, function() {
  // 处理一些任务然后信号交还给 PM2 来重启服务
  db.stop(function(err) {
    process.exit(err ? 1 : 0)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pm2.io/doc/en/runtime/overview/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PM2 的文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Unitech/pm2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PM2 的仓库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置-pm2-一健部署项目目录&#34;&gt;配置 pm2 一健部署项目目录&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以先在本地仓库加一份 PM2 的部署文件 &lt;code&gt;ecosystem.yaml&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apps:
  - script: index.js
    name: NodeDeployStatic
    env:
      COMMON_VARIABLE: true
    env_production:
      NODE_ENV: production
deploy:
  production:
    user: rn_manager
    host:
      - 116.62.201.97
    port: &#39;39999&#39;
    ref: origin/master
    repo: git@git.dev.tencent.com:s_auto/muke.git
    # 服务器上项目部署的目录，会在/www/node-deploy-static下初始化一个production文件夹
    # 配置文件会自动从git上面拉取静态网站代码到此路径
    path: /www/node-deploy-static/production
    
    ssh_options: StrictHostKeyChecking=no
    pre-deploy: git fetch --all
    post-deploy: &#39;npm i &amp;amp;&amp;amp; pm2 startOrRestart ecosystem.yaml --env production&#39;
    env:
      NODE_ENV: production
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;运行：&lt;code&gt;pm2 deploy ./ecosystem.yaml production setup&lt;/code&gt;，*注：有可能会报：Permission denied（权限不足），可以到服务器上使用 &lt;code&gt;sudo chmod 777 /www/&lt;/code&gt; 这个命令对用户的权限为可读、可写、可执行（远程）*，输出内容如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;--&amp;gt; Deploying to production environment
--&amp;gt; on host 116.62.201.97
  ○ hook pre-setup
  ○ running setup
  ○ cloning git@git.dev.tencent.com:s_auto/muke.git
  ○ full fetch
Cloning into &#39;/www/node-deploy-static/production/source&#39;...
  ○ hook post-setup
  ○ setup complete
--&amp;gt; Success
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当前的服务所运行的文件夹，source 是 clone 下来的源码，shared 里面是日志文件和 pid 之类，其中 current 是 source 的软连接，两者是一样的代码，然后通过 &lt;code&gt;sudo chown -R $USER:$USER /www&lt;/code&gt; 可以让权限被当前用户访问，或者更暴力一点：&lt;code&gt;sudo chmod 755 /www/node-deploy-vue&lt;/code&gt;。等到服务器的文件夹都安置后，就可以从本地利用 PM2 往服务器进行部署了。&lt;/p&gt;

&lt;h3 id=&#34;从本地发布上线和更服务器的部署项目&#34;&gt;从本地发布上线和更服务器的部署项目&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;本地目录下输入命令：&lt;code&gt;pm2 deploy ecosystem.yaml production&lt;/code&gt; 更新和运行，&lt;em&gt;注：使用nvm安装的node和pm2 会报 &lt;code&gt;bash: pm2: command not found / post-deploy hook failed / Deploy failed&lt;/code&gt;，网上搜出来说是没有进行加 软链接&amp;ndash;待定&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
