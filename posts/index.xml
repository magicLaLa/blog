<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Magic</title>
    <link>/posts/</link>
    <description>Recent content in Posts on Magic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 02 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>pm2</title>
      <link>/2019/pm2/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/pm2/</guid>
      <description>PM2 的安装提示处理 在本地安装 PM2 之后，可能会看到下面的这个提示，可以按照提示操作一下：
Since PM2’s deployment command runs on a non-interactive SSH connection, we need to resolve this by commenting out a few lines from the semaphoreci user’s ~/.bashrc file. We’re already logged in as this user on our droplet, so we simply need to open up this file and comment this out: Comment the following lines: #If not running interactively, don&#39;t do anything #case $- in # *i*) ;; # * return;; #esac and this in /etc/bash.</description>
    </item>
    
    <item>
      <title>安装与配置MongoDB数据库</title>
      <link>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>服务器系统为 Ubuntu 14.04
 mongodump 逻辑备份工具。 mongorestore 逻辑恢复工具。 mongoexport 数据导出工具。 mongoimport 数据导入工具。  可以使用 Navicat for MongoDB 来管理数据库
安装 MongoDB 并开启等命令  MongoDB社区安装   加入公钥 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 使用后面这个命令：sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10 为 MongoDB 创建一个列表文件，可以选择使用 Aliyun 的镜像文件 echo &amp;quot;deb [ arch=amd64 ] http://mirrors.aliyun.com/MongoDB/apt/ubuntu trusty/MongoDB-org/4.0 multiverse&amp;quot; | sudo tee /etc/apt/sources.list.d/MongoDB-org-4.0.list echo &#39;deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen&#39; | sudo tee /etc/apt/sources.list.d/mongodb.list 重新加载更新本地的包库 sudo apt-get update 安装 MongoDB 稳定版 sudo apt-get install -y MongoDB-org   在安装的时候有可能会遇到这个问题：定位不到本地的 MongoDB-org 的安装包，可能是因为我们使用的是阿里云的服务器，所以默认的是阿里云的源。可以先把阿里云的源屏蔽掉试一下:</description>
    </item>
    
    <item>
      <title>搭建 Node.js 与阿里云 Alinode 环境</title>
      <link>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</guid>
      <description>搭建 Node.js 环境 系统更新，安装基础包 sudo apt-get update sudo apt-get install vim openssl build-essential libssl-dev wget curl git  安装 node.js  使用 nvm 这个工具，方便升级和管理 node.js 版本 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 安装 node.js  nvm install v10.14.2 nvm use v10.14.2 nvm alias default v10.14.2 node -v v10.14.2  安装 阿里云的 alinode  或者可以直接安装阿里云的 alinode，这也是我推荐给大家的 Node，因为它对 Node 做了必要的定制，可以无缝接入到 alinode 的监控中心，对于 多机器多应用运维 非常有用。大家可以参考 alinode 安装文档  安装一些常用的全局工具包  可以配置一个简单的 registry 参数来指定使用国内的 taobao 镜像来下载： npm --registry=https://registry.</description>
    </item>
    
    <item>
      <title>配置Nginx反向代理Node.js端口</title>
      <link>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</guid>
      <description>安装 sudo apt-get install nginx sudo vi /etc/nginx/sites-available/default   安装完毕后，检查下 Nginx 的版本：nginx -v。这个版本号通常可以在 Web 端的 header 里看到。安全起见，可以通过配置隐藏掉，如下打开 nginx.conf 文件：sudo vi /etc/nginx/nginx.conf，把nginx.conf 文件中的server_tokens on 改成 server_tokens off。  配置 Nginx 反向代理 Node.js 端口  我们的网站静态服务是跑在 4321 端口上的，直接通过 80 端口无法启动，原因是我们 rn_manager 下的 Node 并不具备 root 的运行权限，不能监听 0 ~ 1024 之间的端口，当然也包括 80 端口。通过 sudo 来强制启动 Node 服务也不是不可以，但是，这多少会带来一些额外的成本和风险：一是我们需要额外配置，二是需要放大 Node 程序的权限。
  用 ip 访问，使用 nginx，用 root 级的权限来启动对 80 端口的监听，同时把来自 80 端口的流量分配给 Node 服务的另外一个端口，实现这种服务的代理。   如果服务器只需放一个网站程序，那么解析网站到服务器网址，网站程序监听 80 端口即可。如果服务器有多个应用（你有多个网站），借助 Nginx 不仅可以实现端口代理，还可以实现负载均衡，由它来判断是来自哪个域名或 IP 的访问，从而根据配置的规则，将这个请求原封不动地转发给特定的端口或特定的某几台机器。在我们的这个案例中，就是把 80 端口的 IP 请求都转发到 Node.</description>
    </item>
    
    <item>
      <title>阿里云服务器相关</title>
      <link>/2019/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/</guid>
      <description>根据 慕课网 专栏 ‘一条龙的 Node·Vue·React 服务器部署’ 笔记。
购买  到阿里云官网购买一个服务器 配置相关信息 记录登录名 root 和 登录密码  使用 登录  通过 ssh 登录 例如：ssh root@116.62.201.97 后面会要求输入密码 可以通过 sudo lsb_release -a 来查看服务器版本 登录成功后可以首先运行 sudo apt-get update，作用是先把服务器上所有的包和源都 check 和更新一遍，让服务器处在一个崭新的状态 可以把一些常用的开发者套件先安装上 sudo apt-get install -y software-properties-common  添加一个用户  增加一个用户 adduser rn_manager，完成后记录住密码，赋予账号更高权限:可以在 visudo 权限配置文件配置一下:sudo visudo，加入 rn_manager ALL=(ALL:ALL) ALL 这行，然后可以重启 ssh 服务：service ssh restart  配置无密码登录 那么，首先来本地电脑上配置这把钥匙，而且要生成两把钥匙，分别是 私钥 和 公钥
 提示：如果你之前用过 GitHub 或者 GitLab 之类基于 Git 的仓库管理系统，那么你本地应该是配置过这个公钥和私钥的，这里要切记，不用再重复配置一遍了！不用重新配置一遍了！ 可能你会覆盖掉你本地用的钥匙，这样的话，你可能就连不上你之前有权限的 Git 仓库了，我会演示这一步。</description>
    </item>
    
    <item>
      <title>css3 适配iphoneX 安全区域</title>
      <link>/2019/%E9%80%82%E9%85%8Diphonex/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%80%82%E9%85%8Diphonex/</guid>
      <description>iphoneX 适配 第一步：设置网页在可视窗口的布局方式  ios11 引入 meta 标签的 viewpoint 扩展属性 viewpoint-fit，在 iOS 11 中 viewpoint-fit 也官方添加到 CSS Round Display 规范中了。 viewport-fit 有三个属性值：  Auto：默认值。这个值不影响初始布局视窗，整个 Web 页面是可视的。 Contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形。 Cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形。   所以我们可以通过 viewpoint-fit=cover 来解决问题，使页面内容跳出安全区域的框框。
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0,user-scalable=0,viewport-fit=cover&amp;quot;&amp;gt;  第二步：页面主体内容限定在安全区域内  IOS11 提供了两个个新的 css 变量 env(safe-area-inset-※) 和 constant(safe-area-inset-※) safe-area-inset-※ 提供了四个方向的值：
 safe-area-inset-top：在 Viewport 顶部的安全区域内设置量； safe-area-inset-bottom：在 Viewport 底部的安全区域内设置量； safe-area-inset-left：在 Viewport 左边的安全区域内设置量； safe-area-inset-right：在 Viewport 右边的安全区域内设置量；  constant() 和 env() 这个变量已经开始着手标准化，目前也可以被用在 margin、padding、top、bottom、left、right 等 css 属性中，同时在不支持的环境中将不会生效。而且，同样在 iOS 11 中，iPhone X 机型以下得到的值均为 0，iPhone X 得到其对应的设置量。</description>
    </item>
    
    <item>
      <title>数组降纬</title>
      <link>/2019/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BA%AC/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BA%AC/</guid>
      <description> 第一种：将数组字符串话  利用数组与字符串的隐式转换，使用+符号链接一个对象，javascript会默认调用toString方法转为字符串，再使用字符串分割成字符串数组，最后转成数值形数组。
 let arr = [[222, 333, 444], [55, 66, 77], 11, ] arr += &#39;&#39;; arr = arr.split(&#39;,&#39;); arr = arr.map(item =&amp;gt; Number(item)); console.log(arr); // [222, 333, 444, 55, 66, 77, 11]  第二种：自定义函数 const reduceDimension = (arr) =&amp;gt; { let ret = []; let toArr = function(arr){ arr.forEach(function(item){ Array.isArray(item) ? toArr(item) : ret.push(item); }); } toArr(arr); return ret; } let arr = [[12], 4, [333, [4444, 5555]], [9, [111, 222]]];  </description>
    </item>
    
    <item>
      <title>弹出遮照阻止底部页面滚动</title>
      <link>/2019/%E5%BC%B9%E5%87%BA%E9%81%AE%E7%85%A7%E9%98%BB%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%BC%B9%E5%87%BA%E9%81%AE%E7%85%A7%E9%98%BB%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</guid>
      <description> 代码如下： const bodyEl = document.body; let top = 0; /** * 阻止页面滚动 * @param {boolean} isFixed */ export function stopBodyScroll(isFixed: boolean) { if (isFixed) { top = window.scrollY; bodyEl.style.position = &#39;fixed&#39;; bodyEl.style.top = -top + &#39;px&#39;; } else { bodyEl.style.position = &#39;&#39;; bodyEl.style.top = &#39;&#39;; window.scrollTo(0, top); // 回到原先的top } }  </description>
    </item>
    
    <item>
      <title>ua检测</title>
      <link>/2019/ua%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/ua%E6%A3%80%E6%B5%8B/</guid>
      <description>代码如下： const userAgent = window.navigator.userAgent.toLowerCase(); export const uaJudge = { get isAndroid() { return /android|adr/gi.test(userAgent); }, get isVivo() { return /vivo/gi.test(userAgent); }, get isIos() { return /iphone|ipod|ipad/gi.test(userAgent); }, /** 微信（包含小程序） */ get isWeChat() { return /micromessenger/gi.test(userAgent); }, /** 微信小程序 */ get isWeChatMini() { if (this.isWeChat) { return new Promise((resolve, reject) =&amp;gt; { wx.miniProgram.getEnv((res: any) =&amp;gt; { resolve(res.miniprogram); }); setTimeout(resolve, 1000); }); } else { return Promise.resolve(false); } }, /** 支付宝 */ get isAlipay() { return /alipay/gi.</description>
    </item>
    
    <item>
      <title>获取元素content宽高</title>
      <link>/2019/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0content%E5%AE%BD%E9%AB%98/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0content%E5%AE%BD%E9%AB%98/</guid>
      <description>代码如下： /** * 获取元素content宽高 * @param el */ export function getContentSize(el: HTMLElement) { const width = el.offsetWidth; const height = el.offsetHeight; const style = window.getComputedStyle(el); // border const blw = parseFloat(style.borderLeftWidth || &#39;0&#39;); const brw = parseFloat(style.borderRightWidth || &#39;0&#39;); const btw = parseFloat(style.borderTopWidth || &#39;0&#39;); const bbw = parseFloat(style.borderBottomWidth || &#39;0&#39;); // padding const plw = parseFloat(style.paddingLeft || &#39;0&#39;); const prw = parseFloat(style.paddingRight || &#39;0&#39;); const ptw = parseFloat(style.paddingTop || &#39;0&#39;); const pbw = parseFloat(style.</description>
    </item>
    
    <item>
      <title>通过http链接加载script</title>
      <link>/2019/%E9%80%9A%E8%BF%87http%E9%93%BE%E6%8E%A5%E5%8A%A0%E8%BD%BDscript/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%80%9A%E8%BF%87http%E9%93%BE%E6%8E%A5%E5%8A%A0%E8%BD%BDscript/</guid>
      <description>function loadScript(src: string, async: boolean = true) { return new Promise((resolve, reject) =&amp;gt; { const script = document.createElement(&#39;script&#39;); async &amp;amp;&amp;amp; (script.async = true); script.onload = resolve; script.onerror = reject; script.src = src; document.body.appendChild(script); }); } // 注意：使用appendChild，不要使用append，ios9不支持append。  </description>
    </item>
    
    <item>
      <title>Webpack 优化相关</title>
      <link>/2019/webpack/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/webpack/</guid>
      <description>官网  Webpack 优化 构建过程提速策略 不要让 loader 做太多事情  以 babel-loader 为例：  babel-loader 无疑是强大的，但它也是慢的。
最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译，比如 webpack 官方在介绍 babel-loader 时给出的示例：
module: { rules: [ { test: /\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } } } ] }  除此之外，选择开启缓存将转译结果缓存至文件系统，只需要为 loader 增加相应的参数设定：
loader: &#39;babel-loader?cacheDirectory=true&#39;  抽离第三库  DllPlugin是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。  用 DllPlugin 处理文件，要分两步走：
 基于 dll 专属的配置文件，打包 dll 库 基于 webpack.</description>
    </item>
    
    <item>
      <title>localStorage 统一管理设置-增加时间</title>
      <link>/2018/local-stroge/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/local-stroge/</guid>
      <description>设置本地存储  function setStorage(key: string, value: any) { try { localStorage.setItem(key, JSON.stringify({ data: value, time: Date.now(), })); } catch { console.log(&#39;localStorage.setItem error&#39;); console.log(key, value); } }   获取本地存储  // 注意：stringify 会过滤掉undefined的值 function getStorage(key: string) { const result = localStorage.getItem(key); if (result) { try { const objRes = JSON.parse(result); return objRes; } catch (e) { console.log(&#39;JSON.parse error:&#39;, result); return result; } } else { return result; } }   删除本地存储  function removeStorage(key: string) { localStorage.</description>
    </item>
    
    <item>
      <title>Docker 相关</title>
      <link>/2018/docker/</link>
      <pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/docker/</guid>
      <description> Docker 相关 搭建 gitLab 搜索镜像 docker search gitlab-ce  查看镜像 docker images  </description>
    </item>
    
    <item>
      <title>Hapi</title>
      <link>/2018/hapi/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/hapi/</guid>
      <description>Hapi Hapi 相关使用总结  Hapi.js 是一个用来构建基于 Node.js 的应用和服务的富框架，使得开发者把重点放在便携可重用的应用逻辑而不是构建架构。内建输入验证、缓存、认证和其他 Web 应用开发常用的功能。  Hapi 框架模块接口文档  官网 Hapi-api  Supervisor / nodemon / PM2  有不少 Node.js 小工具能帮助我们监视代码的改动然后自动重启 Node.js 服务，好用的工具有 Supervisor / nodemon / PM2。  # 系统全局安装 supervisor $ npm i -g supervisor  目录结构 ├── config # 项目配置目录 | ├── index.js # 配置项目中的配置信息 ├── models # 数据库 model ├── node_modules # node.js 的依赖目录 ├── plugins # 插件目录 ├── routes # 路由目录 │ ├── hello-world.</description>
    </item>
    
    <item>
      <title>MySQL 使用</title>
      <link>/2018/mysql/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/mysql/</guid>
      <description>MySQL 在 cmder 上连接远程服务器 ssh root@**.**.**.*** 远程服务器地址IP root@**.**.**.***&#39;s password: *********** // [root@vultr ~]#  安装 mysql 我是在vultr上安装的，系统是CentOS 7，可以在网上找相关教程安装。
连接数据库 [root@vultr ~]# mysql -u root -p Enter password: **********  查看数据库 mysql&amp;gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | PRACTTEST | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.01 sec)  使用某个数据库 mysql&amp;gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed  查看表 mysql&amp;gt; show tables; +----------------------+ | Tables_in_PRACTTEST | +----------------------+ | DATA_PARICT | | _mysql_session_store | | pract_tbl | | transaction_tbl | | user | +----------------------+ 5 rows in set (0.</description>
    </item>
    
    <item>
      <title>MiniPrograms</title>
      <link>/2018/miniprograms/</link>
      <pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/miniprograms/</guid>
      <description>小程序相关 原生小程序 小程序支持分包加载  分包预下载  小程序转换为百度小程序  可以使用百度搬家工具进行转换 （不持支使用框架转换） ,wx2swanswan小程序搬家工具 (Node &amp;gt;= 8.0)  去掉小程序组件button默认样式  小程序中button组建有默认的点击效果，有border的话，需要去掉边框线的话需要这样写。  /* 去掉button默认边框线 */ button::after { border: 0; }  设置成禁用的话disable=&amp;quot;{{disable}}&amp;quot;,disable为 true 的话，点击按钮的时候还是有默认点击效果，如果需求需要去掉默认点击效果，就需要设置成行内样式来生效。
&amp;lt;!-- 行内样式 --&amp;gt; &amp;lt;button class=&amp;quot;get-code&amp;quot; size=&amp;quot;mini&amp;quot; bindtap=&amp;quot;getCode&amp;quot; disabled=&amp;quot;{{disabled}}&amp;quot; style=&amp;quot;color: #00a4ff; background-color: #fff;&amp;quot;&amp;gt;{{getCodeBtn}}&amp;lt;/button&amp;gt;  小程序限制  小程序背景图片不支持相对路径的图片路径，需要设置为绝对路径。 小程序现在默认上传包大小为2M（以后有可能变化），可以把图片资源单独打包成一个项目工程，然后在小程序中去引用图片的绝对路径。 小程序不支持table组件和标签，如果需要的话可用wxss(css)来写表格，然是涉及到表格跨行跨列的话不太好处理，可以换一种展现格式。简单来说就是小程序不支持复杂的表格。 小程序现在支持跳转外部url，需要使用web-view组建来实现，需要在微信公众平台登录，然后在设置里面&amp;ndash;&amp;gt;开发设置来绑定业务域名，并且在业务域名的跟目下放微信检验文件，只有放过之后，在域名跟目下能访问到这个检验文件，在绑定业务域名的时候才能绑定成功。   小程序使用 wx.request(OBJECT) 来发起请求时，需要在微信公众平台设置&amp;ndash;&amp;gt;开发设置里面设置服务器域名配置。   小程序不能操作BOM/DOM。 在 {{}} 模板语法里不持支复杂计算，具体看小程序文档。 小程序文字不能上下居中，尤其是在一个些小的按钮里边。 小程序 canvas 在真机中不支持base64，画不到canvas里面。 小程序获取用户授权之后再能通过 wx.getUserInfo 来获取用户信息，可以通过 button 来发起用户授权。  &amp;lt;button class=&amp;quot;{{isLog ?</description>
    </item>
    
    <item>
      <title>箭头函数this的指向</title>
      <link>/2018/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E6%8C%87%E5%90%91/</link>
      <pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E6%8C%87%E5%90%91/</guid>
      <description>箭头函数this的指向  介绍   箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。
 一、 何为定义时绑定（看下面的例子）
let x = 11; let obj = { x: 22, say: function () { console.log(this.x) } } obj.say() // 22  一般的定义函数跟我们的理解是一样的，运行的时候决定this的指向，我们可以知道当运行obj.say()时候，this指向的是obj这个对象。
let x = 11; let obj = { x: 22, say: () =&amp;gt; { console.log(this.x) } } obj.say() // 11  这个this指向的是外部的 x = 11。
所谓的定义时候绑定， *就是它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值*，比如这里的箭头函数中的this.x，箭头函数本身与say平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而obj的父执行上下文就是window，因此这里的this.x实际上表示的是window.x，因此输出的是11。(this只有在函数被调用，或者通过构造函数new Object()的形式才会有this)。
 类似的还有：  // 不使用箭头函数 let a = 11; function test () { this.</description>
    </item>
    
    <item>
      <title>ES6的一些方法和技巧</title>
      <link>/2018/es6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/es6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/</guid>
      <description>ES6的一些方法和技巧 声明变量 用let不用var ES6之前我们用var声明一个变量，但是它有很多弊病：
 因为没有块级作用域，很容易声明全局变量 变量提升 可以重复声明 还记得这道面试题吗？  var a = []; for (var i = 0; i &amp;lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 a[7](); // 10 a[8](); // 10 a[9](); // 10  所以要使用 let，可以避免 使用 var 来声明所带来的一些问题。
const 和 let const 和 let 的区别就是 使用 const 来声明的变量，称为 常量
 更好的代码语义化，哪个可以修改，哪个不可以修改等等 函数声明应该使用 const 来声明  字符串 不要使用 &amp;ldquo;双引号&amp;rdquo;，一律使用 &amp;lsquo;单引号&amp;rsquo; 或者 `模板字符串`</description>
    </item>
    
    <item>
      <title>EventLoop</title>
      <link>/2018/eventloop/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/eventloop/</guid>
      <description>Event Loop 参考资料：
JavaScript 运行机制详解：再谈Event Loop@阮一峰
8张图帮你一步步看清 async/await 和 promise 的执行顺序
进程与线程的一个简单解释
事件循环机制 线程与进程   进程：CPU资源分配的最小单位 线程：CPU调度的最小单位   浏览器打开即为打开一个进程（任务管理器查看），浏览器就是多进程、多线程的，浏览器打开后占用CPU的资源，可将这些资源分别分配给不同的tab页面进行并发处理，互不影响；如：一个浏览器打开多个窗口，多个窗口同时运行网页（浏览器中任务管理查看）
浏览器 浏览器进程 作为主进程，主要负责页面管理以及其他进程的创建及销毁，常驻的线程有：(工厂-&amp;gt; 部门)
手机工厂(浏览器)[进程] ↓ 造手机部 &amp;mdash;&amp;ndash; 造手机壳部 &amp;mdash;&amp;ndash; 造膜部等(tab页面)[进程] ↓ 各个岗位(html、css、js、事件触发等)[线程]
  GUI渲染线程  主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。（回流必将引起重绘，重绘不一定会引起回流） 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，JS引擎才会去执行 GUI 渲染。  JS引擎线程
 该线程当然是主要负责处理 JavaScript脚本，执行代码； 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并返回正确时，将依次进入任务队列，等待JS引擎线程的执行； 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。  事件触发线程  主要负责将准备好的事件交给Js引擎线程执行 比如setTimeout定时器计数结束，ajax等异步请求成功并出发回调函数，或者用户出发点击事件，该线程将会整装待发的事件依次加入到任务队列的队尾，等待Js引擎线程的执行  定时器触发线程  顾名思义，负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。  HTTP请求线程  顾名思义，负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。    多个线程之间配合工作，各司其职。</description>
    </item>
    
    <item>
      <title>js 调试相关</title>
      <link>/2018/debugs/</link>
      <pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/debugs/</guid>
      <description>Js调试命令 Console  Console 对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的。
 Console 对象可以在任何全局对象中访问，如 Window，WorkerGlobalScope 以及通过属性工作台提供的特殊定义。
 它被浏览器定义为 Window.Console，也可被简单的 Console 调用。  最常用的方法就是 console.log() 就是在控制台输出内容。console 对象还有除了 log 之外的其他方法。
注意：因为 Console 对象提供对浏览器控制台的接入 ，所以在不同浏览器中的支持以及表现方法可能不太一样，但是调试内容只有开发者会看，所以保证在开发环境用这些方法就可以。
分类输出  不同类别信息的输出。  console.log(&#39;文字信息&#39;); console.info(&#39;提示信息&#39;); console.warn(&#39;警告信息&#39;); console.error(&#39;错误信息&#39;);  分组输出  使用 Console.group()和 Console.groupEnd()包裹分组内容。 还可以使用 Console.groupCollapsed()来代替 Console.group()生成折叠的分组。  console.group(&#39;第一个组&#39;); console.log(&amp;quot;1-1&amp;quot;); console.log(&amp;quot;1-2&amp;quot;); console.log(&amp;quot;1-3&amp;quot;); console.groupEnd(); console.group(&#39;第二个组&#39;); console.log(&amp;quot;2-1&amp;quot;); console.log(&amp;quot;2-2&amp;quot;); console.log(&amp;quot;2-3&amp;quot;); console.groupEnd();  Console.group()还可以嵌套使用。
console.group(&#39;第一个组&#39;); console.group(&amp;quot;1-1&amp;quot;); console.group(&amp;quot;1-1-1&amp;quot;); console.log(&#39;内容&#39;); console.groupEnd(); console.groupEnd(); console.group(&amp;quot;1-2&amp;quot;); console.log(&#39;内容&#39;); console.log(&#39;内容&#39;); console.log(&#39;内容&#39;); console.groupEnd(); console.groupEnd(); console.groupCollapsed(&#39;第二个组&#39;); console.</description>
    </item>
    
    <item>
      <title>npm 镜像设置</title>
      <link>/2018/npm/</link>
      <pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/npm/</guid>
      <description> npm 镜像设置 npm config set registry https://registry.npm.taobao.org npm config set SASS_BINARY_SITE https://npm.taobao.org/mirrors/node-sass/  </description>
    </item>
    
    <item>
      <title>JS随笔</title>
      <link>/2018/js-essay/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/js-essay/</guid>
      <description>JS随笔 等待多好毫秒后执行后面代码 export const sleep = async (ms: number) =&amp;gt; { return new Promise((resolve) =&amp;gt; setTimeout(resolve, ms || 0)); };  点击按钮复制一个文本或者链接地址 &amp;lt;div id=&amp;quot;lalala&amp;quot;&amp;gt;www.baidu.com45646!!!!&amp;lt;/div&amp;gt; &amp;lt;button onclick=&amp;quot;but()&amp;quot;&amp;gt;点我&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function but () { var copyDOM = document.getElementById(&#39;lalala&#39;); var range = document.createRange(); // 选中需要复制的节点 range.selectNode(copyDOM); // 执行选中元素 window.getSelection().addRange(range); // 执行 copy 操作 var successful = document.execCommand(&#39;copy&#39;); try { var msg = successful ? &#39;successful&#39; : &#39;unsuccessful&#39;; console.log(&#39;copy is&#39; + msg); } catch(err) { console.</description>
    </item>
    
    <item>
      <title>Vue Plugins And Expansion</title>
      <link>/2017/vueplugins/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vueplugins/</guid>
      <description> Vue Plugins And Expansion(后台模板) 条形码 vue-barcode  地址：vue-barcode GitHub: https://github.com/fengyuanchen/vue-barcode
 全局使用方式：
  // main.js import VueBarcode from &#39;@chenfengyuan/vue-barcode&#39;; Vue.component(&#39;barcode&#39;, VueBarcode);  &amp;lt;barcode :value=qualityInfo.tyOrderCode :options=&amp;quot;{ displayValue: false }&amp;quot; id=&amp;quot;canves&amp;quot;&amp;gt;&amp;lt;/barcode&amp;gt;  vue图表-V-charts  V-charts 文档  vue后台管理模板  vue-element-admin  vant UI组件库  vant 使用 van-popup 来封装一个组件时，需要使用 :value=&amp;quot;value&amp;quot; 来绑定，避免使用 v-model 来绑定v-model，代码如下：  &amp;lt;!-- 可以查看 vue 文档 对 v-model 的解释 --&amp;gt; &amp;lt;van-popup :value=&amp;quot;isShowCash&amp;quot; @click-overlay=&amp;quot;closeCashPopup&amp;quot;&amp;gt; &amp;lt;!-- .... to do --&amp;gt; &amp;lt;/van-popup&amp;gt;  </description>
    </item>
    
    <item>
      <title>vue 相关问题</title>
      <link>/2017/workrelated/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/workrelated/</guid>
      <description>使用 keep-alive 来包裹路由后，某个页面需要动态的去除缓存 可以使用动态的:include=&amp;quot;calcInclude&amp;quot; 来对需要的缓存的页面进行修改，calcInclude需要使用计算属性。整个include使用数组来储存*string[]*，数据可放到全局 store 中，通过 commit去修改，在需要的地方去更改。
&amp;lt;keep-alive :include=&amp;quot;calcInclude&amp;quot;&amp;gt; &amp;lt;router-view /&amp;gt; &amp;lt;/keep-alive&amp;gt;  get calcInclude() { return this.$store.state.includes; } const store = { state: { includes: [&#39;...&#39;}, }, } const mutations = { changeIncludes(state: State, obj: any) { const name = obj.name; const channel = obj.channel; const ind = state.includes.indexOf(name); if (ind &amp;gt; -1 &amp;amp;&amp;amp; channel === &#39;remove&#39;) { state.includes.splice(ind, 1); } else if (channel === &#39;add&#39;) { state.</description>
    </item>
    
    <item>
      <title>Vue watch选项</title>
      <link>/2017/vue-watch/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vue-watch/</guid>
      <description>Vue watch选项  watch 的用法
 watch 对象里的 value 是对应的回调函数
  data () { return { a: 1 } }, watch: { a: function (newVal, oldVal) { console.log(newVal, oldVal) // 2 1 } }, created () { this.a = 2 }   value 也可以是方法名  data () { return { a: 1 } }, watch: { a: &#39;foo&#39; }, created () { this.a = 2 }, methods: { foo (newVal, oldVal) { console.</description>
    </item>
    
    <item>
      <title>Vue配置相关</title>
      <link>/2017/vue/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vue/</guid>
      <description>Vue配置相关 代理配置 module.exports = { ........, dev: { // 开发环境配置 env: require(&#39;./dev.env&#39;), // 使用 config/dev.env.js 中定义的编译环境 port: 8686, // 运行测试页面的端口号 autoOpenBrowser: true, assetsSubDirectory: &#39;static&#39;, // 编译输出的二级目录 assetsPublicPath: &#39;/&#39;, // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 // 需要 proxyTable 代理的接口（可跨域） proxyTable: { &#39;**&#39;: { target: &#39;https://xxxxxxx&#39;, changeOrigin: true, filter: function (pathname, req) { // 接口地址 /******-server/****/****** return pathname.match(&#39;^\/.+-server.*&#39;) } } }, cssSourceMap: false } }  多入口配置 /* utils.js */ const path = require(&#39;path&#39;); // glob 是 webpack 安装时依赖的一个第三方模块，还模块允许你使用 * 等符号, // 例如 lib/*.</description>
    </item>
    
    <item>
      <title>vue中盲点</title>
      <link>/2017/vue-blind-spot/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vue-blind-spot/</guid>
      <description>vue中盲点 使用 performance 开启性能追踪  performance API 是 Vue 全局配置 API 中的一个，我们可以使用它来进行网页性能的追踪，我们可以在入口文件中添加：  if (process.env.NODE_ENV !== &#39;production&#39;) { Vue.config.performance = true; }  来开启这一功能，该 API（2.2.0 新增）功能只适用于开发模式和支持 performance.mark API 的浏览器上，开启后我们可以下载 Vue Performance Devtool 这一 chrome 插件来看查看各个组件的加载情况，如图：
从中我们可以清晰的看到页面组件在每个阶段的耗时情况，而针对耗时比较久的组件，我们便可以对其进行相应优化。
而其在 Vue 源码中主要使用了 window.performance 来获取网页性能数据，其中包含了 performance.mark 和 performance.measure。
 performance.mark 主要用于创建标记 performance.measure 主要用于记录两个标记的时间间隔  例如：
performance.mark(&#39;start&#39;); // 创建 start 标记 performance.mark(&#39;end&#39;); // 创建 end 标记 performance.measure(&#39;output&#39;, &#39;start&#39;, &#39;end&#39;); // 计算两者时间间隔 performance.getEntriesByName(&#39;output&#39;); // 获取标记，返回值是一个数组，包含了间隔时间数据  熟练的使用 performance 我们可以查看并分析网页的很多数据，为我们项目优化提供保障。</description>
    </item>
    
    <item>
      <title>HTTP Status code（状态码）和 Status text（状态文本）(简单随笔)</title>
      <link>/2017/httpstatus/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/httpstatus/</guid>
      <description>常见的状态码  1xx：临时回应，表示客户端请继续。 2xx：请求成功：  200：请求成功。  3xx: 表示请求的目标有变化，希望客户端进一步处理：  301&amp;amp;302：永久性与临时性跳转。 304：客户端缓存没有更新。  4xx：客户端请求错误：  403：无权限。 404：表示请求的页面不存在。 418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）  5xx：服务端请求错误：  500：服务端错误。 503：服务端暂时性错误，可以一会再试。   对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。
2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。
3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。
304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。</description>
    </item>
    
    <item>
      <title>JS 模板</title>
      <link>/2017/template/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/template/</guid>
      <description> JS 模板 Juicer  GitHub  Soda  官方文档 GitHub  </description>
    </item>
    
    <item>
      <title>debugTools</title>
      <link>/2017/debugtools/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/debugtools/</guid>
      <description>抓包调试工具 Fidder的使用  下载地址  Fidder简介  抓包工具有很多，小到最常用的web调试工具firebug，达到通用的强大的抓包工具wireshark.为什么使用fiddler?原因如下： &amp;gt; a.Firebug虽然可以抓包，但是对于分析http请求的详细信息，不够强大。模拟http请求的功能也不够，且firebug常常是需要“无刷新修改”，如果刷新了页面，所有的修改都不会保存。 &amp;gt; b.Wireshark是通用的抓包工具，但是比较庞大，对于只需要抓取http请求的应用来说，似乎有些大材小用。 &amp;gt; c.Httpwatch也是比较常用的http抓包工具，但是只支持IE和firefox浏览器（其他浏览器可能会有相应的插件），对于想要调试chrome浏览器的http请求，似乎稍显无力，而Fiddler 是一个使用本地 127.0.0.1:8888 的 HTTP 代理，任何能够设置 HTTP 代理为 127.0.0.1:8888 的浏览器和应用程序都可以使用 Fiddler。
 对手机抓包  Tools &amp;gt; Options &amp;gt; https 勾选图中红线框出来的，之后会有弹窗提示安装证书。   Tools &amp;gt; Options &amp;gt; connections 勾选图中的   在手机上连接跟电脑在同一局域网下的网络，然后在无线网络中去设置代理，代理地址就是电脑ip地址和 端口号，之后在手机浏览器中输入 电脑ip地址和端口号 进行访问，会出下如下图，然后点击图中框出来的文字，下载并且安装证书。ios 比 安卓再多一个步骤，需要去 设置-&amp;gt;通用-&amp;gt;关于本机-&amp;gt;证书信任设置 去信任证书才可以进行抓包。  在电脑上对浏览器进行抓包  可以在浏览器设置里面设置代理，或者安装 Proxy SwitchyOmega 这个插件来管理代理，代理协议为 http，代理服务器为 127.0.0.1，端口号是在 fidder 上设置的端口号。  可以对fidder自定义规则(Rules -&amp;gt; Customize Rules)  下列设置中只能有一个OnBeforeResponse和OnBeforeResponse，下面只是为了方便演示代码位置才写了多个</description>
    </item>
    
    <item>
      <title>git commit emoji 使用指南</title>
      <link>/2017/git-commit-emoji/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/git-commit-emoji/</guid>
      <description>git commit emoji 使用指南 目录  commit 格式 emoji 指南 如何在命令行中显示 emoji 参考  git commit emoji write a good commit message   执行 git commit 时使用 emoji 为本次提交打上一个 &amp;ldquo;标签&amp;rdquo;, 使得此次 commit 的主要工作得以凸现，也能够使得其在整个提交历史中易于区分与查找。
截取的 gitmoji 快照:
commit 格式 git commit 时，提交信息遵循以下格式：
:emoji1: :emoji2: 不超过 50 个字的摘要，首字母大写，使用祈使语气，句末不要加句号 提交信息主体 引用相关 issue 或 PR 编号 &amp;lt;#110&amp;gt;  初次提交示例：
git commit -m &amp;quot;🎉 Initialize Repo&amp;quot;  emoji 指南    emoji emoji 代码 commit 说明     🎉 (庆祝) tada 初次提交   ✨ (火花) sparkles 引入新功能   🔖 (书签) bookmark 发行/版本标签   🐛 (bug) bug 修复 bug   🚑 (急救车) ambulance 重要补丁   🌐 (地球) globe_with_meridians 国际化与本地化   💄 (口红) lipstick 更新 UI 和样式文件   🚨 (警车灯) rotating_light 移除 linter 警告   🔧 (扳手) wrench 修改配置文件   ➕ (加号) heavy_plus_sign 增加一个依赖   ➖ (减号) heavy_minus_sign: 减少一个依赖   ⬆️ (上升箭头) arrow_up 升级依赖   ⬇️ (下降箭头) arrow_down 降级依赖   ⚡️ (闪电)</description>
    </item>
    
    <item>
      <title>git 相关总结</title>
      <link>/2017/git-summary/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/git-summary/</guid>
      <description>关于git的总结 git工作流 git相关  git 提交规范 git 简明指南 git 在线教程 git pro 中文教程
 Commitizen是一个撰写合格 Commit message 的工具。
  1.安装命令如下:
npm install -g commitizen  2.然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式
commitizen init cz-conventional-changelog --save --save-exact  3.以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message
 更多关于Commit message 和 Change log 编写指南可以到Commit message 和 Change log 编写指南查看&amp;hellip;  git操作 合并某个分支上的文件到应一个分支、回退到某个版本和 远程服务器上面回退到某个版本  git 合并某个分支上的文件到另一个分支上git checkout branch &amp;lt;path&amp;gt; git 本地回退到某个版本
git reset --hard 23bc94cf7e3c74c33dd4575dfbf72d6647333795   git 远程服务器上面回退到某个版本</description>
    </item>
    
    <item>
      <title>gulp 配置</title>
      <link>/2017/gulp/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/gulp/</guid>
      <description>项目中 gulp 的配置 项目目录结构 . ├── dist // 打包后的文件 ├── node_modules // 依赖模块 ├── src // 具体页面 | ├── namePage | ├── img // 图片 | └── xxx.png | ├── js // js文件 | └── xxx.js | ├── pages // 页面 | └── xxx.html | ├── sass // sass文件 | └── xxx.scss | └── sprite // 需要合成雪碧图的文件 | └── namePage | ├── img // 图片 | └── xxx.png | ├── js // js文件 | └── xxx.</description>
    </item>
    
    <item>
      <title>leetCode Easy One</title>
      <link>/2017/leetcode-easy/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/leetcode-easy/</guid>
      <description>Two Sum 两数之和(1)  给定一个整数数组，返回两个数字的索引，使它们相加到特定目标。您可以假设每个输入只有一个解决方案，并且您可能不会两次使用相同的元素。 例子：   Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].   解:  /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { // 第一种 let map = new Map() for (let i = 0; i &amp;lt; nums.length; i++) { if (map.</description>
    </item>
    
    <item>
      <title>leetCode Medium</title>
      <link>/2017/leetcode-medium/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/leetcode-medium/</guid>
      <description>Add Two Numbers 两数相加(2)  给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
 例子:
  Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807   解:  // 单链表的定义 function ListNode(val) { this.val = val; this.next = null; } // 第一种 /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { if (l1===null) return l2; if (l2===null) return l1; //new a ListNode here, with head.</description>
    </item>
    
    <item>
      <title>text-decoration 文本修饰</title>
      <link>/2017/%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/</guid>
      <description> 项目使用是用来 做下划线等，例如减免邮费等。如果在父元素上设置值为line-through，然后字元素有多个，font-size相同的情况下样式正确，font-size不同的情况下，会找自身元素的中间位置添加下划线。 text-decoration 属性规定添加到文本的修饰。 修饰的颜色由 &amp;ldquo;color&amp;rdquo; 属性设置。  h1 {text-decoration:overline} h2 {text-decoration:line-through} h3 {text-decoration:underline} h4 {text-decoration:blink}   可能的值  none	#默认。定义标准的文本。 underline	#定义文本下的一条线。 overline	#定义文本上的一条线。 line-through	#定义穿过文本下的一条线。 blink	#定义闪烁的文本。 inherit	#规定应该从父元素继承 text-decoration 属性的值。  </description>
    </item>
    
    <item>
      <title>常用工具集合</title>
      <link>/2017/tools/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/tools/</guid>
      <description> Docsify  一个神奇的文档网站生成工具 GitHub  Clover  Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。
 Everything  Everything 是 Windows 全局文件、文件夹 搜索软件。
 YoMail  YoMail 支持 Markdown 语法的邮箱客户端。
 PxCook  PxCook UI自动标注，生成前端css代码等。
 Imagine  Imagine 开源的 PNG/JPEG 压缩工具。
 Eruda  Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。
 vConsole  vConsole 是一个轻量、可拓展、针对手机网页的前端开发者调试面板。
 Weinre  Weinre 基于node平台 的远程运行调试web页面工具。官网。
 </description>
    </item>
    
    <item>
      <title>node版本管理</title>
      <link>/2017/node-version/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/node-version/</guid>
      <description>node版本管理 nvm 和 n  nvm
 Node版本管理器&amp;ndash;nvm，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件,可以在 windows 系统上使用 https://github.com/coreybutler/nvm-windows
 n
 这意味着，我们在使用 n 管理 node 版本前，首先需要一个 node 环境。我们或者用 Homebrew 来安装一个 node，或者从官网下载 pkg 来安装，总之我们得先自己装一个 node —— n 本身是没法给你装的。
然后我们可以使用 n 来安装不同版本的 node。
在安装的时候，n 会先将指定版本的 node 存储下来，然后将其复制到我们熟知的路径 /usr/local/bin，非常简单明了。当然由于 n 会操作到非用户目录，所以需要加 sudo 来执行命令。
所以这样看来，n 在其实现上是一个非常易理解的方案
https://github.com/tj/n
因为我的电脑是 windows 系统，所以使用的是 nvm for windows
nvm for windows  下载地址： https://github.com/coreybutler/nvm-windows/releases   nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置 nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便 Source code(zip)：zip压缩的源码 Sourc code(tar.</description>
    </item>
    
  </channel>
</rss>