<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Magic</title>
    <link>/posts/</link>
    <description>Recent content in Posts on Magic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 22 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Windows Terminal 美化</title>
      <link>/2020/windowsterminal/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/windowsterminal/</guid>
      <description>参考和部分引用自: SpencerWoo：新生代 Windows 终端：Windows Terminal 的全面自定义
Windows Terminal 美化 安装 Windows Terminal  可以到 Microsoft Store 中安装 Windows Terminal（Preview）   也可以从 https://github.com/microsoft/terminal 来安装  使用 scoop 来管理软件  用 Scoop 管理你的 Windows 软件 可以使用 scoop help 来查看更多命令 scoop 语法 scoop + 动作 + 对象，对象是可以省略的 scoop bucket add nerd-fonts 用来添加字体库，后续需要使用这个 scoop search FantasqueSansMono-NF 搜索需要安装的字体，下图所示    scoop install FantasqueSansMono-NF 安装字体  安装 oh-my-posh  官网 安装 posh-git 和 oh-my-posh 这两个模块  Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser  让 PowerShell 主题配置生效  新增（或修改）你的 PowerShell 配置文件  # 如果之前没有配置文件，就新建一个 PowerShell 配置文件 if (!</description>
    </item>
    
    <item>
      <title>常用代理设置汇总</title>
      <link>/2020/%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3/</guid>
      <description>常用代理设置汇总 设置代理是为了这几种情况：
 翻墙 从 内网 访问 外网 从 内网 访问 内网镜像库（npm、composer 等）  代理方式 代理设置至少有以下几种方式：
 设置目标代理机器（常用）如：http://yourProxyServer:port 设置 pac 自动匹配代理（常用于浏览器）如：http://example/a.pac  代理地址 假设你目前可用的代理是：http://yourProxyServer:port，后面例子均以此代理作为示范。
Windows CMD 代理设置 当前 CMD 窗口有效：
REM 设置代理 set http_proxy=http://yourProxyServer:port set https_proxy=http://yourProxyServer:port REM 查看代理 echo %http_proxy% echo %https_proxy% REM 取消代理(留空即可) set http_proxy= set https_proxy=  若想一直有效，设置系统环境变量：http_proxy、https_proxy，并重启你的 Windows。
注意：
 http_proxy 和 https_proxy 对应的都是 http://yourProxyServer:port，后者可能没有 https 的 s  Linux 代理设置 同下面 Mac 代理设置 ↓
Mac 代理设置 这里只说命令行配置代理的方式</description>
    </item>
    
    <item>
      <title>单例模式-创建型</title>
      <link>/2020/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</guid>
      <description>单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。
实现思路 class Single { show() { console.log(&#39;我是一个单例对象&#39;); } } const s1 = new Single(); const s2 = new Single(); // s1 === s2 false  先 new 了一个 s1，又 new 了一个 s2，很明显 s1 和 s2 之间没有任何瓜葛，两者是相互独立的对象，各占一块内存空间。而单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。要做到这一点，就需要构造函数 具备判断自己是否已经创建过一个实例的能力。
 🌰1  /** * 实现：静态方法版 */ class Storage { static getInstance() { if (!Storage.instance) { Storage.instance = new Storage(); } return Storage.instance; } getItem(key) { return localStorage.getItem(key); } setItem(key, val) { return localStorage.</description>
    </item>
    
    <item>
      <title>Docker Gitlab</title>
      <link>/2019/docker-gitlab/</link>
      <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/docker-gitlab/</guid>
      <description>安装 Gitlab  目录类似 Jenkins，使用 docker-compose 安装  version: &#39;3&#39; services: docker-gitlab: image: &#39;twang2218/gitlab-ce-zh:9.4&#39; restart: &#39;no&#39; container_name: gitlab hostname: &#39;gitlab.xxxxx.com&#39; environment: TZ: &#39;Asia/Shanghai&#39; GITLAB_OMNIBUS_CONFIG: | external_url &#39;http://gitlab.xxxxxx.com&#39; unicorn[&#39;worker_timeout&#39;] = 60 unicorn[&#39;worker_processes&#39;] = 2 gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39; gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 26 nginx[&#39;client_max_body_size&#39;] = &#39;250m&#39; ports: - &#39;81:80&#39; - &#39;443:443&#39; - &#39;26:22&#39; volumes: - /home/gitlab/gitlab_home/config:/etc/gitlab - /home/gitlab/gitlab_home/data:/var/opt/gitlab - /home/gitlab/gitlab_home/logs:/var/log/gitlab  在当前目录下运行 docker-compose up -d
Nginx 代理 upstream gitlab { server 116.62.201.97:81; } server { listen 80; server_name gitlab.</description>
    </item>
    
    <item>
      <title>Docker Jenkins</title>
      <link>/2019/docker-jenkins/</link>
      <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/docker-jenkins/</guid>
      <description>安装 jenkins 在安装jenkins我选择了使用docker-compose，docker-compose 是一个用来把 docker 自动化的东西
有了 docker-compose 你可以把所有繁复的 docker 操作全都一条命令，自动化的完成。
首先我们需要在服务器上创建一个目录机构 /home/jenkins - docker-compose.yml - jenkins-home  接下来我们来编写 docker-compose.yml 安装jenkins version: &#39;3&#39; # 指定 docker-compose.yml 文件的写法格式 services: # 多个容器集合 docker_jenkins: user: root # 为了避免一些权限问题 在这我使用了root restart: always # 重启方式 image: jenkins/jenkins:lts # 指定服务所使用的镜像 在这里我选择了 LTS (长期支持) container_name: jenkins # 容器名称 ports: # 对外暴露的端口定义 - &#39;8899:8080&#39; - &#39;50000:50000&#39; volumes: # 卷挂载路径 - /home/jenkins/jenkins_home/:/var/jenkins_home # 这是我们一开始创建的目录挂载到容器内的jenkins_home目录 - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker # 这是为了我们可以在容器内使用docker命令 - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose # 同样的这是为了使用docker-compose命令  我们需要进入到 jenkins 目录下执行：docker-compose up -d，开启守护进程后台执行(停止 docker-compose down)这个命令会帮我们自动拉取镜像并配置，不出意外你现在可以打开你的服务器地址 http://xxxxxxx:端口号 就能看到这个界面：</description>
    </item>
    
    <item>
      <title>链表-leetCode-删除链表中的节点</title>
      <link>/2019/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>删除链表中的节点 描述 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
现有一个链表 &amp;ndash; head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.  分析 从链表里删除一个节点 node 的最常见方法是修改之前节点的 next 指针，使其指向之后的节点。 因为，我们无法访问我们想要删除的节点 之前 的节点，我们始终不能修改该节点的 next 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。 因为我们知道要删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。
/** * @param {ListNode} node * @return {void} Do not return anything, modify node in-place instead.</description>
    </item>
    
    <item>
      <title>TS重新定义模块</title>
      <link>/2019/ts%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/ts%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</guid>
      <description>重新定义模块：
declare var am: any; // 支付宝 declare interface Window { ap: any; // 支付宝注入 } declare module &#39;dva/dynamic&#39; { const dynamic: (config: any) =&amp;gt; React.ComponentType; export default dynamic; }  </description>
    </item>
    
    <item>
      <title>链表-leetCode-反转链表</title>
      <link>/2019/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>反转链表 描述  反转一个单链表。  示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL  分析 一、迭代 - 第一个节点无前置节点 所以需要声明初始化一个前置节点prev - 开始迭代，结束提交为 当前节点不为null - 先把当前节点后置节点变为当前节点的前置节点 - 然后把前置pre变为当前节点 因为下一次所需 - 再把当前节点设为后置节点
在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！
/** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let cur = head; let pre = null; while(cur) { let temp = cur.next; // 保存当前节点的后置节点 之后循环到下一个节点需要 cur.next = pre; pre = cur; cur = temp; } return pre; };  二、递归</description>
    </item>
    
    <item>
      <title>链表-leetCode-设计链表</title>
      <link>/2019/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
      <description>设计链表 描述 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
 get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。  分析 // 假设链表为 5 -&amp;gt; 3 &amp;gt; 1 { val: 5, next: { val: 3, next: { val: 1, next: null } } } // 双链表的结构就会多一个prev  一、数组（不推荐） class MyLinkedList { constructor() { this.</description>
    </item>
    
    <item>
      <title>Docker 相关</title>
      <link>/2019/docker/</link>
      <pubDate>Mon, 02 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/docker/</guid>
      <description>Docker 相关 服务器环境: ubuntu16
使用APT安装 sudo apt-get update sudo apt-get install apt-transport-https ca-certificates curl software-properties-common  添加软件源的 GRP 密钥
curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # 官方源 # curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -  然后，我们需要向 source.list 中添加 Docker 软件源
$ sudo add-apt-repository &amp;quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot; # 官方源 # $ sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;quot;  以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要测试或每日构建版本的 Docker CE 请将 stable 改为 test 或者 nightly。</description>
    </item>
    
    <item>
      <title>链表-leetCode-两数相加</title>
      <link>/2019/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>两数相加 描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) 输出：7 -&amp;gt; 0 -&amp;gt; 8 原因：342 + 465 = 807  分析  单链表的数据结构：val属性存储当前的值，next属性存储下一个节点的引用。  从链表表头开始，然后进行每一位进行相加，每位的数字在 0~9 之间，相加有可能会出现 溢出 。 例如：5+7=12，这种情况下，将个位设置为当前值（也就是2），并将进位 carry=1 带入下一次迭代。进位必定是 0 | 1，因为两个数字相加（考虑到进位）最大和为 9+9+1=19。
 对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。
  先初始化一个哑结点 初始化 sum 为 0 进位 carry 初始化为 0 遍历列表 l1 和 l2 直至到达它们的尾端，并对 sum 进行累加，将 l1 和 l2 赋值为下一个节点 更新进位的值，carry = ~~(sum / 10carry=sum/10) 创建一个数值为 (sum % 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点 sum 赋值为 进位 carry，带入下一次循环 将 carry 从初始化 返回哑结点的下一个结点  代码 /** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>链表-leetCode-合并两个有序链表</title>
      <link>/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>由于单链表是线性的，使用递归方式将导致栈的使用也是线性的，当链表长度达到一定程度时，递归会导致爆栈，因此，现实中并不推荐使用递归方式来操作链表。
 合并两个有序链表 描述 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  分析 一、 递归
可以使用 递归，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。
 特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。
 思路
 这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素 终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束 返回值：每一层调用都返回排序好的链表头 本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理 O(m+n)O(m+n)，mm 为 l1的长度，nn 为 l2 的长度   /** * Definition for singly-linked list. * function ListNode(val) { * this.</description>
    </item>
    
    <item>
      <title>链表-leetCode-回文链表</title>
      <link>/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>回文链表 描述 判断一个链表是否为回文链表
示例 1: 输入: 1-&amp;gt;2 输出: false 示例 2: 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出: true  分析  用2个指针，一个low，一个fast，fast是low的2倍，所以可以达到2分链表的效果 在移动指针时同时对前半部分链表进行反转，最后直接比较被分开的2个链表 因为不能改变当前slow的next，不然就无法跳到下一个元素，所以这里用pre和prepre实现指针的反转  /** * @param {ListNode} head * @return {boolean} */ var isPalindrome = function(head) { if (!head || !head.next) return true; let slow = head; let fast = head.next; let pre = null; let prepre = null; while (fast &amp;amp;&amp;amp; fast.next) { // 反转前半段链表 pre = slow; slow = slow.</description>
    </item>
    
    <item>
      <title>你真的了解webview么？</title>
      <link>/2019/webview/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/webview/</guid>
      <description>文章转载自微信公众号 大转转FE
适用场景 像一些 App 的内嵌页面，提供各种各样的交互操作，其实webview的应用场景远远不止这些，其实在一些PC的软件里，和我们交互的也是我们的html页面，只是穿着webview的衣服，衣服太美而我们没有发现他们的真谛。
另外，还有一些网络机顶盒里的交互，也是webview在和我们打交道，比如一些早期的IPTV里的EPG都是运行在webview里的，它们基于webkit内核，尽管我们使用的交互方式是遥控器。
与App native的交互 目前使用频率最多的，还是客户端内嵌的webview，都是webview打开m页去承接的。目前javascript和客户端（后面统称native）交互的常见方式有两种，一种是通过JSBridge的方式，另一种是通过schema的方式。
JSBridge 体现的形式其实就是，当我们在native内打开m页，native会在全局的window下，为我们注入一个Bridge。这个Bridge里面，会包含我们与native交互的各种方法、比如判断第三方App是否安装、获取网络信息等等功能。
/** * 作用域下的JSBridge， * 和实例化后的getNetInfomation， * 均根据实际约定情况而定， * 这里只是用来举例说明 */ const bridge = window.JSBridge; console.log(bridge.getNetInfomation());   IOS端: 在IOS中，主要使用WebViewJavascriptBridge来注册，可以参考Github WebViewJavascriptBridge  self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView]; [self.bridge registerHandler:@&amp;quot;ObjC Echo&amp;quot; handler:^(id data, WVJBResponseCallback responseCallback) { // to do... }];   Android: 在Android中，需要通过addJavascriptInterface来注册  class JSBridge { @JavascriptInterface //注意这里的注解。出于安全的考虑，4.2 之后强制要求，不然无法从 Javascript 中发起调用 public void getNetInfomation(){ // to do }; } webView.</description>
    </item>
    
    <item>
      <title>链表-leetCode-相交链表</title>
      <link>/2019/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>相交链表 描述 编写一个程序，找到两个单链表相交的起始节点。
注意： - 如果两个链表没有交点，返回 null. - 在返回结果后，两个链表仍须保持原有的结构。 - 可假定整个链表结构中没有循环。 - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
分析 根据题目意思
如果两个链表相交，那么相交点之后的长度是相同的
我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。 为此，我们必须消除两个链表的长度差
 指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历 如果 pA 到了末尾，则 pA = headB 继续遍历 如果 pB 到了末尾，则 pB = headA 继续遍历 比较长的链表指针指向较短链表head时，长度差就消除了 如此，只需要将最短链表遍历两次即可找到位置  var getIntersectionNode = function(headA, headB) { if (headA === null || headB === null) return null; let pA = headA; let pB = headB; while(pA !</description>
    </item>
    
    <item>
      <title>链表-leetCode-环形链表</title>
      <link>/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>环形链表 描述 给定一个链表，判断链表中是否有环。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。  示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。  示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。  分析  一、由上到下给每一层遍历到的结点做上标记，如果在下一个结点中出现了这个标记，则表示存在环形结构。如果不想篡改原始数据，可以先用 temp 保存。  /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { while (head) { if (head.</description>
    </item>
    
    <item>
      <title>链表-leetCode-移除链表元素</title>
      <link>/2019/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</guid>
      <description>移除链表元素  删除链表中等于给定值 val 的所有节点。  示例: 输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5  分析 /** * @param {ListNode} head * @param {number} val * @return {ListNode} */ var removeElements = function(head, val) { let tem = head; let pre = null; while (tem) { if (tem.val === val) { if (pre) { pre.next = tem.next; } else { head = tem.next; } } else { pre = tem; } tem = tem.</description>
    </item>
    
    <item>
      <title>pm2</title>
      <link>/2019/pm2/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/pm2/</guid>
      <description>PM2 的安装提示处理 在本地安装 PM2 之后，可能会看到下面的这个提示，可以按照提示操作一下：
Since PM2’s deployment command runs on a non-interactive SSH connection, we need to resolve this by commenting out a few lines from the semaphoreci user’s ~/.bashrc file. We’re already logged in as this user on our droplet, so we simply need to open up this file and comment this out: Comment the following lines: #If not running interactively, don&#39;t do anything #case $- in # *i*) ;; # * return;; #esac and this in /etc/bash.</description>
    </item>
    
    <item>
      <title>安装与配置MongoDB数据库</title>
      <link>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEmongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>服务器系统为 Ubuntu 14.04
 mongodump 逻辑备份工具。 mongorestore 逻辑恢复工具。 mongoexport 数据导出工具。 mongoimport 数据导入工具。  可以使用 Navicat for MongoDB 来管理数据库
安装 MongoDB 并开启等命令  MongoDB社区安装   加入公钥 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 使用后面这个命令：sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10 为 MongoDB 创建一个列表文件，可以选择使用 Aliyun 的镜像文件 echo &amp;quot;deb [ arch=amd64 ] http://mirrors.aliyun.com/MongoDB/apt/ubuntu trusty/MongoDB-org/4.0 multiverse&amp;quot; | sudo tee /etc/apt/sources.list.d/MongoDB-org-4.0.list echo &#39;deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen&#39; | sudo tee /etc/apt/sources.list.d/mongodb.list 重新加载更新本地的包库 sudo apt-get update 安装 MongoDB 稳定版 sudo apt-get install -y MongoDB-org   在安装的时候有可能会遇到这个问题：定位不到本地的 MongoDB-org 的安装包，可能是因为我们使用的是阿里云的服务器，所以默认的是阿里云的源。可以先把阿里云的源屏蔽掉试一下:</description>
    </item>
    
    <item>
      <title>搭建 Node.js 与阿里云 Alinode 环境</title>
      <link>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%90%AD%E5%BB%BAnode.js%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91alinode%E7%8E%AF%E5%A2%83/</guid>
      <description>搭建 Node.js 环境 系统更新，安装基础包 sudo apt-get update sudo apt-get install vim openssl build-essential libssl-dev wget curl git  安装 node.js  使用 nvm 这个工具，方便升级和管理 node.js 版本 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 安装 node.js  nvm install v10.14.2 nvm use v10.14.2 nvm alias default v10.14.2 node -v v10.14.2  安装 阿里云的 alinode  或者可以直接安装阿里云的 alinode，这也是我推荐给大家的 Node，因为它对 Node 做了必要的定制，可以无缝接入到 alinode 的监控中心，对于 多机器多应用运维 非常有用。大家可以参考 alinode 安装文档  安装一些常用的全局工具包  可以配置一个简单的 registry 参数来指定使用国内的 taobao 镜像来下载： npm --registry=https://registry.</description>
    </item>
    
    <item>
      <title>配置Nginx反向代理Node.js端口</title>
      <link>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86node.js%E7%AB%AF%E5%8F%A3/</guid>
      <description>安装 sudo apt-get install nginx sudo vi /etc/nginx/sites-available/default   安装完毕后，检查下 Nginx 的版本：nginx -v。这个版本号通常可以在 Web 端的 header 里看到。安全起见，可以通过配置隐藏掉，如下打开 nginx.conf 文件：sudo vi /etc/nginx/nginx.conf，把nginx.conf 文件中的server_tokens on 改成 server_tokens off。  配置 Nginx 反向代理 Node.js 端口  我们的网站静态服务是跑在 4321 端口上的，直接通过 80 端口无法启动，原因是我们 rn_manager 下的 Node 并不具备 root 的运行权限，不能监听 0 ~ 1024 之间的端口，当然也包括 80 端口。通过 sudo 来强制启动 Node 服务也不是不可以，但是，这多少会带来一些额外的成本和风险：一是我们需要额外配置，二是需要放大 Node 程序的权限。
  用 ip 访问，使用 nginx，用 root 级的权限来启动对 80 端口的监听，同时把来自 80 端口的流量分配给 Node 服务的另外一个端口，实现这种服务的代理。   如果服务器只需放一个网站程序，那么解析网站到服务器网址，网站程序监听 80 端口即可。如果服务器有多个应用（你有多个网站），借助 Nginx 不仅可以实现端口代理，还可以实现负载均衡，由它来判断是来自哪个域名或 IP 的访问，从而根据配置的规则，将这个请求原封不动地转发给特定的端口或特定的某几台机器。在我们的这个案例中，就是把 80 端口的 IP 请求都转发到 Node.</description>
    </item>
    
    <item>
      <title>阿里云服务器相关</title>
      <link>/2019/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/</guid>
      <description>根据 慕课网 专栏 ‘一条龙的 Node·Vue·React 服务器部署’ 笔记。
购买  到阿里云官网购买一个服务器 配置相关信息 记录登录名 root 和 登录密码  使用 登录  通过 ssh 登录 例如：ssh root@116.62.201.97 后面会要求输入密码 可以通过 sudo lsb_release -a 来查看服务器版本 登录成功后可以首先运行 sudo apt-get update，作用是先把服务器上所有的包和源都 check 和更新一遍，让服务器处在一个崭新的状态 可以把一些常用的开发者套件先安装上 sudo apt-get install -y software-properties-common  添加一个用户  增加一个用户 adduser rn_manager，完成后记录住密码，赋予账号更高权限:可以在 visudo 权限配置文件配置一下:sudo visudo，加入 rn_manager ALL=(ALL:ALL) ALL 这行，然后可以重启 ssh 服务：service ssh restart  配置无密码登录 那么，首先来本地电脑上配置这把钥匙，而且要生成两把钥匙，分别是 私钥 和 公钥
 提示：如果你之前用过 GitHub 或者 GitLab 之类基于 Git 的仓库管理系统，那么你本地应该是配置过这个公钥和私钥的，这里要切记，不用再重复配置一遍了！不用重新配置一遍了！ 可能你会覆盖掉你本地用的钥匙，这样的话，你可能就连不上你之前有权限的 Git 仓库了，我会演示这一步。</description>
    </item>
    
    <item>
      <title>链表-leetCode-删除排序链表中的重复元素</title>
      <link>/2019/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid>
      <description>删除排序链表中的重复元素 描述 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1: 输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2 示例 2: 输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 输出: 1-&amp;gt;2-&amp;gt;3  分析 一、直接法
 仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。
 思路
 指定 cur 指针指向头部 head 当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了 当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果 如果不相等则 cur 移动到下一个位置继续循环 时间复杂度：O(n)O(n)   /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { let current = head; while (current !== null &amp;amp;&amp;amp; current.</description>
    </item>
    
    <item>
      <title>css3 适配iphoneX 安全区域</title>
      <link>/2019/%E9%80%82%E9%85%8Diphonex/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%80%82%E9%85%8Diphonex/</guid>
      <description>iphoneX 适配 第一步：设置网页在可视窗口的布局方式  ios11 引入 meta 标签的 viewpoint 扩展属性 viewpoint-fit，在 iOS 11 中 viewpoint-fit 也官方添加到 CSS Round Display 规范中了。 viewport-fit 有三个属性值：  Auto：默认值。这个值不影响初始布局视窗，整个 Web 页面是可视的。 Contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形。 Cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形。   所以我们可以通过 viewpoint-fit=cover 来解决问题，使页面内容跳出安全区域的框框。
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0,user-scalable=0,viewport-fit=cover&amp;quot;&amp;gt;  第二步：页面主体内容限定在安全区域内  IOS11 提供了两个个新的 css 变量 env(safe-area-inset-※) 和 constant(safe-area-inset-※) safe-area-inset-※ 提供了四个方向的值：
 safe-area-inset-top：在 Viewport 顶部的安全区域内设置量； safe-area-inset-bottom：在 Viewport 底部的安全区域内设置量； safe-area-inset-left：在 Viewport 左边的安全区域内设置量； safe-area-inset-right：在 Viewport 右边的安全区域内设置量；  constant() 和 env() 这个变量已经开始着手标准化，目前也可以被用在 margin、padding、top、bottom、left、right 等 css 属性中，同时在不支持的环境中将不会生效。而且，同样在 iOS 11 中，iPhone X 机型以下得到的值均为 0，iPhone X 得到其对应的设置量。</description>
    </item>
    
    <item>
      <title>typeof Vue/React</title>
      <link>/2019/typeof-vue-react/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/typeof-vue-react/</guid>
      <description> typeof Vue -&amp;gt; function typeof React -&amp;gt; object  </description>
    </item>
    
    <item>
      <title>数组降纬</title>
      <link>/2019/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BA%AC/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BA%AC/</guid>
      <description>第一种：将数组字符串话  利用数组与字符串的隐式转换，使用+符号链接一个对象，javascript会默认调用toString方法转为字符串，再使用字符串分割成字符串数组，最后转成数值形数组。
 let arr = [[222, 333, 444], [55, 66, 77], 11, ] arr += &#39;&#39;; arr = arr.split(&#39;,&#39;); arr = arr.map(item =&amp;gt; Number(item)); console.log(arr); // [222, 333, 444, 55, 66, 77, 11]  第二种：自定义函数 const reduceDimension = (arr) =&amp;gt; { let ret = []; let toArr = function(arr){ arr.forEach(function(item){ Array.isArray(item) ? toArr(item) : ret.push(item); }); } toArr(arr); return ret; } let arr = [[12], 4, [333, [4444, 5555]], [9, [111, 222]]];  第三种 ES6数组的扩展 Array.</description>
    </item>
    
    <item>
      <title>正则相关</title>
      <link>/2019/reg/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/reg/</guid>
      <description> 匹配类似 first-paint=4859.53ms&amp;amp;first-contentful-paint=4859.53ms 这种其中某个值 （first-paint=4859.53ms 中的 4859.53）&amp;mdash;&amp;gt; /(?&amp;lt;=first-paint=)[\d.]+/gi  </description>
    </item>
    
    <item>
      <title>组件设计</title>
      <link>/2019/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/</guid>
      <description> 根据 UI 划分组件层级  可以将组件当作一种函数或者是对象来考虑，根据*单一功能原则*来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。 可以尝试自下而上构建应用。 通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：  该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。   </description>
    </item>
    
    <item>
      <title>行内样式</title>
      <link>/2019/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/</guid>
      <description>行内元素 img 元素外面包裹住一个块元素，实现自适应，然后块元素底部会有留白，类似下面这样：  是因为行内元素有行高，可以设置为 display: block; 转换为块元素，或者设置 vertical-align: top，可以解决。</description>
    </item>
    
    <item>
      <title>.eslintrc.js配置详解</title>
      <link>/2019/eslintrc%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/eslintrc%E9%85%8D%E7%BD%AE/</guid>
      <description>{ &amp;quot;extends&amp;quot;: [ &amp;quot;alloy&amp;quot;, &amp;quot;alloy/react&amp;quot;, &amp;quot;alloy/typescript&amp;quot;, ], &amp;quot;env&amp;quot;: { &amp;quot;browser&amp;quot;: true, &amp;quot;node&amp;quot;: true, &amp;quot;commonjs&amp;quot;: true }, &amp;quot;globals&amp;quot;: { // 这里填入你的项目需要的全局变量 // false 表示这个全局变量不允许被重新赋值，比如： // // myGlobal: false }, &amp;quot;ecmaFeatures&amp;quot;: { // lambda表达式 &amp;quot;arrowFunctions&amp;quot;: true, // 解构赋值 &amp;quot;destructuring&amp;quot;: true, // class &amp;quot;classes&amp;quot;: true, // http://es6.ruanyifeng.com/#docs/function#函数参数的默认值 &amp;quot;defaultParams&amp;quot;: true, // 块级作用域，允许使用let const &amp;quot;blockBindings&amp;quot;: true, // 允许使用模块，模块内默认严格模式 &amp;quot;modules&amp;quot;: true, // 允许字面量定义对象时，用表达式做属性名 // http://es6.ruanyifeng.com/#docs/object#属性名表达式 &amp;quot;objectLiteralComputedProperties&amp;quot;: true, // 允许对象字面量方法名简写 /*var o = { method() { return &amp;quot;Hello!</description>
    </item>
    
    <item>
      <title>弹出遮照阻止底部页面滚动</title>
      <link>/2019/%E5%BC%B9%E5%87%BA%E9%81%AE%E7%85%A7%E9%98%BB%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%BC%B9%E5%87%BA%E9%81%AE%E7%85%A7%E9%98%BB%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</guid>
      <description> 代码如下： const bodyEl = document.body; let top = 0; /** * 阻止页面滚动 * @param {boolean} isFixed */ export function stopBodyScroll(isFixed: boolean) { if (isFixed) { top = window.scrollY; bodyEl.style.position = &#39;fixed&#39;; bodyEl.style.top = -top + &#39;px&#39;; } else { bodyEl.style.position = &#39;&#39;; bodyEl.style.top = &#39;&#39;; window.scrollTo(0, top); // 回到原先的top } }  </description>
    </item>
    
    <item>
      <title>Shadowsocks安装流程</title>
      <link>/2019/shadowsocks%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/shadowsocks%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/</guid>
      <description> 安装  wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh。注意 (warning) : 国外服务器运行脚本时容易出错，如出现错误提示 bash: wget: command not found，可以请在先执行 yum -y install wget 命令。成功后，再执行上面的命令。如果没有出现提示错误，请略过。 chmod +x shadowsocks-all.sh ./shadowsocks-all.sh 2&amp;gt;&amp;amp;1 | tee shadowsocks-all.log  </description>
    </item>
    
    <item>
      <title>ua检测</title>
      <link>/2019/ua%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/ua%E6%A3%80%E6%B5%8B/</guid>
      <description>代码如下： const userAgent = window.navigator.userAgent.toLowerCase(); export const uaJudge = { get isAndroid() { return /android|adr/gi.test(userAgent); }, get isVivo() { return /vivo/gi.test(userAgent); }, get isIos() { return /iphone|ipod|ipad/gi.test(userAgent); }, /** 微信（包含小程序） */ get isWeChat() { return /micromessenger/gi.test(userAgent); }, /** 微信小程序 */ get isWeChatMini() { if (this.isWeChat) { return new Promise((resolve, reject) =&amp;gt; { wx.miniProgram.getEnv((res: any) =&amp;gt; { resolve(res.miniprogram); }); setTimeout(resolve, 1000); }); } else { return Promise.resolve(false); } }, /** 支付宝 */ get isAlipay() { return /alipay/gi.</description>
    </item>
    
    <item>
      <title>获取元素content宽高</title>
      <link>/2019/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0content%E5%AE%BD%E9%AB%98/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0content%E5%AE%BD%E9%AB%98/</guid>
      <description>代码如下： /** * 获取元素content宽高 * @param el */ export function getContentSize(el: HTMLElement) { const width = el.offsetWidth; const height = el.offsetHeight; const style = window.getComputedStyle(el); // border const blw = parseFloat(style.borderLeftWidth || &#39;0&#39;); const brw = parseFloat(style.borderRightWidth || &#39;0&#39;); const btw = parseFloat(style.borderTopWidth || &#39;0&#39;); const bbw = parseFloat(style.borderBottomWidth || &#39;0&#39;); // padding const plw = parseFloat(style.paddingLeft || &#39;0&#39;); const prw = parseFloat(style.paddingRight || &#39;0&#39;); const ptw = parseFloat(style.paddingTop || &#39;0&#39;); const pbw = parseFloat(style.</description>
    </item>
    
    <item>
      <title>通过http链接加载script</title>
      <link>/2019/%E9%80%9A%E8%BF%87http%E9%93%BE%E6%8E%A5%E5%8A%A0%E8%BD%BDscript/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%80%9A%E8%BF%87http%E9%93%BE%E6%8E%A5%E5%8A%A0%E8%BD%BDscript/</guid>
      <description>function loadScript(src: string, async: boolean = true) { return new Promise((resolve, reject) =&amp;gt; { const script = document.createElement(&#39;script&#39;); async &amp;amp;&amp;amp; (script.async = true); script.onload = resolve; script.onerror = reject; script.src = src; document.body.appendChild(script); }); } // 注意：使用appendChild，不要使用append，ios9不支持append。  </description>
    </item>
    
    <item>
      <title>Webpack 优化相关</title>
      <link>/2019/webpack/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/webpack/</guid>
      <description>官网  Webpack 优化 构建过程提速策略 不要让 loader 做太多事情  以 babel-loader 为例：  babel-loader 无疑是强大的，但它也是慢的。
最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译，比如 webpack 官方在介绍 babel-loader 时给出的示例：
module: { rules: [ { test: /\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } } } ] }  除此之外，选择开启缓存将转译结果缓存至文件系统，只需要为 loader 增加相应的参数设定：
loader: &#39;babel-loader?cacheDirectory=true&#39;  抽离第三库  DllPlugin是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。  用 DllPlugin 处理文件，要分两步走：
 基于 dll 专属的配置文件，打包 dll 库 基于 webpack.</description>
    </item>
    
    <item>
      <title>localStorage 统一管理设置-增加时间</title>
      <link>/2018/local-stroge/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/local-stroge/</guid>
      <description>设置本地存储  function setStorage(key: string, value: any) { try { localStorage.setItem(key, JSON.stringify({ data: value, time: Date.now(), })); } catch { console.log(&#39;localStorage.setItem error&#39;); console.log(key, value); } }   获取本地存储  // 注意：stringify 会过滤掉undefined的值 function getStorage(key: string) { const result = localStorage.getItem(key); if (result) { try { const objRes = JSON.parse(result); return objRes; } catch (e) { console.log(&#39;JSON.parse error:&#39;, result); return result; } } else { return result; } }   删除本地存储  function removeStorage(key: string) { localStorage.</description>
    </item>
    
    <item>
      <title>Hapi</title>
      <link>/2018/hapi/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/hapi/</guid>
      <description>Hapi Hapi 相关使用总结  Hapi.js 是一个用来构建基于 Node.js 的应用和服务的富框架，使得开发者把重点放在便携可重用的应用逻辑而不是构建架构。内建输入验证、缓存、认证和其他 Web 应用开发常用的功能。  Hapi 框架模块接口文档  官网 Hapi-api  Supervisor / nodemon / PM2  有不少 Node.js 小工具能帮助我们监视代码的改动然后自动重启 Node.js 服务，好用的工具有 Supervisor / nodemon / PM2。  # 系统全局安装 supervisor $ npm i -g supervisor  目录结构 ├── config # 项目配置目录 | ├── index.js # 配置项目中的配置信息 ├── models # 数据库 model ├── node_modules # node.js 的依赖目录 ├── plugins # 插件目录 ├── routes # 路由目录 │ ├── hello-world.</description>
    </item>
    
    <item>
      <title>MySQL 使用</title>
      <link>/2018/mysql/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/mysql/</guid>
      <description>MySQL 在 cmder 上连接远程服务器 ssh root@**.**.**.*** 远程服务器地址IP root@**.**.**.***&#39;s password: *********** // [root@vultr ~]#  安装 mysql 我是在vultr上安装的，系统是CentOS 7，可以在网上找相关教程安装。
连接数据库 [root@vultr ~]# mysql -u root -p Enter password: **********  查看数据库 mysql&amp;gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | PRACTTEST | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.01 sec)  使用某个数据库 mysql&amp;gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed  查看表 mysql&amp;gt; show tables; +----------------------+ | Tables_in_PRACTTEST | +----------------------+ | DATA_PARICT | | _mysql_session_store | | pract_tbl | | transaction_tbl | | user | +----------------------+ 5 rows in set (0.</description>
    </item>
    
    <item>
      <title>MiniPrograms</title>
      <link>/2018/miniprograms/</link>
      <pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/miniprograms/</guid>
      <description>小程序相关 原生小程序 小程序支持分包加载  分包预下载  小程序转换为百度小程序  可以使用百度搬家工具进行转换 （不持支使用框架转换） ,wx2swanswan小程序搬家工具 (Node &amp;gt;= 8.0)  去掉小程序组件button默认样式  小程序中button组建有默认的点击效果，有border的话，需要去掉边框线的话需要这样写。  /* 去掉button默认边框线 */ button::after { border: 0; }  设置成禁用的话disable=&amp;quot;{{disable}}&amp;quot;,disable为 true 的话，点击按钮的时候还是有默认点击效果，如果需求需要去掉默认点击效果，就需要设置成行内样式来生效。
&amp;lt;!-- 行内样式 --&amp;gt; &amp;lt;button class=&amp;quot;get-code&amp;quot; size=&amp;quot;mini&amp;quot; bindtap=&amp;quot;getCode&amp;quot; disabled=&amp;quot;{{disabled}}&amp;quot; style=&amp;quot;color: #00a4ff; background-color: #fff;&amp;quot;&amp;gt;{{getCodeBtn}}&amp;lt;/button&amp;gt;  小程序限制  小程序背景图片不支持相对路径的图片路径，需要设置为绝对路径。 小程序现在默认上传包大小为2M（以后有可能变化），可以把图片资源单独打包成一个项目工程，然后在小程序中去引用图片的绝对路径。 小程序不支持table组件和标签，如果需要的话可用wxss(css)来写表格，然是涉及到表格跨行跨列的话不太好处理，可以换一种展现格式。简单来说就是小程序不支持复杂的表格。 小程序现在支持跳转外部url，需要使用web-view组建来实现，需要在微信公众平台登录，然后在设置里面&amp;ndash;&amp;gt;开发设置来绑定业务域名，并且在业务域名的跟目下放微信检验文件，只有放过之后，在域名跟目下能访问到这个检验文件，在绑定业务域名的时候才能绑定成功。   小程序使用 wx.request(OBJECT) 来发起请求时，需要在微信公众平台设置&amp;ndash;&amp;gt;开发设置里面设置服务器域名配置。   小程序不能操作BOM/DOM。 在 {{}} 模板语法里不持支复杂计算，具体看小程序文档。 小程序文字不能上下居中，尤其是在一个些小的按钮里边。 小程序 canvas 在真机中不支持base64，画不到canvas里面。 小程序获取用户授权之后再能通过 wx.getUserInfo 来获取用户信息，可以通过 button 来发起用户授权。  &amp;lt;button class=&amp;quot;{{isLog ?</description>
    </item>
    
    <item>
      <title>箭头函数this的指向</title>
      <link>/2018/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E6%8C%87%E5%90%91/</link>
      <pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E6%8C%87%E5%90%91/</guid>
      <description>箭头函数this的指向  介绍   箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。
 一、 何为定义时绑定（看下面的例子）
let x = 11; let obj = { x: 22, say: function () { console.log(this.x) } } obj.say() // 22  一般的定义函数跟我们的理解是一样的，运行的时候决定this的指向，我们可以知道当运行obj.say()时候，this指向的是obj这个对象。
let x = 11; let obj = { x: 22, say: () =&amp;gt; { console.log(this.x) } } obj.say() // 11  这个this指向的是外部的 x = 11。
所谓的定义时候绑定， *就是它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值*，比如这里的箭头函数中的this.x，箭头函数本身与say平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而obj的父执行上下文就是window，因此这里的this.x实际上表示的是window.x，因此输出的是11。(this只有在函数被调用，或者通过构造函数new Object()的形式才会有this)。
 类似的还有：  // 不使用箭头函数 let a = 11; function test () { this.</description>
    </item>
    
    <item>
      <title>ES6的一些方法和技巧</title>
      <link>/2018/es6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/es6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/</guid>
      <description>ES6的一些方法和技巧 声明变量 用let不用var ES6之前我们用var声明一个变量，但是它有很多弊病：
 因为没有块级作用域，很容易声明全局变量 变量提升 可以重复声明 还记得这道面试题吗？  var a = []; for (var i = 0; i &amp;lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 a[7](); // 10 a[8](); // 10 a[9](); // 10  所以要使用 let，可以避免 使用 var 来声明所带来的一些问题。
const 和 let const 和 let 的区别就是 使用 const 来声明的变量，称为 常量
 更好的代码语义化，哪个可以修改，哪个不可以修改等等 函数声明应该使用 const 来声明  字符串 不要使用 &amp;ldquo;双引号&amp;rdquo;，一律使用 &amp;lsquo;单引号&amp;rsquo; 或者 `模板字符串`</description>
    </item>
    
    <item>
      <title>EventLoop</title>
      <link>/2018/eventloop/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/eventloop/</guid>
      <description>Event Loop 参考资料：
JavaScript 运行机制详解：再谈Event Loop@阮一峰
8张图帮你一步步看清 async/await 和 promise 的执行顺序
进程与线程的一个简单解释
事件循环机制 线程与进程   进程：CPU资源分配的最小单位 线程：CPU调度的最小单位   浏览器打开即为打开一个进程（任务管理器查看），浏览器就是多进程、多线程的，浏览器打开后占用CPU的资源，可将这些资源分别分配给不同的tab页面进行并发处理，互不影响；如：一个浏览器打开多个窗口，多个窗口同时运行网页（浏览器中任务管理查看）
浏览器 浏览器进程 作为主进程，主要负责页面管理以及其他进程的创建及销毁，常驻的线程有：(工厂-&amp;gt; 部门)
手机工厂(浏览器)[进程] ↓ 造手机部 &amp;mdash;&amp;ndash; 造手机壳部 &amp;mdash;&amp;ndash; 造膜部等(tab页面)[进程] ↓ 各个岗位(html、css、js、事件触发等)[线程]
  GUI渲染线程  主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。（回流必将引起重绘，重绘不一定会引起回流） 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，JS引擎才会去执行 GUI 渲染。  JS引擎线程
 该线程当然是主要负责处理 JavaScript脚本，执行代码； 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并返回正确时，将依次进入任务队列，等待JS引擎线程的执行； 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。  事件触发线程  主要负责将准备好的事件交给Js引擎线程执行 比如setTimeout定时器计数结束，ajax等异步请求成功并出发回调函数，或者用户出发点击事件，该线程将会整装待发的事件依次加入到任务队列的队尾，等待Js引擎线程的执行  定时器触发线程  顾名思义，负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。  HTTP请求线程  顾名思义，负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。    多个线程之间配合工作，各司其职。</description>
    </item>
    
    <item>
      <title>js 调试相关</title>
      <link>/2018/debugs/</link>
      <pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/debugs/</guid>
      <description>Js调试命令 Console  Console 对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的。
 Console 对象可以在任何全局对象中访问，如 Window，WorkerGlobalScope 以及通过属性工作台提供的特殊定义。
 它被浏览器定义为 Window.Console，也可被简单的 Console 调用。  最常用的方法就是 console.log() 就是在控制台输出内容。console 对象还有除了 log 之外的其他方法。
注意：因为 Console 对象提供对浏览器控制台的接入 ，所以在不同浏览器中的支持以及表现方法可能不太一样，但是调试内容只有开发者会看，所以保证在开发环境用这些方法就可以。
分类输出  不同类别信息的输出。  console.log(&#39;文字信息&#39;); console.info(&#39;提示信息&#39;); console.warn(&#39;警告信息&#39;); console.error(&#39;错误信息&#39;);  分组输出  使用 Console.group()和 Console.groupEnd()包裹分组内容。 还可以使用 Console.groupCollapsed()来代替 Console.group()生成折叠的分组。  console.group(&#39;第一个组&#39;); console.log(&amp;quot;1-1&amp;quot;); console.log(&amp;quot;1-2&amp;quot;); console.log(&amp;quot;1-3&amp;quot;); console.groupEnd(); console.group(&#39;第二个组&#39;); console.log(&amp;quot;2-1&amp;quot;); console.log(&amp;quot;2-2&amp;quot;); console.log(&amp;quot;2-3&amp;quot;); console.groupEnd();  Console.group()还可以嵌套使用。
console.group(&#39;第一个组&#39;); console.group(&amp;quot;1-1&amp;quot;); console.group(&amp;quot;1-1-1&amp;quot;); console.log(&#39;内容&#39;); console.groupEnd(); console.groupEnd(); console.group(&amp;quot;1-2&amp;quot;); console.log(&#39;内容&#39;); console.log(&#39;内容&#39;); console.log(&#39;内容&#39;); console.groupEnd(); console.groupEnd(); console.groupCollapsed(&#39;第二个组&#39;); console.</description>
    </item>
    
    <item>
      <title>npm 镜像设置</title>
      <link>/2018/npm/</link>
      <pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/npm/</guid>
      <description> npm 镜像设置 npm config set registry https://registry.npm.taobao.org npm config set SASS_BINARY_SITE https://npm.taobao.org/mirrors/node-sass/  </description>
    </item>
    
    <item>
      <title>JS随笔</title>
      <link>/2018/js-essay/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/js-essay/</guid>
      <description>JS随笔 等待多好毫秒后执行后面代码 export const sleep = async (ms: number) =&amp;gt; { return new Promise((resolve) =&amp;gt; setTimeout(resolve, ms || 0)); };  点击按钮复制一个文本或者链接地址 &amp;lt;div id=&amp;quot;lalala&amp;quot;&amp;gt;www.baidu.com45646!!!!&amp;lt;/div&amp;gt; &amp;lt;button onclick=&amp;quot;but()&amp;quot;&amp;gt;点我&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function but () { var copyDOM = document.getElementById(&#39;lalala&#39;); var range = document.createRange(); // 选中需要复制的节点 range.selectNode(copyDOM); // 执行选中元素 window.getSelection().addRange(range); // 执行 copy 操作 var successful = document.execCommand(&#39;copy&#39;); try { var msg = successful ? &#39;successful&#39; : &#39;unsuccessful&#39;; console.log(&#39;copy is&#39; + msg); } catch(err) { console.</description>
    </item>
    
    <item>
      <title>Vue Plugins And Expansion</title>
      <link>/2017/vueplugins/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vueplugins/</guid>
      <description> Vue Plugins And Expansion(后台模板) 条形码 vue-barcode  地址：vue-barcode GitHub: https://github.com/fengyuanchen/vue-barcode
 全局使用方式：
  // main.js import VueBarcode from &#39;@chenfengyuan/vue-barcode&#39;; Vue.component(&#39;barcode&#39;, VueBarcode);  &amp;lt;barcode :value=qualityInfo.tyOrderCode :options=&amp;quot;{ displayValue: false }&amp;quot; id=&amp;quot;canves&amp;quot;&amp;gt;&amp;lt;/barcode&amp;gt;  vue图表-V-charts  V-charts 文档  vue后台管理模板  vue-element-admin  vant UI组件库  vant 使用 van-popup 来封装一个组件时，需要使用 :value=&amp;quot;value&amp;quot; 来绑定，避免使用 v-model 来绑定v-model，代码如下：  &amp;lt;!-- 可以查看 vue 文档 对 v-model 的解释 --&amp;gt; &amp;lt;van-popup :value=&amp;quot;isShowCash&amp;quot; @click-overlay=&amp;quot;closeCashPopup&amp;quot;&amp;gt; &amp;lt;!-- .... to do --&amp;gt; &amp;lt;/van-popup&amp;gt;  </description>
    </item>
    
    <item>
      <title>vue 相关问题</title>
      <link>/2017/workrelated/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/workrelated/</guid>
      <description>使用 keep-alive 来包裹路由后，某个页面需要动态的去除缓存 可以使用动态的:include=&amp;quot;calcInclude&amp;quot; 来对需要的缓存的页面进行修改，calcInclude需要使用计算属性。整个include使用数组来储存*string[]*，数据可放到全局 store 中，通过 commit去修改，在需要的地方去更改。
&amp;lt;keep-alive :include=&amp;quot;calcInclude&amp;quot;&amp;gt; &amp;lt;router-view /&amp;gt; &amp;lt;/keep-alive&amp;gt;  get calcInclude() { return this.$store.state.includes; } const store = { state: { includes: [&#39;...&#39;}, }, } const mutations = { changeIncludes(state: State, obj: any) { const name = obj.name; const channel = obj.channel; const ind = state.includes.indexOf(name); if (ind &amp;gt; -1 &amp;amp;&amp;amp; channel === &#39;remove&#39;) { state.includes.splice(ind, 1); } else if (channel === &#39;add&#39;) { state.</description>
    </item>
    
    <item>
      <title>Vue watch选项</title>
      <link>/2017/vue-watch/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vue-watch/</guid>
      <description>Vue watch选项  watch 的用法
 watch 对象里的 value 是对应的回调函数
  data () { return { a: 1 } }, watch: { a: function (newVal, oldVal) { console.log(newVal, oldVal) // 2 1 } }, created () { this.a = 2 }   value 也可以是方法名  data () { return { a: 1 } }, watch: { a: &#39;foo&#39; }, created () { this.a = 2 }, methods: { foo (newVal, oldVal) { console.</description>
    </item>
    
    <item>
      <title>Vue配置相关</title>
      <link>/2017/vue/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vue/</guid>
      <description>Vue配置相关 代理配置 module.exports = { ........, dev: { // 开发环境配置 env: require(&#39;./dev.env&#39;), // 使用 config/dev.env.js 中定义的编译环境 port: 8686, // 运行测试页面的端口号 autoOpenBrowser: true, assetsSubDirectory: &#39;static&#39;, // 编译输出的二级目录 assetsPublicPath: &#39;/&#39;, // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 // 需要 proxyTable 代理的接口（可跨域） proxyTable: { &#39;**&#39;: { target: &#39;https://xxxxxxx&#39;, changeOrigin: true, filter: function (pathname, req) { // 接口地址 /******-server/****/****** return pathname.match(&#39;^\/.+-server.*&#39;) } } }, cssSourceMap: false } }  多入口配置 /* utils.js */ const path = require(&#39;path&#39;); // glob 是 webpack 安装时依赖的一个第三方模块，还模块允许你使用 * 等符号, // 例如 lib/*.</description>
    </item>
    
    <item>
      <title>vue中盲点</title>
      <link>/2017/vue-blind-spot/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/vue-blind-spot/</guid>
      <description>vue中盲点 使用 performance 开启性能追踪  performance API 是 Vue 全局配置 API 中的一个，我们可以使用它来进行网页性能的追踪，我们可以在入口文件中添加：  if (process.env.NODE_ENV !== &#39;production&#39;) { Vue.config.performance = true; }  来开启这一功能，该 API（2.2.0 新增）功能只适用于开发模式和支持 performance.mark API 的浏览器上，开启后我们可以下载 Vue Performance Devtool 这一 chrome 插件来看查看各个组件的加载情况，如图：
从中我们可以清晰的看到页面组件在每个阶段的耗时情况，而针对耗时比较久的组件，我们便可以对其进行相应优化。
而其在 Vue 源码中主要使用了 window.performance 来获取网页性能数据，其中包含了 performance.mark 和 performance.measure。
 performance.mark 主要用于创建标记 performance.measure 主要用于记录两个标记的时间间隔  例如：
performance.mark(&#39;start&#39;); // 创建 start 标记 performance.mark(&#39;end&#39;); // 创建 end 标记 performance.measure(&#39;output&#39;, &#39;start&#39;, &#39;end&#39;); // 计算两者时间间隔 performance.getEntriesByName(&#39;output&#39;); // 获取标记，返回值是一个数组，包含了间隔时间数据  熟练的使用 performance 我们可以查看并分析网页的很多数据，为我们项目优化提供保障。</description>
    </item>
    
    <item>
      <title>HTTP Status code（状态码）和 Status text（状态文本）(简单随笔)</title>
      <link>/2017/httpstatus/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/httpstatus/</guid>
      <description>常见的状态码  1xx：临时回应，表示客户端请继续。 2xx：请求成功：  200：请求成功。  3xx: 表示请求的目标有变化，希望客户端进一步处理：  301&amp;amp;302：永久性与临时性跳转。 304：客户端缓存没有更新。  4xx：客户端请求错误：  403：无权限。 404：表示请求的页面不存在。 418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）  5xx：服务端请求错误：  500：服务端错误。 503：服务端暂时性错误，可以一会再试。   对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。
2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。
3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。
304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。</description>
    </item>
    
    <item>
      <title>JS 模板</title>
      <link>/2017/template/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/template/</guid>
      <description> JS 模板 Juicer  GitHub  Soda  官方文档 GitHub  </description>
    </item>
    
    <item>
      <title>debugTools</title>
      <link>/2017/debugtools/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/debugtools/</guid>
      <description>抓包调试工具 Fidder的使用  下载地址  Fidder简介  抓包工具有很多，小到最常用的web调试工具firebug，达到通用的强大的抓包工具wireshark.为什么使用fiddler?原因如下： &amp;gt; a.Firebug虽然可以抓包，但是对于分析http请求的详细信息，不够强大。模拟http请求的功能也不够，且firebug常常是需要“无刷新修改”，如果刷新了页面，所有的修改都不会保存。 &amp;gt; b.Wireshark是通用的抓包工具，但是比较庞大，对于只需要抓取http请求的应用来说，似乎有些大材小用。 &amp;gt; c.Httpwatch也是比较常用的http抓包工具，但是只支持IE和firefox浏览器（其他浏览器可能会有相应的插件），对于想要调试chrome浏览器的http请求，似乎稍显无力，而Fiddler 是一个使用本地 127.0.0.1:8888 的 HTTP 代理，任何能够设置 HTTP 代理为 127.0.0.1:8888 的浏览器和应用程序都可以使用 Fiddler。
 对手机抓包  Tools &amp;gt; Options &amp;gt; https 勾选图中红线框出来的，之后会有弹窗提示安装证书。   Tools &amp;gt; Options &amp;gt; connections 勾选图中的   在手机上连接跟电脑在同一局域网下的网络，然后在无线网络中去设置代理，代理地址就是电脑ip地址和 端口号，之后在手机浏览器中输入 电脑ip地址和端口号 进行访问，会出下如下图，然后点击图中框出来的文字，下载并且安装证书。ios 比 安卓再多一个步骤，需要去 设置-&amp;gt;通用-&amp;gt;关于本机-&amp;gt;证书信任设置 去信任证书才可以进行抓包。  在电脑上对浏览器进行抓包  可以在浏览器设置里面设置代理，或者安装 Proxy SwitchyOmega 这个插件来管理代理，代理协议为 http，代理服务器为 127.0.0.1，端口号是在 fidder 上设置的端口号。  可以对fidder自定义规则(Rules -&amp;gt; Customize Rules)  下列设置中只能有一个OnBeforeResponse和OnBeforeResponse，下面只是为了方便演示代码位置才写了多个</description>
    </item>
    
    <item>
      <title>git commit emoji 使用指南</title>
      <link>/2017/git-commit-emoji/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/git-commit-emoji/</guid>
      <description>git commit emoji 使用指南 目录  commit 格式 emoji 指南 如何在命令行中显示 emoji 参考  git commit emoji write a good commit message   执行 git commit 时使用 emoji 为本次提交打上一个 &amp;ldquo;标签&amp;rdquo;, 使得此次 commit 的主要工作得以凸现，也能够使得其在整个提交历史中易于区分与查找。
截取的 gitmoji 快照:
commit 格式 git commit 时，提交信息遵循以下格式：
:emoji1: :emoji2: 不超过 50 个字的摘要，首字母大写，使用祈使语气，句末不要加句号 提交信息主体 引用相关 issue 或 PR 编号 &amp;lt;#110&amp;gt;  初次提交示例：
git commit -m &amp;quot;🎉 Initialize Repo&amp;quot;  emoji 指南    emoji emoji 代码 commit 说明     🎉 (庆祝) tada 初次提交   ✨ (火花) sparkles 引入新功能   🔖 (书签) bookmark 发行/版本标签   🐛 (bug) bug 修复 bug   🚑 (急救车) ambulance 重要补丁   🌐 (地球) globe_with_meridians 国际化与本地化   💄 (口红) lipstick 更新 UI 和样式文件   🚨 (警车灯) rotating_light 移除 linter 警告   🔧 (扳手) wrench 修改配置文件   ➕ (加号) heavy_plus_sign 增加一个依赖   ➖ (减号) heavy_minus_sign: 减少一个依赖   ⬆️ (上升箭头) arrow_up 升级依赖   ⬇️ (下降箭头) arrow_down 降级依赖   ⚡️ (闪电)</description>
    </item>
    
    <item>
      <title>git 相关总结</title>
      <link>/2017/git-summary/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/git-summary/</guid>
      <description>关于git的总结 git工作流 git相关  git 提交规范 git 简明指南 git 在线教程 git pro 中文教程
 Commitizen是一个撰写合格 Commit message 的工具。
  1.安装命令如下:
npm install -g commitizen  2.然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式
commitizen init cz-conventional-changelog --save --save-exact  3.以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message
 更多关于Commit message 和 Change log 编写指南可以到Commit message 和 Change log 编写指南查看&amp;hellip;  git操作 合并某个分支上的文件到应一个分支、回退到某个版本和 远程服务器上面回退到某个版本  git 合并某个分支上的文件到另一个分支上git checkout branch &amp;lt;path&amp;gt; git 本地回退到某个版本
git reset --hard 23bc94cf7e3c74c33dd4575dfbf72d6647333795   git 远程服务器上面回退到某个版本</description>
    </item>
    
    <item>
      <title>gulp 配置</title>
      <link>/2017/gulp/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/gulp/</guid>
      <description>项目中 gulp 的配置 项目目录结构 . ├── dist // 打包后的文件 ├── node_modules // 依赖模块 ├── src // 具体页面 | ├── namePage | ├── img // 图片 | └── xxx.png | ├── js // js文件 | └── xxx.js | ├── pages // 页面 | └── xxx.html | ├── sass // sass文件 | └── xxx.scss | └── sprite // 需要合成雪碧图的文件 | └── namePage | ├── img // 图片 | └── xxx.png | ├── js // js文件 | └── xxx.</description>
    </item>
    
    <item>
      <title>leetCode Easy One</title>
      <link>/2017/leetcode-easy/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/leetcode-easy/</guid>
      <description>Two Sum 两数之和(1)  给定一个整数数组，返回两个数字的索引，使它们相加到特定目标。您可以假设每个输入只有一个解决方案，并且您可能不会两次使用相同的元素。 例子：   Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].   解:  /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { // 第一种 let map = new Map() for (let i = 0; i &amp;lt; nums.length; i++) { if (map.</description>
    </item>
    
    <item>
      <title>leetCode Medium</title>
      <link>/2017/leetcode-medium/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/leetcode-medium/</guid>
      <description>Add Two Numbers 两数相加(2)  给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
 例子:
  Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807   解:  // 单链表的定义 function ListNode(val) { this.val = val; this.next = null; } // 第一种 /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { if (l1===null) return l2; if (l2===null) return l1; //new a ListNode here, with head.</description>
    </item>
    
    <item>
      <title>text-decoration 文本修饰</title>
      <link>/2017/%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/</guid>
      <description> 项目使用是用来 做下划线等，例如减免邮费等。如果在父元素上设置值为line-through，然后字元素有多个，font-size相同的情况下样式正确，font-size不同的情况下，会找自身元素的中间位置添加下划线。 text-decoration 属性规定添加到文本的修饰。 修饰的颜色由 &amp;ldquo;color&amp;rdquo; 属性设置。  h1 {text-decoration:overline} h2 {text-decoration:line-through} h3 {text-decoration:underline} h4 {text-decoration:blink}   可能的值  none	#默认。定义标准的文本。 underline	#定义文本下的一条线。 overline	#定义文本上的一条线。 line-through	#定义穿过文本下的一条线。 blink	#定义闪烁的文本。 inherit	#规定应该从父元素继承 text-decoration 属性的值。  </description>
    </item>
    
    <item>
      <title>常用工具集合</title>
      <link>/2017/tools/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/tools/</guid>
      <description> Docsify  一个神奇的文档网站生成工具 GitHub  Clover  Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。
 Everything  Everything 是 Windows 全局文件、文件夹 搜索软件。
 YoMail  YoMail 支持 Markdown 语法的邮箱客户端。
 PxCook  PxCook UI自动标注，生成前端css代码等。
 Imagine  Imagine 开源的 PNG/JPEG 压缩工具。
 Eruda  Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。
 vConsole  vConsole 是一个轻量、可拓展、针对手机网页的前端开发者调试面板。
 Weinre  Weinre 基于node平台 的远程运行调试web页面工具。官网。
 </description>
    </item>
    
    <item>
      <title>node版本管理</title>
      <link>/2017/node-version/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/node-version/</guid>
      <description>node版本管理 nvm 和 n  nvm
 Node版本管理器&amp;ndash;nvm，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件,可以在 windows 系统上使用 https://github.com/coreybutler/nvm-windows
 n
 这意味着，我们在使用 n 管理 node 版本前，首先需要一个 node 环境。我们或者用 Homebrew 来安装一个 node，或者从官网下载 pkg 来安装，总之我们得先自己装一个 node —— n 本身是没法给你装的。
然后我们可以使用 n 来安装不同版本的 node。
在安装的时候，n 会先将指定版本的 node 存储下来，然后将其复制到我们熟知的路径 /usr/local/bin，非常简单明了。当然由于 n 会操作到非用户目录，所以需要加 sudo 来执行命令。
所以这样看来，n 在其实现上是一个非常易理解的方案
https://github.com/tj/n
因为我的电脑是 windows 系统，所以使用的是 nvm for windows
nvm for windows  下载地址： https://github.com/coreybutler/nvm-windows/releases   nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置 nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便 Source code(zip)：zip压缩的源码 Sourc code(tar.</description>
    </item>
    
  </channel>
</rss>