<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Magic</title>
    <link>http://192.168.31.10:8000/posts/</link>
    <description>Recent content in Posts on Magic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 01 Jan 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://192.168.31.10:8000/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Webpack 优化相关</title>
      <link>http://192.168.31.10:8000/2019/webpack/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2019/webpack/</guid>
      <description>官网  Webpack 优化 构建过程提速策略 不要让 loader 做太多事情  以 babel-loader 为例：  babel-loader 无疑是强大的，但它也是慢的。
最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译，比如 webpack 官方在介绍 babel-loader 时给出的示例：
module: { rules: [ { test: /\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } } } ] }  除此之外，选择开启缓存将转译结果缓存至文件系统，只需要为 loader 增加相应的参数设定：
loader: &#39;babel-loader?cacheDirectory=true&#39;  抽离第三库  DllPlugin是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。  用 DllPlugin 处理文件，要分两步走：
 基于 dll 专属的配置文件，打包 dll 库 基于 webpack.</description>
    </item>
    
    <item>
      <title>Docker 相关</title>
      <link>http://192.168.31.10:8000/2018/docker/</link>
      <pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/docker/</guid>
      <description> Docker 相关 搭建 gitLab 搜索镜像 docker search gitlab-ce  查看镜像 docker images  </description>
    </item>
    
    <item>
      <title>Hapi</title>
      <link>http://192.168.31.10:8000/2018/hapi/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/hapi/</guid>
      <description>Hapi Hapi 相关使用总结  Hapi.js 是一个用来构建基于 Node.js 的应用和服务的富框架，使得开发者把重点放在便携可重用的应用逻辑而不是构建架构。内建输入验证、缓存、认证和其他 Web 应用开发常用的功能。  Hapi 框架模块接口文档  官网 Hapi-api  Supervisor / nodemon / PM2  有不少 Node.js 小工具能帮助我们监视代码的改动然后自动重启 Node.js 服务，好用的工具有 Supervisor / nodemon / PM2。  # 系统全局安装 supervisor $ npm i -g supervisor  目录结构 ├── config # 项目配置目录 | ├── index.js # 配置项目中的配置信息 ├── models # 数据库 model ├── node_modules # node.js 的依赖目录 ├── plugins # 插件目录 ├── routes # 路由目录 │ ├── hello-world.</description>
    </item>
    
    <item>
      <title>MySQL 使用</title>
      <link>http://192.168.31.10:8000/2018/mysql/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/mysql/</guid>
      <description>MySQL 在 cmder 上连接远程服务器 ssh root@**.**.**.*** 远程服务器地址IP root@**.**.**.***&#39;s password: *********** // [root@vultr ~]#  安装 mysql 我是在vultr上安装的，系统是CentOS 7，可以在网上找相关教程安装。
连接数据库 [root@vultr ~]# mysql -u root -p Enter password: **********  查看数据库 mysql&amp;gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | PRACTTEST | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.01 sec)  使用某个数据库 mysql&amp;gt; use information_schema; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed  查看表 mysql&amp;gt; show tables; +----------------------+ | Tables_in_PRACTTEST | +----------------------+ | DATA_PARICT | | _mysql_session_store | | pract_tbl | | transaction_tbl | | user | +----------------------+ 5 rows in set (0.</description>
    </item>
    
    <item>
      <title>MiniPrograms</title>
      <link>http://192.168.31.10:8000/2018/miniprograms/</link>
      <pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/miniprograms/</guid>
      <description>小程序相关 原生小程序 小程序支持分包加载  分包预下载  小程序转换为百度小程序  可以使用百度搬家工具进行转换 （不持支使用框架转换） ,wx2swanswan小程序搬家工具 (Node &amp;gt;= 8.0)  去掉小程序组件button默认样式  小程序中button组建有默认的点击效果，有border的话，需要去掉边框线的话需要这样写。  /* 去掉button默认边框线 */ button::after { border: 0; }  设置成禁用的话disable=&amp;quot;{{disable}}&amp;quot;,disable为 true 的话，点击按钮的时候还是有默认点击效果，如果需求需要去掉默认点击效果，就需要设置成行内样式来生效。
&amp;lt;!-- 行内样式 --&amp;gt; &amp;lt;button class=&amp;quot;get-code&amp;quot; size=&amp;quot;mini&amp;quot; bindtap=&amp;quot;getCode&amp;quot; disabled=&amp;quot;{{disabled}}&amp;quot; style=&amp;quot;color: #00a4ff; background-color: #fff;&amp;quot;&amp;gt;{{getCodeBtn}}&amp;lt;/button&amp;gt;  小程序限制  小程序背景图片不支持相对路径的图片路径，需要设置为绝对路径。 小程序现在默认上传包大小为2M（以后有可能变化），可以把图片资源单独打包成一个项目工程，然后在小程序中去引用图片的绝对路径。 小程序不支持table组件和标签，如果需要的话可用wxss(css)来写表格，然是涉及到表格跨行跨列的话不太好处理，可以换一种展现格式。简单来说就是小程序不支持复杂的表格。 小程序现在支持跳转外部url，需要使用web-view组建来实现，需要在微信公众平台登录，然后在设置里面&amp;ndash;&amp;gt;开发设置来绑定业务域名，并且在业务域名的跟目下放微信检验文件，只有放过之后，在域名跟目下能访问到这个检验文件，在绑定业务域名的时候才能绑定成功。   小程序使用 wx.request(OBJECT) 来发起请求时，需要在微信公众平台设置&amp;ndash;&amp;gt;开发设置里面设置服务器域名配置。   小程序不能操作BOM/DOM。 在 {{}} 模板语法里不持支复杂计算，具体看小程序文档。 小程序文字不能上下居中，尤其是在一个些小的按钮里边。 小程序 canvas 在真机中不支持base64，画不到canvas里面。 小程序获取用户授权之后再能通过 wx.getUserInfo 来获取用户信息，可以通过 button 来发起用户授权。  &amp;lt;button class=&amp;quot;{{isLog ?</description>
    </item>
    
    <item>
      <title>箭头函数this的指向</title>
      <link>http://192.168.31.10:8000/2018/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E6%8C%87%E5%90%91/</link>
      <pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E7%9A%84%E6%8C%87%E5%90%91/</guid>
      <description>箭头函数this的指向  介绍   箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。
 一、 何为定义时绑定（看下面的例子）
let x = 11; let obj = { x: 22, say: function () { console.log(this.x) } } obj.say() // 22  一般的定义函数跟我们的理解是一样的，运行的时候决定this的指向，我们可以知道当运行obj.say()时候，this指向的是obj这个对象。
let x = 11; let obj = { x: 22, say: () =&amp;gt; { console.log(this.x) } } obj.say() // 11  这个this指向的是外部的 x = 11。
所谓的定义时候绑定， *就是它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值*，比如这里的箭头函数中的this.x，箭头函数本身与say平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而obj的父执行上下文就是window，因此这里的this.x实际上表示的是window.x，因此输出的是11。(this只有在函数被调用，或者通过构造函数new Object()的形式才会有this)。
 类似的还有：  // 不使用箭头函数 let a = 11; function test () { this.</description>
    </item>
    
    <item>
      <title>ES6的一些方法和技巧</title>
      <link>http://192.168.31.10:8000/2018/es6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/es6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/</guid>
      <description>ES6的一些方法和技巧 声明变量 用let不用var ES6之前我们用var声明一个变量，但是它有很多弊病：
 因为没有块级作用域，很容易声明全局变量 变量提升 可以重复声明 还记得这道面试题吗？  var a = []; for (var i = 0; i &amp;lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 a[7](); // 10 a[8](); // 10 a[9](); // 10  所以要使用 let，可以避免 使用 var 来声明所带来的一些问题。
const 和 let const 和 let 的区别就是 使用 const 来声明的变量，称为 常量
 更好的代码语义化，哪个可以修改，哪个不可以修改等等 函数声明应该使用 const 来声明  字符串 不要使用 &amp;ldquo;双引号&amp;rdquo;，一律使用 &amp;lsquo;单引号&amp;rsquo; 或者 `模板字符串`</description>
    </item>
    
    <item>
      <title>EventLoop</title>
      <link>http://192.168.31.10:8000/2018/eventloop/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/eventloop/</guid>
      <description>Event Loop 事件循环机制 线程与进程   进程：CPU资源分配的最小单位 线程：CPU调度的最小单位   浏览器打开即为打开一个进程（任务管理器查看），浏览器就是多进程、多线程的，浏览器打开后占用CPU的资源，可将这些资源分别分配给不同的tab页面进行并发处理，互不影响；如：一个浏览器打开多个窗口，多个窗口同时运行网页（浏览器中任务管理查看）
浏览器进程 作为主进程，主要负责页面管理以及其他进程的创建及销毁，常驻的线程有：(工厂-&amp;gt; 部门)
手机工厂(浏览器)[进程] ↓ 造手机部 &amp;mdash;&amp;ndash; 造手机壳部 &amp;mdash;&amp;ndash; 造膜部等(tab页面)[进程] ↓ 各个岗位(html、css、js、事件触发等)[线程]
  GUI渲染线程  主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，JS引擎才会去执行 GUI 渲染。  JS引擎线程
 该线程当然是主要负责处理 JavaScript脚本，执行代码； 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并返回正确时，将依次进入任务队列，等待JS引擎线程的执行； 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。  事件触发线程  主要负责将准备好的事件交给Js引擎线程执行 比如setTimeout定时器计数结束，ajax等异步请求成功并出发回调函数，或者用户出发点击事件，该线程将会整装待发的事件依次加入到任务队列的队尾，等待Js引擎线程的执行  定时器触发线程  顾名思义，负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。  HTTP请求线程  顾名思义，负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。    多个线程之间配合工作，各司其职。
Render 进程  浏览器渲染进程（浏览器内核），主要负责页面的渲染、JS执行以及事件的循环。 (render给与，表达 总经办 -&amp;gt; 分管各个部门的副经理)</description>
    </item>
    
    <item>
      <title>js 调试相关</title>
      <link>http://192.168.31.10:8000/2018/debugs/</link>
      <pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/debugs/</guid>
      <description>Js调试命令 Console  Console 对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的。
 Console 对象可以在任何全局对象中访问，如 Window，WorkerGlobalScope 以及通过属性工作台提供的特殊定义。
 它被浏览器定义为 Window.Console，也可被简单的 Console 调用。  最常用的方法就是 console.log() 就是在控制台输出内容。console 对象还有除了 log 之外的其他方法。
注意：因为 Console 对象提供对浏览器控制台的接入 ，所以在不同浏览器中的支持以及表现方法可能不太一样，但是调试内容只有开发者会看，所以保证在开发环境用这些方法就可以。
分类输出  不同类别信息的输出。  console.log(&#39;文字信息&#39;); console.info(&#39;提示信息&#39;); console.warn(&#39;警告信息&#39;); console.error(&#39;错误信息&#39;);  分组输出  使用 Console.group()和 Console.groupEnd()包裹分组内容。 还可以使用 Console.groupCollapsed()来代替 Console.group()生成折叠的分组。  console.group(&#39;第一个组&#39;); console.log(&amp;quot;1-1&amp;quot;); console.log(&amp;quot;1-2&amp;quot;); console.log(&amp;quot;1-3&amp;quot;); console.groupEnd(); console.group(&#39;第二个组&#39;); console.log(&amp;quot;2-1&amp;quot;); console.log(&amp;quot;2-2&amp;quot;); console.log(&amp;quot;2-3&amp;quot;); console.groupEnd();  Console.group()还可以嵌套使用。
console.group(&#39;第一个组&#39;); console.group(&amp;quot;1-1&amp;quot;); console.group(&amp;quot;1-1-1&amp;quot;); console.log(&#39;内容&#39;); console.groupEnd(); console.groupEnd(); console.group(&amp;quot;1-2&amp;quot;); console.log(&#39;内容&#39;); console.log(&#39;内容&#39;); console.log(&#39;内容&#39;); console.groupEnd(); console.groupEnd(); console.groupCollapsed(&#39;第二个组&#39;); console.</description>
    </item>
    
    <item>
      <title>npm 镜像设置</title>
      <link>http://192.168.31.10:8000/2018/npm/</link>
      <pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/npm/</guid>
      <description> npm 镜像设置 npm config set registry https://registry.npm.taobao.org npm config set SASS_BINARY_SITE https://npm.taobao.org/mirrors/node-sass/  </description>
    </item>
    
    <item>
      <title>JS随笔</title>
      <link>http://192.168.31.10:8000/2018/js-essay/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2018/js-essay/</guid>
      <description>JS随笔 点击按钮复制一个文本或者链接地址 &amp;lt;div id=&amp;quot;lalala&amp;quot;&amp;gt;www.baidu.com45646!!!!&amp;lt;/div&amp;gt; &amp;lt;button onclick=&amp;quot;but()&amp;quot;&amp;gt;点我&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function but () { var copyDOM = document.getElementById(&#39;lalala&#39;); var range = document.createRange(); // 选中需要复制的节点 range.selectNode(copyDOM); // 执行选中元素 window.getSelection().addRange(range); // 执行 copy 操作 var successful = document.execCommand(&#39;copy&#39;); try { var msg = successful ? &#39;successful&#39; : &#39;unsuccessful&#39;; console.log(&#39;copy is&#39; + msg); } catch(err) { console.log(&#39;Oops, unable to copy&#39;); } // 移除选中的元素 window.getSelection().removeAllRanges(); return false } &amp;lt;/script&amp;gt;  (a == 1 &amp;amp;&amp;amp; a== 2 &amp;amp;&amp;amp; a == 3) 有可能是 true 吗？  第一种解法:  const a = { i: 0, toString: function() { return a.</description>
    </item>
    
    <item>
      <title>Vue Plugins And Expansion</title>
      <link>http://192.168.31.10:8000/2017/vueplugins/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/vueplugins/</guid>
      <description> Vue Plugins And Expansion(后台模板) 条形码 vue-barcode  地址：vue-barcode GitHub: https://github.com/fengyuanchen/vue-barcode
 全局使用方式：
  // main.js import VueBarcode from &#39;@chenfengyuan/vue-barcode&#39;; Vue.component(&#39;barcode&#39;, VueBarcode);  &amp;lt;barcode :value=qualityInfo.tyOrderCode :options=&amp;quot;{ displayValue: false }&amp;quot; id=&amp;quot;canves&amp;quot;&amp;gt;&amp;lt;/barcode&amp;gt;  vue图表-V-charts  V-charts 文档  vue后台管理模板  vue-element-admin  </description>
    </item>
    
    <item>
      <title>vue 相关问题</title>
      <link>http://192.168.31.10:8000/2017/workrelated/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/workrelated/</guid>
      <description>使用vuex状态管理后，在 input 中使用 v-model 来进行双向数据绑定，在修改 input 中值的时候会抛出一个错误  可以不使用 v-model 来进行双向数据绑定，使用 :value=&amp;rsquo; &amp;lsquo; 来，然后设置一个 监听器来推动 state 的更新( @input=&amp;rsquo; &amp;lsquo; )
vue 模板
 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;quot;hello&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;text&amp;quot; :value=&amp;quot;text&amp;quot; @input=&#39;update&#39;&amp;gt; &amp;lt;span&amp;gt;{{ddd}}&amp;lt;/span&amp;gt; &amp;lt;p ref=&amp;quot;ppp&amp;quot;&amp;gt;啦啦啦&amp;lt;/p&amp;gt; &amp;lt;input type=&amp;quot;text&amp;quot; v-focus&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import {mapState} from &#39;vuex&#39; export default { name: &#39;HelloWorld&#39;, data () { return { ddd: &#39;&#39; } }, computed: { ...mapState([&#39;text&#39;]) }, methods: { update (e) { // 在这里来 更新 state 里的某一个值 this.</description>
    </item>
    
    <item>
      <title>Vue watch选项</title>
      <link>http://192.168.31.10:8000/2017/vue-watch/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/vue-watch/</guid>
      <description>Vue watch选项  watch 的用法
 watch 对象里的 value 是对应的回调函数
  data () { return { a: 1 } }, watch: { a: function (newVal, oldVal) { console.log(newVal, oldVal) // 2 1 } }, created () { this.a = 2 }   value 也可以是方法名  data () { return { a: 1 } }, watch: { a: &#39;foo&#39; }, created () { this.a = 2 }, methods: { foo (newVal, oldVal) { console.</description>
    </item>
    
    <item>
      <title>Vue配置相关</title>
      <link>http://192.168.31.10:8000/2017/vue/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/vue/</guid>
      <description>Vue配置相关 代理配置 module.exports = { ........, dev: { // 开发环境配置 env: require(&#39;./dev.env&#39;), // 使用 config/dev.env.js 中定义的编译环境 port: 8686, // 运行测试页面的端口号 autoOpenBrowser: true, assetsSubDirectory: &#39;static&#39;, // 编译输出的二级目录 assetsPublicPath: &#39;/&#39;, // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 // 需要 proxyTable 代理的接口（可跨域） proxyTable: { &#39;**&#39;: { target: &#39;https://xxxxxxx&#39;, changeOrigin: true, filter: function (pathname, req) { // 接口地址 /******-server/****/****** return pathname.match(&#39;^\/.+-server.*&#39;) } } }, cssSourceMap: false } }  多入口配置 /* utils.js */ const path = require(&#39;path&#39;); // glob 是 webpack 安装时依赖的一个第三方模块，还模块允许你使用 * 等符号, // 例如 lib/*.</description>
    </item>
    
    <item>
      <title>vue中盲点</title>
      <link>http://192.168.31.10:8000/2017/vue-blind-spot/</link>
      <pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/vue-blind-spot/</guid>
      <description>vue中盲点 使用 performance 开启性能追踪  performance API 是 Vue 全局配置 API 中的一个，我们可以使用它来进行网页性能的追踪，我们可以在入口文件中添加：  if (process.env.NODE_ENV !== &#39;production&#39;) { Vue.config.performance = true; }  来开启这一功能，该 API（2.2.0 新增）功能只适用于开发模式和支持 performance.mark API 的浏览器上，开启后我们可以下载 Vue Performance Devtool 这一 chrome 插件来看查看各个组件的加载情况，如图：
从中我们可以清晰的看到页面组件在每个阶段的耗时情况，而针对耗时比较久的组件，我们便可以对其进行相应优化。
而其在 Vue 源码中主要使用了 window.performance 来获取网页性能数据，其中包含了 performance.mark 和 performance.measure。
 performance.mark 主要用于创建标记 performance.measure 主要用于记录两个标记的时间间隔  例如：
performance.mark(&#39;start&#39;); // 创建 start 标记 performance.mark(&#39;end&#39;); // 创建 end 标记 performance.measure(&#39;output&#39;, &#39;start&#39;, &#39;end&#39;); // 计算两者时间间隔 performance.getEntriesByName(&#39;output&#39;); // 获取标记，返回值是一个数组，包含了间隔时间数据  熟练的使用 performance 我们可以查看并分析网页的很多数据，为我们项目优化提供保障。</description>
    </item>
    
    <item>
      <title>JS 模板</title>
      <link>http://192.168.31.10:8000/2017/template/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/template/</guid>
      <description> JS 模板 Juicer  GitHub  Soda  官方文档 GitHub  </description>
    </item>
    
    <item>
      <title>debugTools</title>
      <link>http://192.168.31.10:8000/2017/debugtools/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/debugtools/</guid>
      <description>抓包调试工具 Fidder的使用  下载地址  Fidder简介  抓包工具有很多，小到最常用的web调试工具firebug，达到通用的强大的抓包工具wireshark.为什么使用fiddler?原因如下： &amp;gt; a.Firebug虽然可以抓包，但是对于分析http请求的详细信息，不够强大。模拟http请求的功能也不够，且firebug常常是需要“无刷新修改”，如果刷新了页面，所有的修改都不会保存。 &amp;gt; b.Wireshark是通用的抓包工具，但是比较庞大，对于只需要抓取http请求的应用来说，似乎有些大材小用。 &amp;gt; c.Httpwatch也是比较常用的http抓包工具，但是只支持IE和firefox浏览器（其他浏览器可能会有相应的插件），对于想要调试chrome浏览器的http请求，似乎稍显无力，而Fiddler 是一个使用本地 127.0.0.1:8888 的 HTTP 代理，任何能够设置 HTTP 代理为 127.0.0.1:8888 的浏览器和应用程序都可以使用 Fiddler。
 对手机抓包  Tools &amp;gt; Options &amp;gt; https 勾选图中红线框出来的，之后会有弹窗提示安装证书。   Tools &amp;gt; Options &amp;gt; connections 勾选图中的   在手机上连接跟电脑在同一局域网下的网络，然后在无线网络中去设置代理，代理地址就是电脑ip地址和 端口号，之后在手机浏览器中输入 电脑ip地址和端口号 进行访问，会出下如下图，然后点击图中框出来的文字，下载并且安装证书。ios 比 安卓再多一个步骤，需要去 设置-&amp;gt;通用-&amp;gt;关于本机-&amp;gt;证书信任设置 去信任证书才可以进行抓包。  在电脑上对浏览器进行抓包  可以在浏览器设置里面设置代理，或者安装 Proxy SwitchyOmega 这个插件来管理代理，代理协议为 http，代理服务器为 127.0.0.1，端口号是在 fidder 上设置的端口号。  可以对fidder自定义规则(Rules -&amp;gt; Customize Rules)  下列设置中只能有一个OnBeforeResponse和OnBeforeResponse，下面只是为了方便演示代码位置才写了多个</description>
    </item>
    
    <item>
      <title>git commit emoji 使用指南</title>
      <link>http://192.168.31.10:8000/2017/git-commit-emoji/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/git-commit-emoji/</guid>
      <description>git commit emoji 使用指南 目录  commit 格式 emoji 指南 如何在命令行中显示 emoji 参考  git commit emoji write a good commit message   执行 git commit 时使用 emoji 为本次提交打上一个 &amp;ldquo;标签&amp;rdquo;, 使得此次 commit 的主要工作得以凸现，也能够使得其在整个提交历史中易于区分与查找。
截取的 gitmoji 快照:
commit 格式 git commit 时，提交信息遵循以下格式：
:emoji1: :emoji2: 不超过 50 个字的摘要，首字母大写，使用祈使语气，句末不要加句号 提交信息主体 引用相关 issue 或 PR 编号 &amp;lt;#110&amp;gt;  初次提交示例：
git commit -m &amp;quot;🎉 Initialize Repo&amp;quot;  emoji 指南    emoji emoji 代码 commit 说明     🎉 (庆祝) tada 初次提交   ✨ (火花) sparkles 引入新功能   🔖 (书签) bookmark 发行/版本标签   🐛 (bug) bug 修复 bug   🚑 (急救车) ambulance 重要补丁   🌐 (地球) globe_with_meridians 国际化与本地化   💄 (口红) lipstick 更新 UI 和样式文件   🚨 (警车灯) rotating_light 移除 linter 警告   🔧 (扳手) wrench 修改配置文件   ➕ (加号) heavy_plus_sign 增加一个依赖   ➖ (减号) heavy_minus_sign: 减少一个依赖   ⬆️ (上升箭头) arrow_up 升级依赖   ⬇️ (下降箭头) arrow_down 降级依赖   ⚡️ (闪电)</description>
    </item>
    
    <item>
      <title>git 相关总结</title>
      <link>http://192.168.31.10:8000/2017/git-summary/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/git-summary/</guid>
      <description>关于git的总结 git工作流 git相关  git 提交规范 git 简明指南 git 在线教程 git pro 中文教程
 Commitizen是一个撰写合格 Commit message 的工具。
  1.安装命令如下:
npm install -g commitizen  2.然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式
commitizen init cz-conventional-changelog --save --save-exact  3.以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message
 更多关于Commit message 和 Change log 编写指南可以到Commit message 和 Change log 编写指南查看&amp;hellip;  git操作 合并某个分支上的文件到应一个分支、回退到某个版本和 远程服务器上面回退到某个版本  git 合并某个分支上的文件到另一个分支上git checkout branch &amp;lt;path&amp;gt; git 本地回退到某个版本
git reset --hard 23bc94cf7e3c74c33dd4575dfbf72d6647333795   git 远程服务器上面回退到某个版本</description>
    </item>
    
    <item>
      <title>gulp 配置</title>
      <link>http://192.168.31.10:8000/2017/gulp/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/gulp/</guid>
      <description>项目中 gulp 的配置 项目目录结构 . ├── dist // 打包后的文件 ├── node_modules // 依赖模块 ├── src // 具体页面 | ├── namePage | ├── img // 图片 | └── xxx.png | ├── js // js文件 | └── xxx.js | ├── pages // 页面 | └── xxx.html | ├── sass // sass文件 | └── xxx.scss | └── sprite // 需要合成雪碧图的文件 | └── namePage | ├── img // 图片 | └── xxx.png | ├── js // js文件 | └── xxx.</description>
    </item>
    
    <item>
      <title>leetCode Easy</title>
      <link>http://192.168.31.10:8000/2017/leetcode-easy/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/leetcode-easy/</guid>
      <description>Easy Two Sum 两数之和(1)  给定一个整数数组，返回两个数字的索引，使它们相加到特定目标。您可以假设每个输入只有一个解决方案，并且您可能不会两次使用相同的元素。 例子：   Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].   解:  /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { // 第一种 let map = new Map() for (let i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>leetCode Medium</title>
      <link>http://192.168.31.10:8000/2017/leetcode-medium/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/leetcode-medium/</guid>
      <description>Add Two Numbers 两数相加(2)  给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
 例子:
  Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807   解:  // 单链表的定义 function ListNode(val) { this.val = val; this.next = null; } // 第一种 /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { if (l1===null) return l2; if (l2===null) return l1; //new a ListNode here, with head.</description>
    </item>
    
    <item>
      <title>常用工具集合</title>
      <link>http://192.168.31.10:8000/2017/tools/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/tools/</guid>
      <description> Docsify  一个神奇的文档网站生成工具 GitHub  Clover  Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。
 Everything  Everything 是 Windows 全局文件、文件夹 搜索软件。
 YoMail  YoMail 支持 Markdown 语法的邮箱客户端。
 PxCook  PxCook UI自动标注，生成前端css代码等。
 Imagine  Imagine 开源的 PNG/JPEG 压缩工具。
 Eruda  Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。
 vConsole  vConsole 是一个轻量、可拓展、针对手机网页的前端开发者调试面板。
 Weinre  Weinre 基于node平台 的远程运行调试web页面工具。官网。
 </description>
    </item>
    
    <item>
      <title>node版本管理</title>
      <link>http://192.168.31.10:8000/2017/node-version/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://192.168.31.10:8000/2017/node-version/</guid>
      <description>node版本管理 nvm 和 n  nvm
 Node版本管理器&amp;ndash;nvm，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件,可以在 windows 系统上使用 https://github.com/coreybutler/nvm-windows
 n
 这意味着，我们在使用 n 管理 node 版本前，首先需要一个 node 环境。我们或者用 Homebrew 来安装一个 node，或者从官网下载 pkg 来安装，总之我们得先自己装一个 node —— n 本身是没法给你装的。
然后我们可以使用 n 来安装不同版本的 node。
在安装的时候，n 会先将指定版本的 node 存储下来，然后将其复制到我们熟知的路径 /usr/local/bin，非常简单明了。当然由于 n 会操作到非用户目录，所以需要加 sudo 来执行命令。
所以这样看来，n 在其实现上是一个非常易理解的方案
https://github.com/tj/n
因为我的电脑是 windows 系统，所以使用的是 nvm for windows
nvm for windows  下载地址： https://github.com/coreybutler/nvm-windows/releases   nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置 nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便 Source code(zip)：zip压缩的源码 Sourc code(tar.</description>
    </item>
    
  </channel>
</rss>